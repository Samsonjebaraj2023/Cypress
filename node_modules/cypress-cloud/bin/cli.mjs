#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var init_esm_shims = __esm({
  "../../node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// bin/lib/@commander-js/extra-typings/index.js
var require_extra_typings = __commonJS({
  "bin/lib/@commander-js/extra-typings/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var commander = __require("commander");
    exports = module.exports = {};
    exports.program = new commander.Command();
    exports.Argument = commander.Argument;
    exports.Command = commander.Command;
    exports.CommanderError = commander.CommanderError;
    exports.Help = commander.Help;
    exports.InvalidArgumentError = commander.InvalidArgumentError;
    exports.InvalidOptionArgumentError = commander.InvalidArgumentError;
    exports.Option = commander.Option;
    exports.createCommand = (name) => new commander.Command(name);
    exports.createOption = (flags, description) => new commander.Option(flags, description);
    exports.createArgument = (name, description) => new commander.Argument(name, description);
  }
});

// bin/cli.ts
init_esm_shims();
import "source-map-support/register";

// lib/errors.ts
init_esm_shims();
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/log.ts
init_esm_shims();
import chalk from "chalk";
import util from "util";
var log = (...args) => console.log(util.format(...args));
var info = log;
var format = util.format;
var withError = (msg) => chalk.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => chalk.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(util.format(...args)));
var error = (...args) => log(withError(util.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + chalk[color].bold(util.format(...args)) + "  \n");
var divider = () => console.log("\n" + chalk.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = chalk.cyan;
var blue = chalk.blueBright;
var red = chalk.red;
var green = chalk.greenBright;
var gray = chalk.gray;
var white = chalk.white;
var magenta = chalk.magenta;
var bold = chalk.bold;
var yellow = chalk.yellow;
var dim = chalk.dim;

// lib/run.ts
init_esm_shims();

// lib/init.ts
init_esm_shims();

// lib/require.ts
init_esm_shims();
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);

// lib/stdout.ts
init_esm_shims();
import cp from "child_process";
var orginal = cp.spawn;
cp.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws/index.ts
init_esm_shims();

// lib/ws/ws.ts
init_esm_shims();
import Debug from "debug";
import http from "http";
import HttpTerminator from "lil-http-terminator";
import { match, P } from "ts-pattern";
import * as WebSocket from "ws";

// lib/pubsub.ts
init_esm_shims();
import EventEmitter from "events";
var pubsub = new EventEmitter();

// lib/ws/ws.ts
var debug = Debug("currents:ws");
var server = null;
var wss = null;
var httpTerminator = null;
var getWSSPort = () => match(server?.address()).with({ port: P.number }, (address) => address.port).otherwise(() => 0);
var stopWSS = async () => {
  debug("terminating wss server: %d", getWSSPort());
  if (!httpTerminator) {
    debug("no wss server");
    return;
  }
  const { success, code, message, error: error2 } = await httpTerminator.terminate();
  if (!success) {
    if (code === "TIMED_OUT")
      error2(message);
    if (code === "SERVER_ERROR")
      error2(message, error2);
    if (code === "INTERNAL_ERROR")
      error2(message, error2);
  }
  debug("terminated wss server: %d", getWSSPort());
};
var startWSS = () => {
  if (wss) {
    return;
  }
  server = http.createServer().on("listening", () => {
    if (!server) {
      throw new Error("Server not initialized");
    }
    wss = new WebSocket.WebSocketServer({
      server
    });
    debug("starting wss on port %d", getWSSPort());
    wss.on("connection", function connection(ws) {
      ws.on("message", function incoming(event) {
        const message = JSON.parse(event.toString());
        pubsub.emit(message.type, message.payload);
      });
    });
  }).listen();
  httpTerminator = HttpTerminator({
    server
  });
};

// lib/capture.ts
init_esm_shims();
import Debug2 from "debug";
var debug2 = Debug2("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug2("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug2("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/index.ts
init_esm_shims();

// lib/httpClient/config.ts
init_esm_shims();
import { isAxiosError } from "axios";
var isRetriableError = (err) => {
  if (err.code === "ECONNABORTED") {
    return true;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  if (err.code === "ETIMEDOUT") {
    return true;
  }
  if (!isAxiosError(err)) {
    return false;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [5 * 1e3, 10 * 1e3, 30 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
init_esm_shims();
import axios from "axios";
import axiosRetry from "axios-retry";
import Debug7 from "debug";
import _5 from "lodash";
import prettyMilliseconds from "pretty-ms";

// lib/config/index.ts
init_esm_shims();

// lib/config/config.ts
init_esm_shims();
import Debug5 from "debug";
import { P as P2, match as match2 } from "ts-pattern";

// lib/bootstrap/index.ts
init_esm_shims();

// lib/bootstrap/bootstrap.ts
init_esm_shims();
import { getBinPath } from "cy2";
import Debug4 from "debug";
import execa from "execa";
import fs from "fs";

// lib/fs.ts
init_esm_shims();
import { file } from "tmp-promise";
var createTempFile = async () => {
  const { path: path5 } = await file();
  return path5;
};

// lib/bootstrap/serializer.ts
init_esm_shims();
import Debug3 from "debug";
import _ from "lodash";
import { customAlphabet } from "nanoid";
var debug3 = Debug3("currents:boot");
var getDummySpec = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  tempFilePath
}) {
  return _.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug3("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug3("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ..._.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (_.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug4 = Debug4("currents:boot");
var bootCypress = async (params) => {
  debug4("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await getBinPath(require2.resolve("cypress"));
  debug4("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ tempFilePath, params });
  debug4("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!fs.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = fs.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug4("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug4("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await execa(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug4("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/config/path.ts
init_esm_shims();
import isAbsolute from "is-absolute";
import _2 from "lodash";
import path2 from "path";
var defaultFilenames = [
  "currents.config.js",
  "currents.config.cjs",
  "currents.config.mjs"
];
function getConfigFilePath(projectRoot = null, explicitConfigFilePath) {
  const prefix = projectRoot ?? process.cwd();
  if (_2.isString(explicitConfigFilePath) && isAbsolute(explicitConfigFilePath)) {
    return [explicitConfigFilePath];
  }
  if (_2.isString(explicitConfigFilePath)) {
    return [normalizePath(prefix, explicitConfigFilePath)];
  }
  return defaultFilenames.map((p) => normalizePath(prefix, p));
}
function normalizePath(prefix, filename) {
  return `file://${path2.resolve(prefix, filename)}`;
}

// lib/config/config.ts
var debug5 = Debug5("currents:config");
var _config = null;
var defaultConfig = {
  e2e: {
    batchSize: 3
  },
  component: {
    batchSize: 5
  },
  cloudServiceUrl: "https://cy.currents.dev",
  networkHeaders: void 0
};
async function getCurrentsConfig(projectRoot, explicitConfigFilePath) {
  if (_config) {
    return _config;
  }
  const configFilePath = getConfigFilePath(projectRoot, explicitConfigFilePath);
  for (const filepath of configFilePath) {
    const config = match2(await loadConfigFile(filepath)).with({ default: P2.not(P2.nullish) }, (c) => c.default).with(P2.not(P2.nullish), (c) => c).otherwise(() => null);
    if (config) {
      debug5("loaded currents config from '%s'\n%O", filepath, config);
      info("Using config file: '%s'", filepath);
      _config = {
        ...defaultConfig,
        ...config
      };
      return _config;
    }
  }
  warn(
    "Failed to load config file, falling back to the default config. Attempted locations: %s",
    configFilePath
  );
  _config = defaultConfig;
  return _config;
}
async function loadConfigFile(filepath) {
  try {
    debug5("loading currents config file from '%s'", filepath);
    return await import(filepath);
  } catch (e) {
    debug5("failed loading config file from: %s", e);
    return null;
  }
}
async function getMergedConfig(params) {
  debug5("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(params);
  debug5("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig,
    experimentalCoverageRecording: params.experimentalCoverageRecording
  };
  debug5("merged config: %O", result);
  return result;
}

// lib/config/params.ts
init_esm_shims();
import Debug6 from "debug";
import _3 from "lodash";
var debug6 = Debug6("currents:validateParams");
async function resolveCurrentsParams(params) {
  const configFromFile = await getCurrentsConfig(
    params.project,
    params.cloudConfigFile
  );
  debug6("resolving currents params: %o", params);
  debug6("resolving currents config file: %o", configFromFile);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.{c}js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.{c}js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.{c}js" file
`;
async function validateParams(_params) {
  const params = await resolveCurrentsParams(_params);
  debug6("validating currents params: %o", params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug6("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ..._3.pickBy(
      _3.omit(params, [
        "cloudDebug",
        "cloudConfigFile",
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headless",
        "experimentalCoverageRecording"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return _3.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/httpClient/printErrors.ts
init_esm_shims();
import _4 from "lodash";
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!_4.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug7 = Debug7("currents:api");
var MAX_RETRIES = 3;
var TIMEOUT_MS = 30 * 1e3;
var _client = null;
async function getClient() {
  if (_client) {
    return _client;
  }
  const currentsConfig = await getCurrentsConfig();
  _client = axios.create({
    baseURL: getAPIBaseUrl(),
    timeout: TIMEOUT_MS
  });
  _client.interceptors.request.use((config) => {
    const ccyVerson = _currentsVersion ?? "0.0.0";
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": ccyVerson,
      "User-Agent": `cypress-cloud/${ccyVerson}`
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    if (currentsConfig.networkHeaders) {
      const filteredHeaders = _5.omit(currentsConfig.networkHeaders, [
        "x-cypress-request-attempt",
        "x-cypress-version",
        "x-ccy-version",
        "x-cypress-run-id",
        "Content-Type"
      ]);
      debug7("using custom network headers: %o", filteredHeaders);
      Object.assign(headers, filteredHeaders);
    }
    const req = {
      ...config,
      headers
    };
    debug7("network request: %o", {
      ..._5.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  axiosRetry(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry,
    shouldResetTimeout: true
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, config) {
  warn(
    "Network request '%s' failed: '%s'. Next attempt is in %s (%d/%d).",
    `${config.method} ${config.url}`,
    err.message,
    prettyMilliseconds(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = async (config) => {
  return (await getClient())(config).then((res) => {
    debug7("network response: %o", _5.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
import Debug19 from "debug";
import plur from "plur";

// legal.ts
init_esm_shims();
function getLegalNotice() {
  return `
Copyright (C) ${(/* @__PURE__ */ new Date()).getFullYear()} Currents Software Inc https://currents.dev
This is free software, and you are welcome to redistribute it under certain
conditions. This program comes with no warranty. Parts of this program are MIT
licensed. Refer to the license for details
https://github.com/currents-dev/cypress-cloud/blob/main/LICENSE.md
`;
}

// lib/api/index.ts
init_esm_shims();

// lib/api/api.ts
init_esm_shims();

// lib/api/warnings.ts
init_esm_shims();
import _6 from "lodash";
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(_6.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/api/types/index.ts
init_esm_shims();

// lib/api/types/instance.ts
init_esm_shims();

// lib/api/types/run.ts
init_esm_shims();

// lib/api/types/test.ts
init_esm_shims();

// lib/ciProvider/index.ts
init_esm_shims();

// lib/ciProvider/ciProvider.ts
init_esm_shims();
import debugFn from "debug";
import _7 from "lodash";
var debug8 = debugFn("currents:ci");
var join = (char, ...pieces) => {
  return _7.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return _7.set(obj, _7.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return _7.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return _7.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return _7.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return _7.findKey(CI_PROVIDERS, (value) => {
    if (_7.isString(value)) {
      return env[value];
    }
    if (_7.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return _7.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return _7.chain(_providerCiParams()).omitBy(_7.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug8("detected CI provider: %s", provider);
  debug8("detected CI params: %O", params);
  return {
    params,
    provider
  };
}

// lib/ciProvider/merge.ts
init_esm_shims();
import debugFn2 from "debug";
import _8 from "lodash";
var debug9 = debugFn2("currents:ci");
function getCommitDefaults(existingInfo) {
  debug9("git commit existing info");
  debug9(existingInfo);
  const commitParamsObj = getCommitParams();
  debug9("commit info from provider environment variables: %O", commitParamsObj);
  const combined = _8.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = _8.defaultTo(
        value || (commitParamsObj ? commitParamsObj[key] : null),
        null
      );
    }
  );
  debug9("combined git and environment variables from provider");
  debug9(combined);
  return combined;
}

// lib/coverage/index.ts
init_esm_shims();
import fs2 from "fs/promises";
import { join as join2 } from "path";
var getCoverageFilePath = async (coverageFile = "./.nyc_output/out.json") => {
  const path5 = join2(process.cwd(), coverageFile);
  try {
    await fs2.access(path5);
    return {
      path: path5,
      error: false
    };
  } catch (error2) {
    return {
      path: path5,
      error: error2
    };
  }
};

// lib/cypress/index.ts
init_esm_shims();

// lib/cypress/cypress.ts
init_esm_shims();
import cypress from "cypress";
import Debug8 from "debug";
import _9 from "lodash";

// lib/lang.ts
init_esm_shims();
import bluebird from "bluebird";
bluebird.Promise.config({
  cancellation: true
});
var BPromise = bluebird.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    return ifFaled(e);
  }
};

// lib/cypress/cypress.ts
var debug10 = Debug8("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: _9.flatten(params.spec).join(",")
  };
  debug10("Running bare Cypress with params %o", p);
  return cypress.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: getWSSPort()
    },
    spec
  };
  debug10("running cypress with options %o", options);
  let result = await cypress.run(options);
  let retries = 0;
  const currentsConfig = await getCurrentsConfig();
  while (currentsConfig.retry && retries < (currentsConfig.retry.hardFailureMaxRetries ?? 0) && result.status === "failed") {
    warn("Cypress runner failed with message: %s", result.message);
    warn(
      "[retry %d/%d] Retrying the following spec files because of retry config: %s",
      retries + 1,
      currentsConfig.retry.hardFailureMaxRetries,
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    result = await cypress.run(options);
    retries++;
  }
  if (currentsConfig.retry && retries > 0) {
    warn(
      "Exhausted max retries: %d/%d",
      retries,
      currentsConfig.retry.hardFailureMaxRetries
    );
  }
  if (result.status === "failed") {
    warn('Cypress runner failed with message: "%s"', result.message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
  }
  debug10("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = (spec, cypressRunOptions) => safe(
  runSpecFile,
  (error2) => {
    const message = `Cypress runnner crashed with an error:
${error2.message}
${error2.stack}}`;
    debug10("cypress run exception %o", error2);
    warn('Cypress runner crashed: "%s"', message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    return {
      status: "failed",
      failures: 1,
      message
    };
  },
  () => {
  }
)(spec, cypressRunOptions);

// lib/debug/index.ts
init_esm_shims();
import debug11 from "debug";
import { match as match3, P as P3 } from "ts-pattern";

// types.ts
init_esm_shims();
var DebugMode = /* @__PURE__ */ ((DebugMode2) => {
  DebugMode2["None"] = "none";
  DebugMode2["All"] = "all";
  DebugMode2["Currents"] = "currents";
  DebugMode2["Cypress"] = "cypress";
  DebugMode2["CommitInfo"] = "commit-info";
  return DebugMode2;
})(DebugMode || {});

// lib/debug/index.ts
function activateDebug(mode) {
  match3(mode).with(P3.instanceOf(Array), (i) => i.forEach(setDebugMode)).with(true, () => setDebugMode("all" /* All */)).with(
    P3.union(
      "all" /* All */,
      "currents" /* Currents */,
      "cypress" /* Cypress */,
      "commit-info" /* CommitInfo */
    ),
    (i) => setDebugMode(i)
  ).otherwise(() => setDebugMode("none" /* None */));
}
function setDebugMode(mode) {
  if (mode === "none" /* None */) {
    return;
  }
  const tokens = new Set(process.env.DEBUG ? process.env.DEBUG.split(",") : []);
  match3(mode).with("all" /* All */, () => {
    tokens.add("commit-info" /* CommitInfo */);
    tokens.add("currents:*" /* Currents */);
    tokens.add("cypress:*" /* Cypress */);
  }).with("currents" /* Currents */, () => tokens.add("currents:*" /* Currents */)).with("cypress" /* Cypress */, () => tokens.add("cypress:*" /* Cypress */)).with("commit-info" /* CommitInfo */, () => tokens.add("commit-info" /* CommitInfo */)).otherwise(() => {
  });
  debug11.enable(Array.from(tokens).join(","));
}

// lib/env.ts
init_esm_shims();
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/git.ts
init_esm_shims();
import { commitInfo } from "@currents/commit-info";
var getGitInfo = async (projectRoot) => {
  const commit = await commitInfo(projectRoot);
  return getCommitDefaults({
    branch: commit.branch,
    remoteOrigin: commit.remote,
    authorEmail: commit.email,
    authorName: commit.author,
    message: commit.message,
    sha: commit.sha,
    ghaEventData: commit.ghaEventData
  });
};

// lib/platform/index.ts
init_esm_shims();

// lib/platform/browser.ts
init_esm_shims();
import Debug9 from "debug";
var debug12 = Debug9("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug12(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug12("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug12("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
init_esm_shims();
import Debug10 from "debug";
import getos from "getos";
import { cpus, freemem, platform, release, totalmem } from "os";
import { promisify } from "util";
var debug13 = Debug10("currents:platform");
var getOsVersion = async () => {
  if (platform() === "linux") {
    try {
      const linuxOs = await promisify(getos)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return release();
      }
    } catch {
      return release();
    }
  }
  return release();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: platform(),
    osVersion,
    osCpus: cpus(),
    osMemory: {
      free: freemem(),
      total: totalmem()
    }
  };
  debug13("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/index.ts
init_esm_shims();

// lib/results/results.ts
init_esm_shims();
import Debug11 from "debug";
import _10 from "lodash";
import { nanoid } from "nanoid";
var debug14 = Debug11("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: nanoid()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult, coverageFilePath) => {
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    hasCoverage: !!coverageFilePath,
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? []
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? [],
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: _10.first(startItems),
    endedTestsAt: _10.last(endItems),
    ..._10.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
var getDummyFailedTest = (start, error2) => ({
  title: ["Unknown"],
  state: "failed",
  body: "// This test is automatically generated due to execution failure",
  displayError: error2,
  attempts: [
    {
      state: "failed",
      startedAt: start,
      duration: 0,
      videoTimestamp: 0,
      screenshots: [],
      error: {
        name: "CypressExecutionError",
        message: error2,
        stack: ""
      }
    }
  ]
});
function getFailedDummyResult(configState, {
  specs,
  error: error2
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    // @ts-ignore
    config: configState.getConfig() ?? {},
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: s,
        absolute: s,
        relativeToCommonRoot: s
      },
      tests: [getDummyFailedTest(start, error2)],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function getCypressRunResultForSpec(spec, cypressResult) {
  if (!isSuccessResult(cypressResult)) {
    return;
  }
  const run2 = cypressResult.runs.find((r) => r.spec.relative === spec);
  if (!run2) {
    return;
  }
  const stats = getStats(run2.stats);
  return {
    ...cypressResult,
    runs: [run2],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
init_esm_shims();
import _11 from "lodash";
import prettyMS from "pretty-ms";
import { table } from "table";
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = _11.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray(prettyMS(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return table(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray(prettyMS(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = _11.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
init_esm_shims();
import Debug14 from "debug";

// lib/artifacts.ts
init_esm_shims();
import Debug13 from "debug";

// lib/upload.ts
init_esm_shims();
import Debug12 from "debug";
import fs3 from "fs";
var readFile = fs3.promises.readFile;
var debug15 = Debug12("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
function uploadJson(file2, url) {
  return uploadFile(file2, url, "application/json");
}
async function uploadFile(file2, url, type) {
  debug15('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type,
      "Content-Disposition": `inline`
    }
  });
}

// lib/artifacts.ts
var debug16 = Debug13("currents:artifacts");
async function uploadArtifacts({
  executionState,
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls,
  coverageFilePath,
  coverageUploadUrl
}) {
  debug16("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls,
    coverageFilePath,
    coverageUploadUrl
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length + (coverageUploadUrl ? 1 : 0);
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => {
        debug16("failed uploading video %s. Error: %o", videoPath, e);
        executionState.addWarning(
          `Failed uploading video ${videoPath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug16(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          executionState.addWarning(
            `No upload URL for screenshot ${screenshot.path}`
          );
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => {
            debug16(
              "failed uploading screenshot %s. Error: %o",
              screenshot.path,
              e
            );
            executionState.addWarning(
              `Failed uploading screenshot ${screenshot.path}.
${dim(e)}`
            );
          },
          () => debug16("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
  if (coverageUploadUrl && coverageFilePath) {
    await safe(
      uploadJson,
      (e) => {
        debug16(
          "failed uploading coverage file %s. Error: %o",
          coverageFilePath,
          e
        );
        executionState.addWarning(
          `Failed uploading coverage file ${coverageFilePath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", coverageFilePath)
    )(coverageFilePath, coverageUploadUrl);
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/cancellation/index.ts
init_esm_shims();

// lib/cancellation/cancellation.ts
init_esm_shims();
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug17 = Debug14("currents:results");
async function getReportResultsTask(instanceId, configState, executionState, stdout2, coverageFilePath) {
  const results = executionState.getInstanceResults(configState, instanceId);
  const run2 = results.runs[0];
  if (!run2) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run2, coverageFilePath);
  const instanceTests = getInstanceTestsPayload(run2, results.config);
  const { videoUploadUrl, screenshotUploadUrls, coverageUploadUrl, cloud } = await reportResults(instanceId, instanceTests, instanceResults);
  if (cloud?.shouldCancel) {
    debug17("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug17("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls,
    coverageUploadUrl
  });
  return Promise.all([
    uploadArtifacts({
      executionState,
      videoUploadUrl,
      videoPath: run2.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots,
      coverageUploadUrl,
      coverageFilePath
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug17("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/index.ts
init_esm_shims();

// lib/runner/cancellable.ts
init_esm_shims();

// lib/runner/runner.ts
init_esm_shims();
import Debug16 from "debug";

// lib/runner/reportTask.ts
init_esm_shims();
import Debug15 from "debug";
var debug18 = Debug15("currents:reportTask");
var reportTasks = [];
var createReportTask = (configState, executionState, instanceId) => {
  const instance = executionState.getInstance(instanceId);
  if (!instance) {
    error("Cannot find execution state for instance %s", instanceId);
    return;
  }
  if (instance.reportStartedAt) {
    debug18("Report task already created for instance %s", instanceId);
    return;
  }
  instance.reportStartedAt = /* @__PURE__ */ new Date();
  debug18("Creating report task for instanceId %s", instanceId);
  reportTasks.push(
    getReportResultsTask(
      instanceId,
      configState,
      executionState,
      instance.output ?? "no output captured",
      instance.coverageFilePath
    ).catch(error)
  );
};
var createReportTaskSpec = (configState, executionState, spec) => {
  const i = executionState.getSpec(spec);
  if (!i) {
    error("Cannot find execution state for spec %s", spec);
    return;
  }
  debug18("Creating report task for spec %s", spec);
  return createReportTask(configState, executionState, i.instanceId);
};

// lib/runner/runner.ts
var debug19 = Debug16("currents:runner");
async function runTillDone(executionState, configState, {
  runId,
  groupId,
  machineId,
  platform: platform2,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch(executionState, configState, {
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params
    });
    if (!newTasks.length) {
      debug19("No more tasks to run. Uploads queue: %d", reportTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach(
      (t) => createReportTask(configState, executionState, t.instanceId)
    );
  }
}
async function runBatch(executionState, configState, {
  runMeta,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug19("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug19("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  batch.specs.forEach((i) => executionState.initInstance(i));
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths - user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still report the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  batch.specs.forEach((spec) => {
    executionState.setInstanceOutput(spec.instanceId, output);
    const specRunResult = getCypressRunResultForSpec(spec.spec, rawResult);
    if (!specRunResult) {
      return;
    }
    executionState.setInstanceResult(
      configState,
      spec.instanceId,
      specRunResult
    );
  });
  resetCapture();
  return batch.specs;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(void 0));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(void 0);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/shutdown.ts
init_esm_shims();
async function shutdown() {
  await stopWSS();
}

// lib/specMatcher/index.ts
init_esm_shims();

// lib/specMatcher/getSpecFiles.ts
init_esm_shims();

// lib/specMatcher/specMatcher.ts
init_esm_shims();
import Debug17 from "debug";
import path4 from "path";
import commonPathPrefix from "common-path-prefix";
import globby from "globby";
import _12 from "lodash";
import os from "os";

// lib/utils.ts
init_esm_shims();
import path3 from "path";
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = path3.sep) {
  return file2.split(sep).join(path3.posix.sep);
}

// lib/specMatcher/specMatcher.ts
var debug20 = Debug17("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug20("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!_12.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = _12.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = path4.join(projectRoot, path4.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (os.platform() === "win32") {
    debug20("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug20("globbing pattern(s): %o", globs);
    debug20("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug20("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await globby(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug20("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = path4.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = commonPathPrefix(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: os.platform(),
      sep: path4.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = path4.relative(projectRoot, absolute);
  const parsedFile = path4.parse(absolute);
  const fileExtension = path4.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/state/index.ts
init_esm_shims();

// lib/state/config.ts
init_esm_shims();
var ConfigState = class {
  constructor() {
    this._config = void 0;
  }
  setConfig(c) {
    this._config = c;
  }
  getConfig() {
    return this._config;
  }
};

// lib/state/execution.ts
init_esm_shims();

// lib/results/mapResult.ts
init_esm_shims();
function getScreenshot(s) {
  return {
    ...s,
    name: s.name ?? "screenshot"
  };
}
function getTestAttempt2(attempt, screenshots) {
  return {
    ...attempt,
    startedAt: attempt.wallClockStartedAt,
    duration: attempt.wallClockDuration,
    screenshots: screenshots.map(getScreenshot)
  };
}
function getTest(t, screenshots) {
  const _screenshots = screenshots.filter((s) => s.testId === t.testId);
  return {
    ...t,
    attempts: t.attempts.map(
      (a, i) => getTestAttempt2(
        a,
        _screenshots.filter((s) => s.testAttemptIndex === i)
      )
    )
  };
}
function specResultsToCypressResults(configState, specAfterResult) {
  return {
    status: "finished",
    // @ts-ignore
    config: configState.getConfig(),
    totalDuration: specAfterResult.stats.wallClockDuration,
    totalSuites: specAfterResult.stats.suites,
    totalTests: specAfterResult.stats.tests,
    totalFailed: specAfterResult.stats.failures,
    totalPassed: specAfterResult.stats.passes,
    totalPending: specAfterResult.stats.pending,
    totalSkipped: specAfterResult.stats.skipped,
    startedTestsAt: specAfterResult.stats.wallClockStartedAt,
    endedTestsAt: specAfterResult.stats.wallClockEndedAt,
    runs: [
      {
        stats: {
          ...specAfterResult.stats,
          startedAt: specAfterResult.stats.wallClockStartedAt,
          endedAt: specAfterResult.stats.wallClockEndedAt,
          duration: specAfterResult.stats.wallClockDuration
        },
        reporter: specAfterResult.reporter,
        reporterStats: specAfterResult.reporterStats ?? {},
        spec: specAfterResult.spec,
        error: specAfterResult.error,
        video: specAfterResult.video,
        shouldUploadVideo: true,
        // not really used
        // @ts-ignore
        // wrong typedef for CypressCommandLine.CypressRunResult
        // actual HookName is "before all" | "before each" | "after all" | "after each"
        hooks: specAfterResult.hooks,
        tests: (specAfterResult.tests ?? []).map(
          (t) => getTest(t, specAfterResult.screenshots)
        )
      }
    ]
  };
}
var backfillException = (result) => {
  return {
    ...result,
    runs: result.runs.map(backfillExceptionRun)
  };
};
var backfillExceptionRun = (run2) => {
  if (!run2.error) {
    return run2;
  }
  return {
    ...run2,
    tests: [getFakeTestFromException(run2.error, run2.stats)]
  };
};

// lib/state/execution.ts
import Debug18 from "debug";
var debug21 = Debug18("currents:state");
var ExecutionState = class {
  constructor() {
    this.warnings = /* @__PURE__ */ new Set();
    this.state = {};
  }
  getWarnings() {
    return this.warnings;
  }
  addWarning(warning) {
    this.warnings.add(warning);
  }
  getResults(configState) {
    return Object.values(this.state).map(
      (i) => this.getInstanceResults(configState, i.instanceId)
    );
  }
  getInstance(instanceId) {
    return this.state[instanceId];
  }
  getSpec(spec) {
    return Object.values(this.state).find((i) => i.spec === spec);
  }
  initInstance({
    instanceId,
    spec
  }) {
    debug21('Init execution state for "%s"', spec);
    this.state[instanceId] = {
      instanceId,
      spec,
      createdAt: /* @__PURE__ */ new Date()
    };
  }
  setSpecBefore(spec) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specBefore = /* @__PURE__ */ new Date();
  }
  setSpecCoverage(spec, coverageFilePath) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    debug21("Experimental: coverageFilePath was set");
    i.coverageFilePath = coverageFilePath;
  }
  setSpecAfter(spec, results) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specAfter = /* @__PURE__ */ new Date();
    i.specAfterResults = results;
  }
  setSpecOutput(spec, output) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    this.setInstanceOutput(i.instanceId, output);
  }
  setInstanceOutput(instanceId, output) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    if (i.output) {
      debug21('Instance "%s" already has output', instanceId);
      return;
    }
    i.output = output;
  }
  setInstanceResult(configState, instanceId, results) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    i.runResults = results;
    i.runResultsReportedAt = /* @__PURE__ */ new Date();
  }
  getInstanceResults(configState, instanceId) {
    const i = this.getInstance(instanceId);
    if (!i) {
      error('Cannot find execution state for instance "%s"', instanceId);
      return getFailedDummyResult(configState, {
        specs: ["unknown"],
        error: "Cannot find execution state for instance"
      });
    }
    if (i.specAfterResults) {
      return backfillException(
        specResultsToCypressResults(configState, i.specAfterResults)
      );
    }
    if (i.runResults) {
      return backfillException(i.runResults);
    }
    debug21('No results detected for "%s"', i.spec);
    return getFailedDummyResult(configState, {
      specs: [i.spec],
      error: `No results detected for the spec file. That usually happens because of cypress crash. See the console output for details.`
    });
  }
};

// lib/run.ts
var debug22 = Debug19("currents:run");
async function run(params = {}) {
  const executionState = new ExecutionState();
  const configState = new ConfigState();
  activateDebug(params.cloudDebug);
  debug22("run params %o", params);
  params = preprocessParams(params);
  debug22("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = await validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  if (!isCurrents()) {
    console.log(getLegalNotice());
  }
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    experimentalCoverageRecording
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  configState.setConfig(config?.resolved);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run2 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    coverageEnabled: experimentalCoverageRecording,
    previousCiBuildId: process.env.CURRENTS_PREVIOUS_CI_BUILD_ID,
    providedMachineId: process.env.CURRENTS_MACHINE_ID
  });
  setRunId(run2.runId);
  info("\u{1F3A5} Run URL:", bold(run2.runUrl));
  process.env.CURRENTS_MACHINE_ID ? info("\u{1F916} Machine ID:", bold(run2.machineId)) : null;
  cutInitialOutput();
  await startWSS();
  listenToSpecEvents(
    configState,
    executionState,
    config.experimentalCoverageRecording
  );
  await runTillDoneOrCancelled(
    executionState,
    configState,
    {
      runId: run2.runId,
      groupId: run2.groupId,
      machineId: run2.machineId,
      platform: platform2,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(reportTasks);
  const _summary = summarizeTestResults(
    executionState.getResults(configState),
    config
  );
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  printWarnings2(executionState);
  info("\n\u{1F3C1} Recorded Run:", bold(run2.runUrl));
  await shutdown();
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run2.runUrl
    };
  }
  return _summary;
}
function listenToSpecEvents(configState, executionState, experimentalCoverageRecording) {
  const config = configState.getConfig();
  pubsub.on("before:spec", async ({ spec }) => {
    debug22("before:spec %o", spec);
    executionState.setSpecBefore(spec.relative);
  });
  pubsub.on(
    "after:spec",
    async ({ spec, results }) => {
      debug22("after:spec %o %o", spec, results);
      executionState.setSpecAfter(spec.relative, results);
      executionState.setSpecOutput(spec.relative, getCapturedOutput());
      if (experimentalCoverageRecording) {
        const { path: path5, error: error2 } = await getCoverageFilePath(
          config?.env?.coverageFile
        );
        if (!error2) {
          executionState.setSpecCoverage(spec.relative, path5);
        } else {
          executionState.addWarning(
            `Could not process coverage file "${path5}"
${dim(error2)}`
          );
        }
      }
      createReportTaskSpec(configState, executionState, spec.relative);
    }
  );
}
function printWarnings2(executionState) {
  const warnings = Array.from(executionState.getWarnings());
  if (warnings.length > 0) {
    warn(
      `${warnings.length} ${plur(
        "Warning",
        warnings.length
      )} encountered during the execution:
${warnings.map((w, i) => `
${yellow(`[${i + 1}/${warnings.length}]`)} ${w}`).join("\n")}`
    );
  }
}

// bin/lib/index.ts
init_esm_shims();

// bin/lib/cli.ts
init_esm_shims();
import Debug20 from "debug";

// bin/lib/parser.ts
init_esm_shims();
import _13 from "lodash";
import assert from "node:assert";
var nestedObjectsInCurlyBracesRe = /\{(.+?)\}/g;
var nestedArraysInSquareBracketsRe = /\[(.+?)\]/g;
var everythingAfterFirstEqualRe = /=(.*)/;
var sanitizeAndConvertNestedArgs = (str, argName) => {
  if (!str) {
    return;
  }
  assert(_13.isString(argName) && argName.trim() !== "");
  try {
    if (typeof str === "object") {
      return str;
    }
    const parsed = tryJSONParse(str);
    if (parsed) {
      return parsed;
    }
    return _13.chain(str).replace(nestedObjectsInCurlyBracesRe, commasToPipes).replace(nestedArraysInSquareBracketsRe, commasToPipes).split(",").map((pair) => {
      return pair.split(everythingAfterFirstEqualRe);
    }).fromPairs().mapValues(JSONOrCoerce).value();
  } catch (err) {
    error("could not parse CLI option '%s' value: %s", argName, str);
    error("error %o", err);
    return void 0;
  }
};
var tryJSONParse = (str) => {
  try {
    return JSON.parse(str) === Infinity ? null : JSON.parse(str);
  } catch (err) {
    return null;
  }
};
var commasToPipes = (match4) => {
  return match4.split(",").join("|");
};
var pipesToCommas = (str) => {
  return str.split("|").join(",");
};
var JSONOrCoerce = (str) => {
  const parsed = tryJSONParse(str);
  if (parsed) {
    return parsed;
  }
  str = pipesToCommas(str);
  const parsed2 = tryJSONParse(str);
  if (parsed2) {
    return parsed2;
  }
  return coerce(str);
};
var coerce = (value) => {
  const num = _13.toNumber(value);
  if (_13.invoke(num, "toString") === value) {
    return num;
  }
  const bool = toBoolean(value);
  if (_13.invoke(bool, "toString") === value) {
    return bool;
  }
  const obj = tryJSONParse(value);
  if (obj && typeof obj === "object") {
    return obj;
  }
  const arr = _13.toArray(value);
  if (_13.invoke(arr, "toString") === value) {
    return arr;
  }
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      return value;
  }
};

// bin/lib/program.ts
init_esm_shims();
var import_extra_typings = __toESM(require_extra_typings());
var createProgram = (command = new import_extra_typings.Command()) => command.name("cypress-cloud").description(
  `
Run Cypress tests on CI using https://currents.dev or https://sorry-cypress.dev as an orchestration and reporting service

${getLegalNotice()}
      `
).option(
  "-b, --browser <browser-name-or-path>",
  "runs Cypress in the browser with the given name; if a filesystem path is supplied, Cypress will attempt to use the browser at that path"
).option(
  "--ci-build-id <id>",
  "the unique identifier for a run, this value is automatically detected for most CI providers"
).addOption(
  new import_extra_typings.Option("--component", "runs Cypress component test").default(false).implies({
    e2e: false
  })
).option(
  "-c, --config <config>",
  "sets Cypress configuration values. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs}"
).option(
  "-e, --env <env>",
  "sets environment variables. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs} or cypress.env.json"
).option(
  "-C, --config-file <config-file>",
  'specify Cypress config file, path to script file where Cypress configuration values are set. defaults to "cypress.config.{js,ts,mjs,cjs}"'
).addOption(new import_extra_typings.Option("--e2e", "runs end to end tests").default(true)).option("--group <name>", "a named group for recorded runs in Currents").addOption(
  new import_extra_typings.Option(
    "-k, --key <record-key>",
    "your secret Record Key obtained from Currents. you can omit this if you set a CURRENTS_RECORD_KEY environment variable"
  ).env("CURRENTS_RECORD_KEY")
).option(
  "--parallel",
  "enables concurrent runs and automatic load balancing of specs across multiple machines or processes",
  false
).addOption(
  new import_extra_typings.Option(
    "-p, --port <number>",
    "runs Cypress on a specific port. overrides any value in cypress.config.{js,ts,mjs,cjs}"
  ).argParser((i) => parseInt(i, 10))
).option(
  "-P, --project <project-path>",
  "path to your Cypress project root location - defaults to the current working directory"
).option("-q, --quiet", "suppress verbose output from Cypress").addOption(
  new import_extra_typings.Option(
    "--record [bool]",
    "records the run and sends test results, screenshots and videos to Currents"
  ).default(true).argParser((i) => i === "false" ? false : true)
).option(
  "-r, --reporter <reporter>",
  'use a specific mocha reporter for Cypress, pass a path to use a custom reporter, defaults to "spec"'
).option(
  "-o, --reporter-options <reporter-options>",
  'options for the mocha reporter. defaults to "null"'
).addOption(
  new import_extra_typings.Option(
    "-s, --spec <spec-pattern>",
    'define specific glob pattern for running the spec file(s), Defaults to the "specMatch" entry from the "cypress.config.{js,ts,mjs,cjs}" file'
  ).argParser(parseCommaSeparatedList)
).option(
  "-t, --tag <tag>",
  "comma-separated tag(s) for recorded runs in Currents",
  parseCommaSeparatedList
).addOption(
  new import_extra_typings.Option(
    "--auto-cancel-after-failures <number | false>",
    "Automatically abort the run after the specified number of failed tests. Overrides the default project settings. If set, must be a positive integer or 'false' to disable (Currents-only)"
  ).argParser(parseAutoCancelFailures)
).addOption(
  new import_extra_typings.Option("--headed [bool]", "Run cypress in headed mode").default(false).argParser((i) => i === "false" ? false : true)
).addOption(
  new import_extra_typings.Option(
    "--cloud-config-file <path>",
    "Specify the config file for cypress-cloud, defaults to 'currents.config.js' and will be searched in the project root, unless an absolute path is provided"
  ).default(void 0)
).addOption(
  new import_extra_typings.Option(
    `--cloud-debug [true | string]`,
    `Enable debug mode for cypress-cloud, this will print out logs for troubleshooting. Values: [true | ${Object.values(
      DebugMode
    ).join(
      " | "
    )}]. Use comma to separate multiple values, e.g. --cloud-debug commit-info,currents`
  ).argParser(parseCommaSeparatedList).default(void 0)
).addOption(
  new import_extra_typings.Option(
    `--experimental-coverage-recording [bool]`,
    `Enable recording coverage results, specify the "coverageFile" Cypress environment variable for a custom coverage file, default is "./.nyc_output/out.json"`
  ).default(void 0).argParser((i) => i === "false" ? false : true)
);
var program = createProgram();
function parseCommaSeparatedList(value, previous = []) {
  if (value) {
    return previous.concat(value.split(",").map((t) => t.trim()));
  }
  return previous;
}
function parseAutoCancelFailures(value) {
  if (value === "false") {
    return false;
  }
  const parsedValue = parseInt(value, 10);
  if (isNaN(parsedValue) || parsedValue < 1) {
    throw new Error(
      "Invalid argument provided. Must be a positive integer or 'false'."
    );
  }
  return parsedValue;
}

// bin/lib/cli.ts
var debug23 = Debug20("currents:cli");
function parseCLIOptions(_program = program, ...args) {
  const opts = _program.parse(...args).opts();
  activateDebug(opts.cloudDebug);
  debug23("parsed CLI flags %o", opts);
  const { e2e, component } = opts;
  if (e2e && component) {
    _program.error("Cannot use both e2e and component options");
  }
  return getRunParametersFromCLI(opts);
}
function getRunParametersFromCLI(cliOptions) {
  const { component, e2e, ...restOptions } = cliOptions;
  const testingType = component ? "component" : "e2e";
  const result = {
    ...restOptions,
    config: sanitizeAndConvertNestedArgs(cliOptions.config, "config"),
    env: sanitizeAndConvertNestedArgs(cliOptions.env, "env"),
    reporterOptions: sanitizeAndConvertNestedArgs(
      cliOptions.reporterOptions,
      "reporterOptions"
    ),
    testingType,
    recordKey: cliOptions.key
  };
  debug23("parsed run params: %o", result);
  return result;
}

// bin/cli.ts
async function main() {
  return run(parseCLIOptions());
}
main().then((result) => {
  if (!result) {
    process.exit(1);
  }
  if (result.status === "failed") {
    process.exit(1);
  }
  const overallFailed = result.totalFailed + result.totalSkipped;
  if (overallFailed > 0) {
    process.exit(overallFailed);
  }
  process.exit(0);
}).catch((err) => {
  if (err instanceof ValidationError) {
    program.error(withError(err.toString()));
  } else {
    console.error(err);
  }
  process.exit(1);
});
/*! @preserve

### MIT

Parts of this code was copied from https://github.com/cypress-io/cypress and is subject to MIT license.

MIT License

Copyright (c) 2022 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzdXAvYXNzZXRzL2VzbV9zaGltcy5qcyIsICIuLi8uLi9iaW4vbGliL0Bjb21tYW5kZXItanMvZXh0cmEtdHlwaW5ncy9pbmRleC5qcyIsICIuLi8uLi9iaW4vY2xpLnRzIiwgIi4uLy4uL2xpYi9lcnJvcnMudHMiLCAiLi4vLi4vbGliL2xvZy50cyIsICIuLi8uLi9saWIvcnVuLnRzIiwgIi4uLy4uL2xpYi9pbml0LnRzIiwgIi4uLy4uL2xpYi9yZXF1aXJlLnRzIiwgIi4uLy4uL2xpYi9zdGRvdXQudHMiLCAiLi4vLi4vbGliL3dzL2luZGV4LnRzIiwgIi4uLy4uL2xpYi93cy93cy50cyIsICIuLi8uLi9saWIvcHVic3ViLnRzIiwgIi4uLy4uL2xpYi9jYXB0dXJlLnRzIiwgIi4uLy4uL2xpYi9odHRwQ2xpZW50L2luZGV4LnRzIiwgIi4uLy4uL2xpYi9odHRwQ2xpZW50L2NvbmZpZy50cyIsICIuLi8uLi9saWIvaHR0cENsaWVudC9odHRwQ2xpZW50LnRzIiwgIi4uLy4uL2xpYi9jb25maWcvaW5kZXgudHMiLCAiLi4vLi4vbGliL2NvbmZpZy9jb25maWcudHMiLCAiLi4vLi4vbGliL2Jvb3RzdHJhcC9pbmRleC50cyIsICIuLi8uLi9saWIvYm9vdHN0cmFwL2Jvb3RzdHJhcC50cyIsICIuLi8uLi9saWIvZnMudHMiLCAiLi4vLi4vbGliL2Jvb3RzdHJhcC9zZXJpYWxpemVyLnRzIiwgIi4uLy4uL2xpYi9jb25maWcvcGF0aC50cyIsICIuLi8uLi9saWIvY29uZmlnL3BhcmFtcy50cyIsICIuLi8uLi9saWIvaHR0cENsaWVudC9wcmludEVycm9ycy50cyIsICIuLi8uLi9sZWdhbC50cyIsICIuLi8uLi9saWIvYXBpL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9hcGkvYXBpLnRzIiwgIi4uLy4uL2xpYi9hcGkvd2FybmluZ3MudHMiLCAiLi4vLi4vbGliL2FwaS90eXBlcy9pbmRleC50cyIsICIuLi8uLi9saWIvYXBpL3R5cGVzL2luc3RhbmNlLnRzIiwgIi4uLy4uL2xpYi9hcGkvdHlwZXMvcnVuLnRzIiwgIi4uLy4uL2xpYi9hcGkvdHlwZXMvdGVzdC50cyIsICIuLi8uLi9saWIvY2lQcm92aWRlci9pbmRleC50cyIsICIuLi8uLi9saWIvY2lQcm92aWRlci9jaVByb3ZpZGVyLnRzIiwgIi4uLy4uL2xpYi9jaVByb3ZpZGVyL21lcmdlLnRzIiwgIi4uLy4uL2xpYi9jb3ZlcmFnZS9pbmRleC50cyIsICIuLi8uLi9saWIvY3lwcmVzcy9pbmRleC50cyIsICIuLi8uLi9saWIvY3lwcmVzcy9jeXByZXNzLnRzIiwgIi4uLy4uL2xpYi9sYW5nLnRzIiwgIi4uLy4uL2xpYi9kZWJ1Zy9pbmRleC50cyIsICIuLi8uLi90eXBlcy50cyIsICIuLi8uLi9saWIvZW52LnRzIiwgIi4uLy4uL2xpYi9naXQudHMiLCAiLi4vLi4vbGliL3BsYXRmb3JtL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyLnRzIiwgIi4uLy4uL2xpYi9wbGF0Zm9ybS9wbGF0Zm9ybS50cyIsICIuLi8uLi9saWIvcmVzdWx0cy9pbmRleC50cyIsICIuLi8uLi9saWIvcmVzdWx0cy9yZXN1bHRzLnRzIiwgIi4uLy4uL2xpYi9yZXN1bHRzL3RhYmxlLnRzIiwgIi4uLy4uL2xpYi9yZXN1bHRzL3VwbG9hZFJlc3VsdHMudHMiLCAiLi4vLi4vbGliL2FydGlmYWN0cy50cyIsICIuLi8uLi9saWIvdXBsb2FkLnRzIiwgIi4uLy4uL2xpYi9jYW5jZWxsYXRpb24vaW5kZXgudHMiLCAiLi4vLi4vbGliL2NhbmNlbGxhdGlvbi9jYW5jZWxsYXRpb24udHMiLCAiLi4vLi4vbGliL3J1bm5lci9pbmRleC50cyIsICIuLi8uLi9saWIvcnVubmVyL2NhbmNlbGxhYmxlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVubmVyLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcmVwb3J0VGFzay50cyIsICIuLi8uLi9saWIvc2h1dGRvd24udHMiLCAiLi4vLi4vbGliL3NwZWNNYXRjaGVyL2luZGV4LnRzIiwgIi4uLy4uL2xpYi9zcGVjTWF0Y2hlci9nZXRTcGVjRmlsZXMudHMiLCAiLi4vLi4vbGliL3NwZWNNYXRjaGVyL3NwZWNNYXRjaGVyLnRzIiwgIi4uLy4uL2xpYi91dGlscy50cyIsICIuLi8uLi9saWIvc3RhdGUvaW5kZXgudHMiLCAiLi4vLi4vbGliL3N0YXRlL2NvbmZpZy50cyIsICIuLi8uLi9saWIvc3RhdGUvZXhlY3V0aW9uLnRzIiwgIi4uLy4uL2xpYi9yZXN1bHRzL21hcFJlc3VsdC50cyIsICIuLi8uLi9iaW4vbGliL2luZGV4LnRzIiwgIi4uLy4uL2Jpbi9saWIvY2xpLnRzIiwgIi4uLy4uL2Jpbi9saWIvcGFyc2VyLnRzIiwgIi4uLy4uL2Jpbi9saWIvcHJvZ3JhbS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gU2hpbSBnbG9iYWxzIGluIGVzbSBidW5kbGVcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuXG5jb25zdCBnZXRGaWxlbmFtZSA9ICgpID0+IGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKVxuY29uc3QgZ2V0RGlybmFtZSA9ICgpID0+IHBhdGguZGlybmFtZShnZXRGaWxlbmFtZSgpKVxuXG5leHBvcnQgY29uc3QgX19kaXJuYW1lID0gLyogQF9fUFVSRV9fICovIGdldERpcm5hbWUoKVxuZXhwb3J0IGNvbnN0IF9fZmlsZW5hbWUgPSAvKiBAX19QVVJFX18gKi8gZ2V0RmlsZW5hbWUoKVxuIiwgImNvbnN0IGNvbW1hbmRlciA9IHJlcXVpcmUoXCJjb21tYW5kZXJcIik7XG5cbi8vIEB0cy1jaGVja1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgZGlmZmVyZW50IGdsb2JhbCBwcm9ncmFtIHRoYW4gY29tbWFuZGVyLFxuLy8gYW5kIGRvbid0IGFsc28gcmV0dXJuIGl0IGFzIGRlZmF1bHQgZXhwb3J0LlxuZXhwb3J0cy5wcm9ncmFtID0gbmV3IGNvbW1hbmRlci5Db21tYW5kKCk7XG5cbi8qKlxuICogRXhwb3NlIGNsYXNzZXMuIFRoZSBGb29UIHZlcnNpb25zIGFyZSBqdXN0IHR5cGVzLCBzbyByZXR1cm4gQ29tbWFuZGVyIG9yaWdpbmFsIGltcGxlbWVudGF0aW9ucyFcbiAqL1xuXG5leHBvcnRzLkFyZ3VtZW50ID0gY29tbWFuZGVyLkFyZ3VtZW50O1xuZXhwb3J0cy5Db21tYW5kID0gY29tbWFuZGVyLkNvbW1hbmQ7XG5leHBvcnRzLkNvbW1hbmRlckVycm9yID0gY29tbWFuZGVyLkNvbW1hbmRlckVycm9yO1xuZXhwb3J0cy5IZWxwID0gY29tbWFuZGVyLkhlbHA7XG5leHBvcnRzLkludmFsaWRBcmd1bWVudEVycm9yID0gY29tbWFuZGVyLkludmFsaWRBcmd1bWVudEVycm9yO1xuZXhwb3J0cy5JbnZhbGlkT3B0aW9uQXJndW1lbnRFcnJvciA9IGNvbW1hbmRlci5JbnZhbGlkQXJndW1lbnRFcnJvcjsgLy8gRGVwcmVjYXRlZFxuZXhwb3J0cy5PcHRpb24gPSBjb21tYW5kZXIuT3B0aW9uO1xuXG4vLyBJbiBDb21tYW5kZXIsIHRoZSBjcmVhdGUgcm91dGluZXMgZW5kIHVwIGJlaW5nIGFsaWFzZXMgZm9yIHRoZSBtYXRjaGluZ1xuLy8gbWV0aG9kcyBvbiB0aGUgZ2xvYmFsIHByb2dyYW0gZHVlIHRvIHRoZSAoZGVwcmVjYXRlZCkgbGVnYWN5IGRlZmF1bHQgZXhwb3J0LlxuLy8gSGVyZSB3ZSByb2xsIG91ciBvd24sIHRoZSB3YXkgQ29tbWFuZGVyIG1pZ2h0IGluIGZ1dHVyZS5cbmV4cG9ydHMuY3JlYXRlQ29tbWFuZCA9IChuYW1lKSA9PiBuZXcgY29tbWFuZGVyLkNvbW1hbmQobmFtZSk7XG5leHBvcnRzLmNyZWF0ZU9wdGlvbiA9IChmbGFncywgZGVzY3JpcHRpb24pID0+XG4gIG5ldyBjb21tYW5kZXIuT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbik7XG5leHBvcnRzLmNyZWF0ZUFyZ3VtZW50ID0gKG5hbWUsIGRlc2NyaXB0aW9uKSA9PlxuICBuZXcgY29tbWFuZGVyLkFyZ3VtZW50KG5hbWUsIGRlc2NyaXB0aW9uKTtcbiIsICIjIS91c3IvYmluL2VudiBub2RlXG5pbXBvcnQgXCJzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXJcIjtcblxuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2xpYi9lcnJvcnNcIjtcbmltcG9ydCB7IHdpdGhFcnJvciB9IGZyb20gXCIuLi9saWIvbG9nXCI7XG5pbXBvcnQgeyBydW4gfSBmcm9tIFwiLi4vbGliL3J1blwiO1xuaW1wb3J0IHsgcGFyc2VDTElPcHRpb25zLCBwcm9ncmFtIH0gZnJvbSBcIi4vbGliXCI7XG5cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gIHJldHVybiBydW4ocGFyc2VDTElPcHRpb25zKCkpO1xufVxuXG5tYWluKClcbiAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3ZlcmFsbEZhaWxlZCA9IHJlc3VsdC50b3RhbEZhaWxlZCArIHJlc3VsdC50b3RhbFNraXBwZWQ7XG4gICAgaWYgKG92ZXJhbGxGYWlsZWQgPiAwKSB7XG4gICAgICBwcm9jZXNzLmV4aXQob3ZlcmFsbEZhaWxlZCk7XG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgfSlcbiAgLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBwcm9ncmFtLmVycm9yKHdpdGhFcnJvcihlcnIudG9TdHJpbmcoKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSk7XG4iLCAiZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgfVxufVxuIiwgImltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG5cbmNvbnN0IGxvZyA9ICguLi5hcmdzOiB1bmtub3duW10pID0+IGNvbnNvbGUubG9nKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKTtcblxuZXhwb3J0IGNvbnN0IGluZm8gPSBsb2c7XG5leHBvcnQgY29uc3QgZm9ybWF0ID0gdXRpbC5mb3JtYXQ7XG5cbmV4cG9ydCBjb25zdCB3aXRoRXJyb3IgPSAobXNnOiBzdHJpbmcpID0+XG4gIGNoYWxrLmJnUmVkLndoaXRlKFwiIEVSUk9SIFwiKSArIFwiIFwiICsgbXNnO1xuZXhwb3J0IGNvbnN0IHdpdGhXYXJuaW5nID0gKG1zZzogc3RyaW5nKSA9PlxuICBjaGFsay5iZ1llbGxvdy5ibGFjayhcIiBXQVJOSU5HIFwiKSArIFwiIFwiICsgbXNnO1xuXG5leHBvcnQgY29uc3Qgd2FybiA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyh3aXRoV2FybmluZyh1dGlsLmZvcm1hdCguLi5hcmdzKSkpO1xuXG5leHBvcnQgY29uc3Qgc3VjY2VzcyA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyhjaGFsay5ncmVlbih1dGlsLmZvcm1hdCguLi5hcmdzKSkpO1xuXG5leHBvcnQgY29uc3QgZXJyb3IgPSAoLi4uYXJnczogdW5rbm93bltdKSA9PlxuICBsb2cod2l0aEVycm9yKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSArIFwiXFxuXCIpO1xuXG50eXBlIENvbG9yID0gXCJyZWRcIiB8IFwiZ3JlZW5cIiB8IFwieWVsbG93XCIgfCBcImJsdWVcIiB8IFwibWFnZW50YVwiIHwgXCJjeWFuXCIgfCBcIndoaXRlXCI7XG5leHBvcnQgY29uc3QgdGl0bGUgPSAoY29sb3I6IENvbG9yLCAuLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGluZm8oXCJcXG5cIiArIFwiICBcIiArIGNoYWxrW2NvbG9yXS5ib2xkKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSArIFwiICBcIiArIFwiXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgZGl2aWRlciA9ICgpID0+XG4gIGNvbnNvbGUubG9nKFwiXFxuXCIgKyBjaGFsay5ncmF5KEFycmF5KDEwMCkuZmlsbChcIj1cIikuam9pbihcIlwiKSkgKyBcIlxcblwiKTtcblxuZXhwb3J0IGNvbnN0IHNwYWNlciA9IChuOiBudW1iZXIgPSAwKSA9PlxuICBjb25zb2xlLmxvZyhBcnJheShuKS5maWxsKFwiXCIpLmpvaW4oXCJcXG5cIikpO1xuXG5leHBvcnQgY29uc3QgY3lhbiA9IGNoYWxrLmN5YW47XG5leHBvcnQgY29uc3QgYmx1ZSA9IGNoYWxrLmJsdWVCcmlnaHQ7XG5leHBvcnQgY29uc3QgcmVkID0gY2hhbGsucmVkO1xuZXhwb3J0IGNvbnN0IGdyZWVuID0gY2hhbGsuZ3JlZW5CcmlnaHQ7XG5leHBvcnQgY29uc3QgZ3JheSA9IGNoYWxrLmdyYXk7XG5leHBvcnQgY29uc3Qgd2hpdGUgPSBjaGFsay53aGl0ZTtcbmV4cG9ydCBjb25zdCBtYWdlbnRhID0gY2hhbGsubWFnZW50YTtcbmV4cG9ydCBjb25zdCBib2xkID0gY2hhbGsuYm9sZDtcbmV4cG9ydCBjb25zdCB5ZWxsb3cgPSBjaGFsay55ZWxsb3c7XG5leHBvcnQgY29uc3QgZGltID0gY2hhbGsuZGltO1xuIiwgImltcG9ydCBcIi4vaW5pdFwiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgcGx1ciBmcm9tIFwicGx1clwiO1xuaW1wb3J0IHsgZ2V0TGVnYWxOb3RpY2UgfSBmcm9tIFwiLi4vbGVnYWxcIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuUGFyYW1ldGVycyB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlUnVuIH0gZnJvbSBcIi4vYXBpXCI7XG5pbXBvcnQgeyBjdXRJbml0aWFsT3V0cHV0LCBnZXRDYXB0dXJlZE91dHB1dCB9IGZyb20gXCIuL2NhcHR1cmVcIjtcbmltcG9ydCB7IGdldENJIH0gZnJvbSBcIi4vY2lQcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgZ2V0TWVyZ2VkQ29uZmlnLFxuICBpc09mZmxpbmUsXG4gIHByZXByb2Nlc3NQYXJhbXMsXG4gIHZhbGlkYXRlUGFyYW1zLFxufSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IGdldENvdmVyYWdlRmlsZVBhdGggfSBmcm9tIFwiLi9jb3ZlcmFnZVwiO1xuaW1wb3J0IHsgcnVuQmFyZUN5cHJlc3MgfSBmcm9tIFwiLi9jeXByZXNzXCI7XG5pbXBvcnQgeyBhY3RpdmF0ZURlYnVnIH0gZnJvbSBcIi4vZGVidWdcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi9lbnZcIjtcbmltcG9ydCB7IGdldEdpdEluZm8gfSBmcm9tIFwiLi9naXRcIjtcbmltcG9ydCB7IHNldEFQSUJhc2VVcmwsIHNldFJ1bklkIH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuaW1wb3J0IHsgYm9sZCwgZGltLCBkaXZpZGVyLCBpbmZvLCBzcGFjZXIsIHRpdGxlLCB3YXJuLCB5ZWxsb3cgfSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7IGdldFBsYXRmb3JtIH0gZnJvbSBcIi4vcGxhdGZvcm1cIjtcbmltcG9ydCB7IHB1YnN1YiB9IGZyb20gXCIuL3B1YnN1YlwiO1xuaW1wb3J0IHsgc3VtbWFyaXplVGVzdFJlc3VsdHMsIHN1bW1hcnlUYWJsZSB9IGZyb20gXCIuL3Jlc3VsdHNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVJlcG9ydFRhc2tTcGVjLFxuICByZXBvcnRUYXNrcyxcbiAgcnVuVGlsbERvbmVPckNhbmNlbGxlZCxcbn0gZnJvbSBcIi4vcnVubmVyXCI7XG5pbXBvcnQgeyBzaHV0ZG93biB9IGZyb20gXCIuL3NodXRkb3duXCI7XG5pbXBvcnQgeyBnZXRTcGVjRmlsZXMgfSBmcm9tIFwiLi9zcGVjTWF0Y2hlclwiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4vc3RhdGVcIjtcbmltcG9ydCB7IHN0YXJ0V1NTIH0gZnJvbSBcIi4vd3NcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJ1blwiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bihwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycyA9IHt9KSB7XG4gIGNvbnN0IGV4ZWN1dGlvblN0YXRlID0gbmV3IEV4ZWN1dGlvblN0YXRlKCk7XG4gIGNvbnN0IGNvbmZpZ1N0YXRlID0gbmV3IENvbmZpZ1N0YXRlKCk7XG4gIGFjdGl2YXRlRGVidWcocGFyYW1zLmNsb3VkRGVidWcpO1xuICBkZWJ1ZyhcInJ1biBwYXJhbXMgJW9cIiwgcGFyYW1zKTtcbiAgcGFyYW1zID0gcHJlcHJvY2Vzc1BhcmFtcyhwYXJhbXMpO1xuICBkZWJ1ZyhcInBhcmFtcyBhZnRlciBwcmVwcm9jZXNzICVvXCIsIHBhcmFtcyk7XG5cbiAgaWYgKGlzT2ZmbGluZShwYXJhbXMpKSB7XG4gICAgaW5mbyhgU2tpcHBpbmcgY2xvdWQgb3JjaGVzdHJhdGlvbiBiZWNhdXNlIC0tcmVjb3JkIGlzIHNldCB0byBmYWxzZWApO1xuICAgIHJldHVybiBydW5CYXJlQ3lwcmVzcyhwYXJhbXMpO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVkUGFyYW1zID0gYXdhaXQgdmFsaWRhdGVQYXJhbXMocGFyYW1zKTtcbiAgc2V0QVBJQmFzZVVybCh2YWxpZGF0ZWRQYXJhbXMuY2xvdWRTZXJ2aWNlVXJsKTtcblxuICBpZiAoIWlzQ3VycmVudHMoKSkge1xuICAgIGNvbnNvbGUubG9nKGdldExlZ2FsTm90aWNlKCkpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgZ3JvdXAsXG4gICAgcGFyYWxsZWwsXG4gICAgY2lCdWlsZElkLFxuICAgIHRhZyxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBiYXRjaFNpemUsXG4gICAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMsXG4gICAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcsXG4gIH0gPSB2YWxpZGF0ZWRQYXJhbXM7XG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgZ2V0TWVyZ2VkQ29uZmlnKHZhbGlkYXRlZFBhcmFtcyk7XG4gIGNvbmZpZ1N0YXRlLnNldENvbmZpZyhjb25maWc/LnJlc29sdmVkKTtcblxuICBjb25zdCB7IHNwZWNzLCBzcGVjUGF0dGVybiB9ID0gYXdhaXQgZ2V0U3BlY0ZpbGVzKHtcbiAgICBjb25maWcsXG4gICAgcGFyYW1zOiB2YWxpZGF0ZWRQYXJhbXMsXG4gIH0pO1xuXG4gIGlmIChzcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGdldFBsYXRmb3JtKHtcbiAgICBjb25maWcsXG4gICAgYnJvd3NlcjogdmFsaWRhdGVkUGFyYW1zLmJyb3dzZXIsXG4gIH0pO1xuXG4gIGluZm8oXCJEaXNjb3ZlcmVkICVkIHNwZWMgZmlsZXNcIiwgc3BlY3MubGVuZ3RoKTtcbiAgaW5mbyhcbiAgICBgVGFnczogJHt0YWcubGVuZ3RoID4gMCA/IHRhZy5qb2luKFwiLFwiKSA6IGZhbHNlfTsgR3JvdXA6ICR7XG4gICAgICBncm91cCA/PyBmYWxzZVxuICAgIH07IFBhcmFsbGVsOiAke3BhcmFsbGVsID8/IGZhbHNlfTsgQmF0Y2ggU2l6ZTogJHtiYXRjaFNpemV9YFxuICApO1xuICBpbmZvKFwiQ29ubmVjdGluZyB0byBjbG91ZCBvcmNoZXN0cmF0aW9uIHNlcnZpY2UuLi5cIik7XG5cbiAgY29uc3QgcnVuID0gYXdhaXQgY3JlYXRlUnVuKHtcbiAgICBjaTogZ2V0Q0koY2lCdWlsZElkKSxcbiAgICBzcGVjczogc3BlY3MubWFwKChzcGVjKSA9PiBzcGVjLnJlbGF0aXZlKSxcbiAgICBjb21taXQ6IGF3YWl0IGdldEdpdEluZm8oY29uZmlnLnByb2plY3RSb290KSxcbiAgICBncm91cCxcbiAgICBwbGF0Zm9ybSxcbiAgICBwYXJhbGxlbDogcGFyYWxsZWwgPz8gZmFsc2UsXG4gICAgY2lCdWlsZElkLFxuICAgIHByb2plY3RJZCxcbiAgICByZWNvcmRLZXksXG4gICAgc3BlY1BhdHRlcm46IFtzcGVjUGF0dGVybl0uZmxhdCgyKSxcbiAgICB0YWdzOiB0YWcsXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgYmF0Y2hTaXplLFxuICAgIGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzLFxuICAgIGNvdmVyYWdlRW5hYmxlZDogZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcsXG4gICAgcHJldmlvdXNDaUJ1aWxkSWQ6IHByb2Nlc3MuZW52LkNVUlJFTlRTX1BSRVZJT1VTX0NJX0JVSUxEX0lELFxuICAgIHByb3ZpZGVkTWFjaGluZUlkOiBwcm9jZXNzLmVudi5DVVJSRU5UU19NQUNISU5FX0lELFxuICB9KTtcblxuICBzZXRSdW5JZChydW4ucnVuSWQpO1xuICBpbmZvKFwiXHVEODNDXHVERkE1IFJ1biBVUkw6XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuICBwcm9jZXNzLmVudi5DVVJSRU5UU19NQUNISU5FX0lEXG4gICAgPyBpbmZvKFwiXHVEODNFXHVERDE2IE1hY2hpbmUgSUQ6XCIsIGJvbGQocnVuLm1hY2hpbmVJZCkpXG4gICAgOiBudWxsO1xuICBjdXRJbml0aWFsT3V0cHV0KCk7XG5cbiAgYXdhaXQgc3RhcnRXU1MoKTtcbiAgbGlzdGVuVG9TcGVjRXZlbnRzKFxuICAgIGNvbmZpZ1N0YXRlLFxuICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgIGNvbmZpZy5leHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZ1xuICApO1xuXG4gIGF3YWl0IHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgY29uZmlnU3RhdGUsXG4gICAge1xuICAgICAgcnVuSWQ6IHJ1bi5ydW5JZCxcbiAgICAgIGdyb3VwSWQ6IHJ1bi5ncm91cElkLFxuICAgICAgbWFjaGluZUlkOiBydW4ubWFjaGluZUlkLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBzcGVjcyxcbiAgICB9LFxuICAgIHZhbGlkYXRlZFBhcmFtc1xuICApO1xuXG4gIGRpdmlkZXIoKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVwb3J0VGFza3MpO1xuICBjb25zdCBfc3VtbWFyeSA9IHN1bW1hcml6ZVRlc3RSZXN1bHRzKFxuICAgIGV4ZWN1dGlvblN0YXRlLmdldFJlc3VsdHMoY29uZmlnU3RhdGUpLFxuICAgIGNvbmZpZ1xuICApO1xuXG4gIHRpdGxlKFwid2hpdGVcIiwgXCJDbG91ZCBSdW4gRmluaXNoZWRcIik7XG4gIGNvbnNvbGUubG9nKHN1bW1hcnlUYWJsZShfc3VtbWFyeSkpO1xuXG4gIHByaW50V2FybmluZ3MoZXhlY3V0aW9uU3RhdGUpO1xuXG4gIGluZm8oXCJcXG5cdUQ4M0NcdURGQzEgUmVjb3JkZWQgUnVuOlwiLCBib2xkKHJ1bi5ydW5VcmwpKTtcblxuICBhd2FpdCBzaHV0ZG93bigpO1xuXG4gIHNwYWNlcigpO1xuICBpZiAoX3N1bW1hcnkuc3RhdHVzID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uX3N1bW1hcnksXG4gICAgICBydW5Vcmw6IHJ1bi5ydW5VcmwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfc3VtbWFyeTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9TcGVjRXZlbnRzKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmc/OiBib29sZWFuXG4pIHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlnU3RhdGUuZ2V0Q29uZmlnKCk7XG4gIHB1YnN1Yi5vbihcImJlZm9yZTpzcGVjXCIsIGFzeW5jICh7IHNwZWMgfTogeyBzcGVjOiBDeXByZXNzLlNwZWMgfSkgPT4ge1xuICAgIGRlYnVnKFwiYmVmb3JlOnNwZWMgJW9cIiwgc3BlYyk7XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0U3BlY0JlZm9yZShzcGVjLnJlbGF0aXZlKTtcbiAgfSk7XG5cbiAgcHVic3ViLm9uKFxuICAgIFwiYWZ0ZXI6c3BlY1wiLFxuICAgIGFzeW5jICh7IHNwZWMsIHJlc3VsdHMgfTogeyBzcGVjOiBDeXByZXNzLlNwZWM7IHJlc3VsdHM6IGFueSB9KSA9PiB7XG4gICAgICBkZWJ1ZyhcImFmdGVyOnNwZWMgJW8gJW9cIiwgc3BlYywgcmVzdWx0cyk7XG4gICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQWZ0ZXIoc3BlYy5yZWxhdGl2ZSwgcmVzdWx0cyk7XG4gICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjT3V0cHV0KHNwZWMucmVsYXRpdmUsIGdldENhcHR1cmVkT3V0cHV0KCkpO1xuXG4gICAgICBpZiAoZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBlcnJvciB9ID0gYXdhaXQgZ2V0Q292ZXJhZ2VGaWxlUGF0aChcbiAgICAgICAgICBjb25maWc/LmVudj8uY292ZXJhZ2VGaWxlXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQ292ZXJhZ2Uoc3BlYy5yZWxhdGl2ZSwgcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgIGBDb3VsZCBub3QgcHJvY2VzcyBjb3ZlcmFnZSBmaWxlIFwiJHtwYXRofVwiXFxuJHtkaW0oZXJyb3IpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjcmVhdGVSZXBvcnRUYXNrU3BlYyhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIHNwZWMucmVsYXRpdmUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5ncyhleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUpIHtcbiAgY29uc3Qgd2FybmluZ3MgPSBBcnJheS5mcm9tKGV4ZWN1dGlvblN0YXRlLmdldFdhcm5pbmdzKCkpO1xuICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgIHdhcm4oXG4gICAgICBgJHt3YXJuaW5ncy5sZW5ndGh9ICR7cGx1cihcbiAgICAgICAgXCJXYXJuaW5nXCIsXG4gICAgICAgIHdhcm5pbmdzLmxlbmd0aFxuICAgICAgKX0gZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBleGVjdXRpb246XFxuJHt3YXJuaW5nc1xuICAgICAgICAubWFwKCh3LCBpKSA9PiBgXFxuJHt5ZWxsb3coYFske2kgKyAxfS8ke3dhcm5pbmdzLmxlbmd0aH1dYCl9ICR7d31gKVxuICAgICAgICAuam9pbihcIlxcblwiKX1gXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IHJlcXVpcmUgfSBmcm9tIFwiLi4vbGliL3JlcXVpcmVcIjtcbmltcG9ydCBcIi4vc3Rkb3V0XCI7XG5pbXBvcnQgXCIuL3dzXCI7XG5cbmNvbnN0IGN5cHJlc3NQa2cgPSByZXF1aXJlKFwiY3lwcmVzcy9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBwa2cgPSByZXF1aXJlKFwiY3lwcmVzcy1jbG91ZC9wYWNrYWdlLmpzb25cIik7XG5cbmltcG9ydCB7IGluaXRDYXB0dXJlIH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgc2V0Q3VycmVudHNWZXJzaW9uLCBzZXRDeXByZXNzVmVyc2lvbiB9IGZyb20gXCIuL2h0dHBDbGllbnRcIjtcblxuaW5pdENhcHR1cmUoKTtcbnNldEN5cHJlc3NWZXJzaW9uKGN5cHJlc3NQa2cudmVyc2lvbik7XG5zZXRDdXJyZW50c1ZlcnNpb24ocGtnLnZlcnNpb24pO1xuIiwgImltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tIFwibW9kdWxlXCI7XG4vLyByZXF1aXJlcyBzaGltPXRydWUgaW4gcGFja2FnZS5qc29uXG5leHBvcnQgY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiIsICJpbXBvcnQgY3AgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmNvbnN0IG9yZ2luYWwgPSBjcC5zcGF3bjtcblxuLy8gQHRzLWlnbm9yZVxuY3Auc3Bhd24gPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncywgb3B0aW9ucykge1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChjb21tYW5kLm1hdGNoKC9DeXByZXNzLykpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcHJvY2VzcyA9IG9yZ2luYWwoY29tbWFuZCwgYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIHVzaW5nIHBpcGUgZW5hYmxlcyBjYXB0dXJpbmcgc3Rkb3V0IGFuZCBzdGRlcnJcbiAgICAgIHN0ZGlvOiBbXCJwaXBlXCIsIFwicGlwZVwiLCBcInBpcGVcIl0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3M7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBvcmdpbmFsKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xufTtcbiIsICJleHBvcnQgKiBmcm9tIFwiLi93c1wiO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBodHRwIGZyb20gXCJodHRwXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgSHR0cFRlcm1pbmF0b3IgZnJvbSBcImxpbC1odHRwLXRlcm1pbmF0b3JcIjtcbmltcG9ydCB7IG1hdGNoLCBQIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCAqIGFzIFdlYlNvY2tldCBmcm9tIFwid3NcIjtcbmltcG9ydCB7IHB1YnN1YiB9IGZyb20gXCIuLi9wdWJzdWJcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOndzXCIpO1xuXG5sZXQgc2VydmVyOiBodHRwLlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IHdzczogV2ViU29ja2V0LlNlcnZlciB8IG51bGwgPSBudWxsO1xubGV0IGh0dHBUZXJtaW5hdG9yOiBIdHRwVGVybWluYXRvciB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgY29uc3QgZ2V0V1NTUG9ydCA9ICgpID0+XG4gIG1hdGNoKHNlcnZlcj8uYWRkcmVzcygpKVxuICAgIC53aXRoKHsgcG9ydDogUC5udW1iZXIgfSwgKGFkZHJlc3MpID0+IGFkZHJlc3MucG9ydClcbiAgICAub3RoZXJ3aXNlKCgpID0+IDApO1xuXG5leHBvcnQgY29uc3Qgc3RvcFdTUyA9IGFzeW5jICgpID0+IHtcbiAgZGVidWcoXCJ0ZXJtaW5hdGluZyB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICBpZiAoIWh0dHBUZXJtaW5hdG9yKSB7XG4gICAgZGVidWcoXCJubyB3c3Mgc2VydmVyXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHN1Y2Nlc3MsIGNvZGUsIG1lc3NhZ2UsIGVycm9yIH0gPSBhd2FpdCBodHRwVGVybWluYXRvci50ZXJtaW5hdGUoKTtcbiAgaWYgKCFzdWNjZXNzKSB7XG4gICAgaWYgKGNvZGUgPT09IFwiVElNRURfT1VUXCIpIGVycm9yKG1lc3NhZ2UpO1xuICAgIGlmIChjb2RlID09PSBcIlNFUlZFUl9FUlJPUlwiKSBlcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgaWYgKGNvZGUgPT09IFwiSU5URVJOQUxfRVJST1JcIikgZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG4gIGRlYnVnKFwidGVybWluYXRlZCB3c3Mgc2VydmVyOiAlZFwiLCBnZXRXU1NQb3J0KCkpO1xufTtcbmV4cG9ydCBjb25zdCBzdGFydFdTUyA9ICgpID0+IHtcbiAgaWYgKHdzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXJ2ZXIgPSBodHRwXG4gICAgLmNyZWF0ZVNlcnZlcigpXG4gICAgLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHtcbiAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZlciBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICB9XG4gICAgICB3c3MgPSBuZXcgV2ViU29ja2V0LldlYlNvY2tldFNlcnZlcih7XG4gICAgICAgIHNlcnZlcixcbiAgICAgIH0pO1xuICAgICAgZGVidWcoXCJzdGFydGluZyB3c3Mgb24gcG9ydCAlZFwiLCBnZXRXU1NQb3J0KCkpO1xuICAgICAgd3NzLm9uKFwiY29ubmVjdGlvblwiLCBmdW5jdGlvbiBjb25uZWN0aW9uKHdzKSB7XG4gICAgICAgIHdzLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBpbmNvbWluZyhldmVudCkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHB1YnN1Yi5lbWl0KG1lc3NhZ2UudHlwZSwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5saXN0ZW4oKTtcblxuICBodHRwVGVybWluYXRvciA9IEh0dHBUZXJtaW5hdG9yKHtcbiAgICBzZXJ2ZXIsXG4gIH0pO1xufTtcbiIsICJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIjtcbmV4cG9ydCBlbnVtIEV2ZW50IHtcbiAgUlVOX0NBTkNFTExFRCA9IFwicnVuQ2FuY2VsbGVkXCIsXG59XG5leHBvcnQgY29uc3QgcHVic3ViID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpjYXB0dXJlXCIpO1xuXG5jb25zdCBfd3JpdGUgPSBwcm9jZXNzLnN0ZG91dC53cml0ZTtcbmNvbnN0IF9sb2cgPSBwcm9jZXNzLmxvZztcblxuZXhwb3J0IGNvbnN0IHJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsc1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSA9IF93cml0ZTtcbiAgcHJvY2Vzcy5sb2cgPSBfbG9nO1xufTtcblxuY29uc3QgbG9nczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG5cbmNvbnN0IHN0ZG91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoXCJjYXB0dXJpbmcgc3Rkb3V0XCIpO1xuICBsZXQgbG9nczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBsYXppbHkgYmFja3VwIHdyaXRlIHRvIGVuYWJsZSBpbmplY3Rpb25cbiAgY29uc3QgeyB3cml0ZSB9ID0gcHJvY2Vzcy5zdGRvdXQ7XG4gIGNvbnN0IHsgbG9nIH0gPSBwcm9jZXNzO1xuXG4gIC8vIGVsZWN0cm9uIGFkZHMgYSBuZXcgcHJvY2Vzcy5sb2dcbiAgLy8gbWV0aG9kIGZvciB3aW5kb3dzIGluc3RlYWQgb2YgcHJvY2Vzcy5zdGRvdXQud3JpdGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9pc3N1ZXMvOTc3XG4gIGlmIChsb2cpIHtcbiAgICBwcm9jZXNzLmxvZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZykge1xuICAgICAgbG9ncy5wdXNoKHN0cik7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIHJldHVybiBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpIHtcbiAgICBsb2dzLnB1c2goc3RyKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgcmV0dXJuIHdyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBsb2dzLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICBkYXRhOiBsb2dzLFxuICAgIHJlc3RvcmUsXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGRlYnVnKFwicmVzZXR0aW5nIGNhcHR1cmVkIHN0ZG91dFwiKTtcbiAgICAgIGxvZ3MgPSBbXTtcbiAgICB9LFxuICB9O1xufTtcblxubGV0IGluaXRpYWxPdXRwdXQ6IHN0cmluZyA9IFwiXCI7XG5sZXQgY2FwdHVyZWRPdXRwdXQ6IG51bGwgfCBSZXR1cm5UeXBlPHR5cGVvZiBzdGRvdXQ+ID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGluaXRDYXB0dXJlID0gKCkgPT4gKGNhcHR1cmVkT3V0cHV0ID0gc3Rkb3V0KCkpO1xuXG5leHBvcnQgY29uc3QgY3V0SW5pdGlhbE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgaW5pdGlhbE91dHB1dCA9IGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG4gIGNhcHR1cmVkT3V0cHV0LnJlc2V0KCk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc2V0Q2FwdHVyZSA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgY2FwdHVyZWRPdXRwdXQucmVzZXQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYXB0dXJlZE91dHB1dCA9ICgpID0+IHtcbiAgaWYgKCFjYXB0dXJlZE91dHB1dCkgdGhyb3cgbmV3IEVycm9yKFwiY2FwdHVyZWRPdXRwdXQgaXMgbnVsbFwiKTtcbiAgcmV0dXJuIGNhcHR1cmVkT3V0cHV0LnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxPdXRwdXQgPSAoKSA9PiBpbml0aWFsT3V0cHV0O1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL2NvbmZpZ1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuIiwgImltcG9ydCB7IEF4aW9zRXJyb3IsIGlzQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuXG5leHBvcnQgY29uc3QgaXNSZXRyaWFibGVFcnJvciA9IChlcnI6IEF4aW9zRXJyb3IpOiBib29sZWFuID0+IHtcbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVyci5jb2RlID09PSBcIkVUSU1FRE9VVFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWlzQXhpb3NFcnJvcihlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKFxuICAgIGVycj8ucmVzcG9uc2U/LnN0YXR1cyAmJlxuICAgIDUwMCA8PSBlcnIucmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgZXJyLnJlc3BvbnNlLnN0YXR1cyA8IDYwMFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldERlbGF5ID0gKGk6IG51bWJlcikgPT4gWzUgKiAxMDAwLCAxMCAqIDEwMDAsIDMwICogMTAwMF1baSAtIDFdO1xuXG5sZXQgYmFzZVVSTCA9IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbmV4cG9ydCBjb25zdCBnZXRBUElCYXNlVXJsID0gKCkgPT4gYmFzZVVSTCA/PyBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCI7XG5leHBvcnQgY29uc3Qgc2V0QVBJQmFzZVVybCA9ICh1cmw/OiBzdHJpbmcpID0+XG4gIChiYXNlVVJMID0gdXJsID8/IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIik7XG4iLCAiaW1wb3J0IGF4aW9zLCB7XG4gIEF4aW9zRXJyb3IsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZyxcbiAgQXhpb3NSZXNwb25zZSxcbiAgUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyxcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgYXhpb3NSZXRyeSBmcm9tIFwiYXhpb3MtcmV0cnlcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNaWxsaXNlY29uZHMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudHNDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCwgZ2V0RGVsYXksIGlzUmV0cmlhYmxlRXJyb3IgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IG1heWJlUHJpbnRFcnJvcnMgfSBmcm9tIFwiLi9wcmludEVycm9yc1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6YXBpXCIpO1xuXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5jb25zdCBUSU1FT1VUX01TID0gMzAgKiAxMDAwO1xubGV0IF9jbGllbnQ6IEF4aW9zSW5zdGFuY2UgfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENsaWVudCgpIHtcbiAgaWYgKF9jbGllbnQpIHtcbiAgICByZXR1cm4gX2NsaWVudDtcbiAgfVxuICBjb25zdCBjdXJyZW50c0NvbmZpZyA9IGF3YWl0IGdldEN1cnJlbnRzQ29uZmlnKCk7XG4gIF9jbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICAgIGJhc2VVUkw6IGdldEFQSUJhc2VVcmwoKSxcbiAgICB0aW1lb3V0OiBUSU1FT1VUX01TLFxuICB9KTtcblxuICBfY2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY2N5VmVyc29uID0gX2N1cnJlbnRzVmVyc2lvbiA/PyBcIjAuMC4wXCI7XG4gICAgY29uc3QgaGVhZGVyczogUmF3QXhpb3NSZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCI6IGNvbmZpZ1tcImF4aW9zLXJldHJ5XCJdPy5yZXRyeUNvdW50ID8/IDAsXG4gICAgICBcIngtY3lwcmVzcy12ZXJzaW9uXCI6IF9jeXByZXNzVmVyc2lvbiA/PyBcIjAuMC4wXCIsXG4gICAgICBcIngtY2N5LXZlcnNpb25cIjogY2N5VmVyc29uLFxuICAgICAgXCJVc2VyLUFnZW50XCI6IGBjeXByZXNzLWNsb3VkLyR7Y2N5VmVyc29ufWAsXG4gICAgfTtcbiAgICBpZiAoX3J1bklkKSB7XG4gICAgICBoZWFkZXJzW1wieC1jeXByZXNzLXJ1bi1pZFwiXSA9IF9ydW5JZDtcbiAgICB9XG4gICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRzQ29uZmlnLm5ldHdvcmtIZWFkZXJzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEhlYWRlcnMgPSBfLm9taXQoY3VycmVudHNDb25maWcubmV0d29ya0hlYWRlcnMsIFtcbiAgICAgICAgXCJ4LWN5cHJlc3MtcmVxdWVzdC1hdHRlbXB0XCIsXG4gICAgICAgIFwieC1jeXByZXNzLXZlcnNpb25cIixcbiAgICAgICAgXCJ4LWNjeS12ZXJzaW9uXCIsXG4gICAgICAgIFwieC1jeXByZXNzLXJ1bi1pZFwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiLFxuICAgICAgXSk7XG4gICAgICBkZWJ1ZyhcInVzaW5nIGN1c3RvbSBuZXR3b3JrIGhlYWRlcnM6ICVvXCIsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGZpbHRlcmVkSGVhZGVycyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaGVhZGVycyxcbiAgICB9O1xuXG4gICAgZGVidWcoXCJuZXR3b3JrIHJlcXVlc3Q6ICVvXCIsIHtcbiAgICAgIC4uLl8ucGljayhyZXEsIFwibWV0aG9kXCIsIFwidXJsXCIsIFwiaGVhZGVyc1wiKSxcbiAgICAgIGRhdGE6IEJ1ZmZlci5pc0J1ZmZlcihyZXEuZGF0YSkgPyBcImJ1ZmZlclwiIDogcmVxLmRhdGEsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxO1xuICB9KTtcblxuICBheGlvc1JldHJ5KF9jbGllbnQsIHtcbiAgICByZXRyaWVzOiBNQVhfUkVUUklFUyxcbiAgICByZXRyeUNvbmRpdGlvbjogaXNSZXRyaWFibGVFcnJvcixcbiAgICByZXRyeURlbGF5OiBnZXREZWxheSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb25SZXRyeSxcbiAgICBzaG91bGRSZXNldFRpbWVvdXQ6IHRydWUsXG4gIH0pO1xuICByZXR1cm4gX2NsaWVudDtcbn1cblxubGV0IF9ydW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IHNldFJ1bklkID0gKHJ1bklkOiBzdHJpbmcpID0+IHtcbiAgX3J1bklkID0gcnVuSWQ7XG59O1xuXG5sZXQgX2N5cHJlc3NWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3lwcmVzc1ZlcnNpb24gPSAoY3lwcmVzc1ZlcnNpb246IHN0cmluZykgPT4ge1xuICBfY3lwcmVzc1ZlcnNpb24gPSBjeXByZXNzVmVyc2lvbjtcbn07XG5cbmxldCBfY3VycmVudHNWZXJzaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0Q3VycmVudHNWZXJzaW9uID0gKHY6IHN0cmluZykgPT4ge1xuICBfY3VycmVudHNWZXJzaW9uID0gdjtcbn07XG5cbmZ1bmN0aW9uIG9uUmV0cnkoXG4gIHJldHJ5Q291bnQ6IG51bWJlcixcbiAgZXJyOiBBeGlvc0Vycm9yPHsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcnM/OiBzdHJpbmdbXSB9PixcbiAgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWdcbikge1xuICB3YXJuKFxuICAgIFwiTmV0d29yayByZXF1ZXN0ICclcycgZmFpbGVkOiAnJXMnLiBOZXh0IGF0dGVtcHQgaXMgaW4gJXMgKCVkLyVkKS5cIixcbiAgICBgJHtjb25maWcubWV0aG9kfSAke2NvbmZpZy51cmx9YCxcbiAgICBlcnIubWVzc2FnZSxcbiAgICBwcmV0dHlNaWxsaXNlY29uZHMoZ2V0RGVsYXkocmV0cnlDb3VudCkpLFxuICAgIHJldHJ5Q291bnQsXG4gICAgTUFYX1JFVFJJRVNcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VSZXF1ZXN0ID0gYXN5bmMgPFQgPSBhbnksIEQgPSBhbnk+KFxuICBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZzxEPlxuKSA9PiB7XG4gIHJldHVybiAoYXdhaXQgZ2V0Q2xpZW50KCkpPEQsIEF4aW9zUmVzcG9uc2U8VD4+KGNvbmZpZylcbiAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICBkZWJ1ZyhcIm5ldHdvcmsgcmVzcG9uc2U6ICVvXCIsIF8ub21pdChyZXMsIFwicmVxdWVzdFwiLCBcImNvbmZpZ1wiKSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgbWF5YmVQcmludEVycm9ycyhlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0pO1xufTtcbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jb25maWdcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BhcmFtc1wiO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcblxuaW1wb3J0IHsgUCwgbWF0Y2ggfSBmcm9tIFwidHMtcGF0dGVyblwiO1xuaW1wb3J0IHsgRGV0ZWN0ZWRCcm93c2VyLCBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IGJvb3RDeXByZXNzIH0gZnJvbSBcIi4uL2Jvb3RzdHJhcFwiO1xuaW1wb3J0IHsgaW5mbywgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldENvbmZpZ0ZpbGVQYXRoIH0gZnJvbSBcIi4vcGF0aFwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Y29uZmlnXCIpO1xuXG5leHBvcnQgdHlwZSBFMkVDb25maWcgPSB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIENvbXBvbmVudENvbmZpZyA9IHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuXG50eXBlIFJldHJ5Q29uZmlnID0ge1xuICBoYXJkRmFpbHVyZU1heFJldHJpZXM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdHlwZSBmb3IgYGN1cnJlbnRzLmNvbmZpZy4qc2AuIElmIHlvdSBhcmUgbm90IG9mZmljaWFsbHkgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHlvdSBjYW4gc3RpbGwgdHlwZSB0aGUgZXhwb3J0ZWQgY29uZmlnIGluIHlvdXIgSURFIGJ5IGFkZGluZyB0aGUgZm9sbG93aW5nIGFzIGEgYmxvY2sgY29tbWVudFxuICogYWJvdmUgYG1vZHVsZS5leHBvcnRzYCAvIGBleHBvcnQgZGVmYXVsdGA6XG4gKlxuICogYEB0eXBlIHtpbXBvcnQoJ2N5cHJlc3MtY2xvdWQnKS5DdXJyZW50c0NvbmZpZ31gXG4gKi9cbmV4cG9ydCB0eXBlIEN1cnJlbnRzQ29uZmlnID0ge1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHJlY29yZEtleT86IHN0cmluZztcbiAgY2xvdWRTZXJ2aWNlVXJsOiBzdHJpbmc7XG4gIGUyZTogRTJFQ29uZmlnO1xuICBjb21wb25lbnQ6IENvbXBvbmVudENvbmZpZztcbiAgbmV0d29ya0hlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZXRyeT86IFJldHJ5Q29uZmlnO1xufTtcblxubGV0IF9jb25maWc6IEN1cnJlbnRzQ29uZmlnIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRDb25maWc6IEN1cnJlbnRzQ29uZmlnID0ge1xuICBlMmU6IHtcbiAgICBiYXRjaFNpemU6IDMsXG4gIH0sXG4gIGNvbXBvbmVudDoge1xuICAgIGJhdGNoU2l6ZTogNSxcbiAgfSxcbiAgY2xvdWRTZXJ2aWNlVXJsOiBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCIsXG4gIG5ldHdvcmtIZWFkZXJzOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudHNDb25maWcoXG4gIHByb2plY3RSb290Pzogc3RyaW5nLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nLFxuKTogUHJvbWlzZTxDdXJyZW50c0NvbmZpZz4ge1xuICBpZiAoX2NvbmZpZykge1xuICAgIHJldHVybiBfY29uZmlnO1xuICB9XG5cbiAgY29uc3QgY29uZmlnRmlsZVBhdGggPSBnZXRDb25maWdGaWxlUGF0aChwcm9qZWN0Um9vdCwgZXhwbGljaXRDb25maWdGaWxlUGF0aCk7XG4gIC8vIHRyeSBsb2FkaW5nIHBvc3NpYmxlIGNvbmZpZyBmaWxlc1xuICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnID0gbWF0Y2goYXdhaXQgbG9hZENvbmZpZ0ZpbGUoZmlsZXBhdGgpKVxuICAgICAgLndpdGgoeyBkZWZhdWx0OiBQLm5vdChQLm51bGxpc2gpIH0sIChjKSA9PiBjLmRlZmF1bHQpXG4gICAgICAud2l0aChQLm5vdChQLm51bGxpc2gpLCAoYykgPT4gYylcbiAgICAgIC5vdGhlcndpc2UoKCkgPT4gbnVsbCk7XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBkZWJ1ZyhcImxvYWRlZCBjdXJyZW50cyBjb25maWcgZnJvbSAnJXMnXFxuJU9cIiwgZmlsZXBhdGgsIGNvbmZpZyk7XG4gICAgICBpbmZvKFwiVXNpbmcgY29uZmlnIGZpbGU6ICclcydcIiwgZmlsZXBhdGgpO1xuICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBfY29uZmlnO1xuICAgIH1cbiAgfVxuXG4gIHdhcm4oXG4gICAgXCJGYWlsZWQgdG8gbG9hZCBjb25maWcgZmlsZSwgZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbmZpZy4gQXR0ZW1wdGVkIGxvY2F0aW9uczogJXNcIixcbiAgICBjb25maWdGaWxlUGF0aCxcbiAgKTtcbiAgX2NvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIHJldHVybiBfY29uZmlnO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkQ29uZmlnRmlsZShmaWxlcGF0aDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgZGVidWcoXCJsb2FkaW5nIGN1cnJlbnRzIGNvbmZpZyBmaWxlIGZyb20gJyVzJ1wiLCBmaWxlcGF0aCk7XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydChmaWxlcGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcImZhaWxlZCBsb2FkaW5nIGNvbmZpZyBmaWxlIGZyb206ICVzXCIsIGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE1lcmdlZENvbmZpZyA9IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgZ2V0TWVyZ2VkQ29uZmlnPj47XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWVyZ2VkQ29uZmlnKHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzKSB7XG4gIGRlYnVnKFwicmVzb2x2aW5nIGN5cHJlc3MgY29uZmlnXCIpO1xuICBjb25zdCBjeXByZXNzUmVzb2x2ZWRDb25maWc6XG4gICAgfCAoQ3lwcmVzcy5SZXNvbHZlZENvbmZpZ09wdGlvbnMgJiB7XG4gICAgICAgIHByb2plY3RSb290OiBzdHJpbmc7XG4gICAgICAgIHJhd0pzb246IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICBicm93c2VyczogRGV0ZWN0ZWRCcm93c2VyW107XG4gICAgICB9KVxuICAgIHwgdW5kZWZpbmVkID0gYXdhaXQgYm9vdEN5cHJlc3MocGFyYW1zKTtcblxuICBkZWJ1ZyhcImN5cHJlc3MgcmVzb2x2ZWRDb25maWc6ICVPXCIsIGN5cHJlc3NSZXNvbHZlZENvbmZpZyk7XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCByYXdFMkVQYXR0ZXJuID0gY3lwcmVzc1Jlc29sdmVkQ29uZmlnLnJhd0pzb24/LmUyZT8uc3BlY1BhdHRlcm47XG4gIGxldCBhZGRpdGlvbmFsSWdub3JlUGF0dGVybjogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiByYXdFMkVQYXR0ZXJuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuID0gcmF3RTJFUGF0dGVybjtcbiAgfVxuXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvZWQwNjY4ZTI0YzJlZTY3NTNiYmQyNWFlNDY3Y2U5NGFlNTg1Nzc0MS9wYWNrYWdlcy9jb25maWcvc3JjL29wdGlvbnMudHMjTDQ1N1xuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2RldmVsb3AvcGFja2FnZXMvY29uZmlnL3NyYy9wcm9qZWN0L3V0aWxzLnRzI0w0MTJcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb2plY3RSb290OiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnByb2plY3RSb290IHx8IHByb2Nlc3MuY3dkKCksXG4gICAgcHJvamVjdElkOiBwYXJhbXMucHJvamVjdElkLFxuICAgIHNwZWNQYXR0ZXJuOiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnNwZWNQYXR0ZXJuIHx8IFwiKiovKi4qXCIsXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5yZXNvbHZlZC5leGNsdWRlU3BlY1BhdHRlcm4udmFsdWUgPz8gW10sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gICAgcmVzb2x2ZWQ6IGN5cHJlc3NSZXNvbHZlZENvbmZpZyxcbiAgICBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZzogcGFyYW1zLmV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nLFxuICB9O1xuICBkZWJ1ZyhcIm1lcmdlZCBjb25maWc6ICVPXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vYm9vdHN0cmFwXCI7XG4iLCAiaW1wb3J0IHsgZ2V0QmluUGF0aCB9IGZyb20gXCJjeTJcIjtcbmltcG9ydCB7IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZXhlY2EsIHsgRXhlY2FFcnJvciB9IGZyb20gXCJleGVjYVwiO1xuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgY3JlYXRlVGVtcEZpbGUgfSBmcm9tIFwiLi4vZnNcIjtcbmltcG9ydCB7IGJvbGQsIGluZm8gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyByZXF1aXJlIH0gZnJvbSBcIi4uL3JlcXVpcmVcIjtcbmltcG9ydCB7IGdldEJvb3RzdHJhcEFyZ3MgfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpib290XCIpO1xuXG5leHBvcnQgY29uc3QgYm9vdEN5cHJlc3MgPSBhc3luYyAocGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMpID0+IHtcbiAgZGVidWcoXCJib290aW5nIGN5cHJlc3MuLi5cIik7XG4gIGNvbnN0IHRlbXBGaWxlUGF0aCA9IGF3YWl0IGNyZWF0ZVRlbXBGaWxlKCk7XG5cbiAgY29uc3QgY3lwcmVzc0JpbiA9IGF3YWl0IGdldEJpblBhdGgocmVxdWlyZS5yZXNvbHZlKFwiY3lwcmVzc1wiKSk7XG4gIGRlYnVnKFwiY3lwcmVzcyBleGVjdXRhYmxlIGxvY2F0aW9uOiAlc1wiLCBjeXByZXNzQmluKTtcblxuICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8gcGFzcyB0aGUgc2FtZSBhcmdzIGluIG9yZGVyIHRvIGdldCB0aGUgc2FtZSBjb25maWcgYXMgZm9yIHRoZSBhY3R1YWwgcnVuXG4gIGNvbnN0IGFyZ3MgPSBnZXRCb290c3RyYXBBcmdzKHsgdGVtcEZpbGVQYXRoLCBwYXJhbXMgfSk7XG4gIGRlYnVnKFwiYm9vdGluZyBjeXByZXNzIHdpdGggYXJnczogJW9cIiwgYXJncyk7XG4gIGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWNDeXByZXNzKGN5cHJlc3NCaW4sIGFyZ3MpO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyh0ZW1wRmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCByZXNvbHZlIGN5cHJlc3MgY29uZmlndXJhdGlvbiBmcm9tICR7dGVtcEZpbGVQYXRofS4gUGxlYXNlIHJlcG9ydCB0aGUgaXNzdWUuYFxuICAgICk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmID0gZnMucmVhZEZpbGVTeW5jKHRlbXBGaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICBpZiAoIWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklzIGN5cHJlc3MtY2xvdWQvcGx1Z2luIGluc3RhbGxlZD9cIik7XG4gICAgfVxuICAgIGRlYnVnKFwiY3lwcmVzcyBjb25maWcgJyVzJzogJyVzJ1wiLCB0ZW1wRmlsZVBhdGgsIGYpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZyhcInJlYWQgY29uZmlnIHRlbXAgZmlsZSBmYWlsZWQ6ICVvXCIsIGVycik7XG4gICAgaW5mbyhib2xkKFwiQ3lwcmVzcyBzdGRvdXQ6XFxuXCIpLCBzdGRvdXQpO1xuICAgIGluZm8oYm9sZChcIkN5cHJlc3Mgc3RkZXJyOlxcblwiKSwgc3RkZXJyKTtcblxuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIGN5cHJlc3MgY29uZmlndXJhdGlvblxuLSBtYWtlIHN1cmUgdGhhdCAnY3lwcmVzcy1jbG91ZC9wbHVnaW4nIGlzIGluc3RhbGxlZFxuLSByZXBvcnQgdGhlIGlzc3VlIHRvZ2V0aGVyIHdpdGggY3lwcmVzcyBzdGRvdXQgYW5kIHN0ZGVyclxuYCk7XG4gIH1cbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGV4ZWNDeXByZXNzKGN5cHJlc3NCaW46IHN0cmluZywgYXJnczogcmVhZG9ubHkgc3RyaW5nW10pIHtcbiAgbGV0IHN0ZG91dCA9IFwiXCI7XG4gIGxldCBzdGRlcnIgPSBcIlwiO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWNhKGN5cHJlc3NCaW4sIFtcInJ1blwiLCAuLi5hcmdzXSwge1xuICAgICAgc3RkaW86IFwicGlwZVwiLFxuICAgICAgZW52OiB7XG4gICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAvLyBwcmV2ZW50IHdhcm5pbmdzIGFib3V0IHJlY29yZGluZyBtb2RlXG4gICAgICAgIENZUFJFU1NfUkVDT1JEX0tFWTogdW5kZWZpbmVkLFxuICAgICAgICBDWVBSRVNTX1BST0pFQ1RfSUQ6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlYnVnKFwiZXhlYyBjeXByZXNzIGZhaWxlZCAoY2VydGFpbiBmYWlsdXJlcyBhcmUgZXhwZWN0ZWQpOiAlb1wiLCBlcnIpO1xuICAgIHN0ZG91dCA9IChlcnIgYXMgRXhlY2FFcnJvcikuc3Rkb3V0O1xuICAgIHN0ZGVyciA9IChlcnIgYXMgRXhlY2FFcnJvcikuc3RkZXJyO1xuICB9XG4gIHJldHVybiB7IHN0ZG91dCwgc3RkZXJyIH07XG59XG4iLCAiaW1wb3J0IHsgZmlsZSB9IGZyb20gXCJ0bXAtcHJvbWlzZVwiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVtcEZpbGUgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgcGF0aCB9ID0gYXdhaXQgZmlsZSgpO1xuICByZXR1cm4gcGF0aDtcbn07XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBDeXByZXNzUnVuUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpib290XCIpO1xuXG5jb25zdCBnZXREdW1teVNwZWMgPSBjdXN0b21BbHBoYWJldChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsIDEwKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvb3RzdHJhcEFyZ3Moe1xuICBwYXJhbXMsXG4gIHRlbXBGaWxlUGF0aCxcbn06IHtcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnM7XG4gIHRlbXBGaWxlUGF0aDogc3RyaW5nO1xufSkge1xuICByZXR1cm4gXy5jaGFpbihnZXRDeXByZXNzQ0xJUGFyYW1zKHBhcmFtcykpXG4gICAgLnRocnUoKG9wdHMpID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgLy8gbWVyZ2UgdGhlIGVudiB3aXRoIHRoZSBjdXJyZW50cyBzcGVjaWZpYyBlbnYgdmFyaWFibGVzXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4uKG9wdHMuZW52ID8/IHt9KSxcbiAgICAgICAgY3VycmVudHNfdGVtcF9maWxlOiB0ZW1wRmlsZVBhdGgsXG4gICAgICAgIGN1cnJlbnRzX2RlYnVnX2VuYWJsZWQ6IHByb2Nlc3MuZW52LkRFQlVHPy5pbmNsdWRlcyhcImN1cnJlbnRzOlwiKVxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pKVxuICAgIC50YXAoKG9wdHMpID0+IHtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBib290c3RyYXAgcGFyYW1zOiAlb1wiLCBvcHRzKTtcbiAgICB9KVxuICAgIC50aHJ1KHNlcmlhbGl6ZU9wdGlvbnMpXG4gICAgLnRhcCgob3B0cykgPT4ge1xuICAgICAgZGVidWcoXCJjeXByZXNzIGJvb3RzdHJhcCBzZXJpYWxpemVkIHBhcmFtczogJW9cIiwgb3B0cyk7XG4gICAgfSlcbiAgICAudGhydSgoYXJncykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgXCItLXNwZWNcIixcbiAgICAgICAgZ2V0RHVtbXlTcGVjKCksXG4gICAgICAgIHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiA/IFwiLS1jb21wb25lbnRcIiA6IFwiLS1lMmVcIixcbiAgICAgIF07XG4gICAgfSlcbiAgICAudmFsdWUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBDdXJyZW50cyBvcHRpb25zIHRvIEN5cHJlc3MgQ0xJIHBhcmFtcy5cbiAqIEN5cHJlc3MgQ0xJIG9wdGlvbnMgYXJlIGRpZmZlcmVudCBmcm9tIEN5cHJlc3MgbW9kdWxlIEFQSSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgQ3VycmVudHMgcGFyYW1cbiAqIEByZXR1cm5zIEN5cHJlc3MgQ0xJIHBhcmFtc1xuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvZ3VpZGVzL2NvbW1hbmQtbGluZSNjeXByZXNzLXJ1blxuICogQHNlZSBodHRwczovL2RvY3MuY3lwcmVzcy5pby9hcGkvbW9kdWxlLWFwaVxuICovXG5mdW5jdGlvbiBnZXRDeXByZXNzQ0xJUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3lwcmVzc1J1blBhcmFtZXRlcnMge1xuICBjb25zdCByZXN1bHQgPSBnZXRDeXByZXNzUnVuQVBJUGFyYW1zKHBhcmFtcyk7XG4gIGNvbnN0IHRlc3RpbmdUeXBlID1cbiAgICByZXN1bHQudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCJcbiAgICAgID8ge1xuICAgICAgICAgIGNvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgOiB7fTtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLm9taXQocmVzdWx0LCBcInRlc3RpbmdUeXBlXCIpLFxuICAgIC4uLnRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmxhdE1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgX2tleSA9IGRhc2hlZChrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyBbYC0tJHtfa2V5fWBdIDogW2AtLSR7X2tleX1gLCBmYWxzZV07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW2AtLSR7X2tleX1gLCBzZXJpYWxpemVDb21wbGV4UGFyYW0odmFsdWUpXTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIFtgLS0ke19rZXl9YCwgdmFsdWUudG9TdHJpbmcoKV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVDb21wbGV4UGFyYW0ocGFyYW06IHt9KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbSk7XG59XG5cbmNvbnN0IGRhc2hlZCA9ICh2OiBzdHJpbmcpID0+IHYucmVwbGFjZSgvW0EtWl0vZywgKG0pID0+IFwiLVwiICsgbS50b0xvd2VyQ2FzZSgpKTtcbiIsICJpbXBvcnQgaXNBYnNvbHV0ZSBmcm9tIFwiaXMtYWJzb2x1dGVcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RmlsZW5hbWVzID0gW1xuICBcImN1cnJlbnRzLmNvbmZpZy5qc1wiLFxuICBcImN1cnJlbnRzLmNvbmZpZy5janNcIixcbiAgXCJjdXJyZW50cy5jb25maWcubWpzXCIsXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZ0ZpbGVQYXRoKFxuICBwcm9qZWN0Um9vdDogc3RyaW5nIHwgbnVsbCA9IG51bGwsXG4gIGV4cGxpY2l0Q29uZmlnRmlsZVBhdGg/OiBzdHJpbmdcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgcHJlZml4ID0gcHJvamVjdFJvb3QgPz8gcHJvY2Vzcy5jd2QoKTtcbiAgaWYgKFxuICAgIF8uaXNTdHJpbmcoZXhwbGljaXRDb25maWdGaWxlUGF0aCkgJiZcbiAgICBpc0Fic29sdXRlKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpXG4gICkge1xuICAgIHJldHVybiBbZXhwbGljaXRDb25maWdGaWxlUGF0aF07XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoZXhwbGljaXRDb25maWdGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gW25vcm1hbGl6ZVBhdGgocHJlZml4LCBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKV07XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lcy5tYXAoKHApID0+IG5vcm1hbGl6ZVBhdGgocHJlZml4LCBwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHByZWZpeDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBmaWxlOi8vJHtwYXRoLnJlc29sdmUocHJlZml4LCBmaWxlbmFtZSl9YDtcbn1cbiIsICJpbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSdW5QYXJhbWV0ZXJzLFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRzQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6dmFsaWRhdGVQYXJhbXNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQ3VycmVudHNQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBQcm9taXNlPEN1cnJlbnRzUnVuUGFyYW1ldGVycz4ge1xuICBjb25zdCBjb25maWdGcm9tRmlsZSA9IGF3YWl0IGdldEN1cnJlbnRzQ29uZmlnKFxuICAgIHBhcmFtcy5wcm9qZWN0LFxuICAgIHBhcmFtcy5jbG91ZENvbmZpZ0ZpbGVcbiAgKTtcblxuICBkZWJ1ZyhcInJlc29sdmluZyBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG4gIGRlYnVnKFwicmVzb2x2aW5nIGN1cnJlbnRzIGNvbmZpZyBmaWxlOiAlb1wiLCBjb25maWdGcm9tRmlsZSk7XG4gIGNvbnN0IGNsb3VkU2VydmljZVVybCA9XG4gICAgcGFyYW1zLmNsb3VkU2VydmljZVVybCA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX0FQSV9VUkwgPz9cbiAgICBjb25maWdGcm9tRmlsZS5jbG91ZFNlcnZpY2VVcmw7XG5cbiAgY29uc3QgcmVjb3JkS2V5ID1cbiAgICBwYXJhbXMucmVjb3JkS2V5ID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUkVDT1JEX0tFWSA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLnJlY29yZEtleTtcblxuICBjb25zdCBwcm9qZWN0SWQgPVxuICAgIHBhcmFtcy5wcm9qZWN0SWQgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19QUk9KRUNUX0lEID8/XG4gICAgY29uZmlnRnJvbUZpbGUucHJvamVjdElkO1xuXG4gIGNvbnN0IHRlc3RpbmdUeXBlID0gcGFyYW1zLnRlc3RpbmdUeXBlID8/IFwiZTJlXCI7XG5cbiAgY29uc3QgYmF0Y2hTaXplID1cbiAgICB0ZXN0aW5nVHlwZSA9PT0gXCJlMmVcIlxuICAgICAgPyBjb25maWdGcm9tRmlsZS5lMmUuYmF0Y2hTaXplXG4gICAgICA6IGNvbmZpZ0Zyb21GaWxlLmNvbXBvbmVudC5iYXRjaFNpemU7XG5cbiAgLy8gYmF0Y2hTaXplIGFuZCBjbG91ZFNlcnZpY2VVcmwgZGVmYXVsdHMgYXJlIGluIGdldEN1cnJlbnRzQ29uZmlnKClcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgY2xvdWRTZXJ2aWNlVXJsLFxuICAgIHJlY29yZEtleSxcbiAgICBwcm9qZWN0SWQsXG4gICAgYmF0Y2hTaXplLFxuICAgIHRlc3RpbmdUeXBlLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgcHJvamVjdElkRXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcHJvamVjdElkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLSBwcm92aWRlIGl0IGFzIGEgXCJwcm9qZWN0SWRcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19QUk9KRUNUX0lEIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcInByb2plY3RJZFwiIGluIFwiY3VycmVudHMuY29uZmlnLntjfWpzXCIgZmlsZWA7XG5cbmV4cG9ydCBjb25zdCBjbG91ZFNlcnZpY2VVcmxFcnJvciA9IGBDYW5ub3QgcmVzb2x2ZSBjbG91ZCBzZXJ2aWNlIFVSTC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi0gcHJvdmlkZSBpdCBhcyBhIFwiY2xvdWRTZXJ2aWNlVXJsXCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfQVBJX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJjbG91ZFNlcnZpY2VVcmxcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy57Y31qc1wiIGZpbGVgO1xuXG5leHBvcnQgY29uc3QgY2xvdWRTZXJ2aWNlSW52YWxpZFVybEVycm9yID0gYEludmFsaWQgY2xvdWQgc2VydmljZSBVUkwgcHJvdmlkZWRgO1xuXG5leHBvcnQgY29uc3QgcmVjb3JkS2V5RXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgcmVjb3JkIGtleS4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblxuLSBwYXNzIGl0IGFzIGEgQ0xJIGZsYWcgJy1rLCAtLWtleSA8cmVjb3JkLWtleT4nXG4tIHByb3ZpZGUgaXQgYXMgYSBcInJlY29yZEtleVwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX1JFQ09SRF9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwicmVjb3JkS2V5XCIgaW4gXCJjdXJyZW50cy5jb25maWcue2N9anNcIiBmaWxlXG5gO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMoXG4gIF9wYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM+IHtcbiAgY29uc3QgcGFyYW1zID0gYXdhaXQgcmVzb2x2ZUN1cnJlbnRzUGFyYW1zKF9wYXJhbXMpO1xuXG4gIGRlYnVnKFwidmFsaWRhdGluZyBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG4gIGlmICghcGFyYW1zLmNsb3VkU2VydmljZVVybCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoY2xvdWRTZXJ2aWNlVXJsRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnByb2plY3RJZCkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocHJvamVjdElkRXJyb3IpO1xuICB9XG4gIGlmICghcGFyYW1zLnJlY29yZEtleSkge1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IocmVjb3JkS2V5RXJyb3IpO1xuICB9XG5cbiAgdmFsaWRhdGVVUkwocGFyYW1zLmNsb3VkU2VydmljZVVybCk7XG5cbiAgY29uc3QgcmVxdWlyZWRQYXJhbWV0ZXJzOiBBcnJheTxrZXlvZiBDdXJyZW50c1J1blBhcmFtZXRlcnM+ID0gW1xuICAgIFwidGVzdGluZ1R5cGVcIixcbiAgICBcImJhdGNoU2l6ZVwiLFxuICAgIFwicHJvamVjdElkXCIsXG4gIF07XG4gIHJlcXVpcmVkUGFyYW1ldGVycy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcmFtc1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBlcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgXCIlc1wiJywga2V5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcGFyYW1zLnRhZyA9IHBhcnNlVGFncyhwYXJhbXMudGFnKTtcbiAgcGFyYW1zLmF1dG9DYW5jZWxBZnRlckZhaWx1cmVzID0gZ2V0QXV0b0NhbmNlbFZhbHVlKFxuICAgIHBhcmFtcy5hdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1xuICApO1xuXG4gIGRlYnVnKFwidmFsaWRhdGVkIGN1cnJlbnRzIHBhcmFtczogJW9cIiwgcGFyYW1zKTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjYXN0IGFmdGVyIGZpbmRpbmcgYSB3YXkgdG8gcHJvcGVybHkgcmVzb2x2ZSBwYXJhbXMgdHlwZSBhZnRlciB2YWxpZGF0aW9uc1xuICByZXR1cm4gcGFyYW1zIGFzIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b0NhbmNlbFZhbHVlKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgZmFsc2UgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICBgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXM6IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgXCJmYWxzZVwiLiBHb3Q6IFwiJHt2YWx1ZX1cImBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2ZmbGluZShwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycykge1xuICByZXR1cm4gcGFyYW1zLnJlY29yZCA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFncyh0YWdTdHJpbmc6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInRhZ1wiXSk6IHN0cmluZ1tdIHtcbiAgaWYgKCF0YWdTdHJpbmcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFnU3RyaW5nKSkge1xuICAgIHJldHVybiB0YWdTdHJpbmcuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG4gIHJldHVybiB0YWdTdHJpbmdcbiAgICAuc3BsaXQoXCIsXCIpXG4gICAgLm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVVJMKHVybDogc3RyaW5nKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke2Nsb3VkU2VydmljZUludmFsaWRVcmxFcnJvcn06IFwiJHt1cmx9XCJgKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBDeXByZXNzIG9wdGlvbnMgd2l0aG91dCBpdGVtcyB0aGF0IGFmZmVjdCByZWNvcmRpbmcgbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN5cHJlc3NSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5fLnBpY2tCeShcbiAgICAgIF8ub21pdChwYXJhbXMsIFtcbiAgICAgICAgXCJjbG91ZERlYnVnXCIsXG4gICAgICAgIFwiY2xvdWRDb25maWdGaWxlXCIsXG4gICAgICAgIFwiYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXNcIixcbiAgICAgICAgXCJjbG91ZFNlcnZpY2VVcmxcIixcbiAgICAgICAgXCJiYXRjaFNpemVcIixcbiAgICAgICAgXCJwcm9qZWN0SWRcIixcbiAgICAgICAgXCJrZXlcIixcbiAgICAgICAgXCJyZWNvcmRLZXlcIixcbiAgICAgICAgXCJyZWNvcmRcIixcbiAgICAgICAgXCJncm91cFwiLFxuICAgICAgICBcInBhcmFsbGVsXCIsXG4gICAgICAgIFwidGFnXCIsXG4gICAgICAgIFwiY2lCdWlsZElkXCIsXG4gICAgICAgIFwic3BlY1wiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJoZWFkbGVzc1wiLFxuICAgICAgICBcImV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nXCIsXG4gICAgICBdKSxcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIHJlY29yZDogZmFsc2UsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogQ3VycmVudHNSdW5QYXJhbWV0ZXJzIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgc3BlYzogcHJvY2Vzc1NwZWNQYXJhbShwYXJhbXMuc3BlYyksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTcGVjUGFyYW0oXG4gIHNwZWM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcInNwZWNcIl1cbik6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihzcGVjLm1hcCgoaSkgPT4gaS5zcGxpdChcIixcIikpKTtcbiAgfVxuXG4gIHJldHVybiBzcGVjLnNwbGl0KFwiLFwiKTtcbn1cbiIsICJpbXBvcnQgeyBBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBzcGFjZXIsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVByaW50RXJyb3JzKFxuICBlcnI6IEF4aW9zRXJyb3I8eyBtZXNzYWdlOiBzdHJpbmc7IGVycm9ycz86IHN0cmluZ1tdIH0+XG4pIHtcbiAgaWYgKCFlcnIucmVzcG9uc2U/LmRhdGEgfHwgIWVyci5yZXNwb25zZT8uc3RhdHVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBtZXNzYWdlLCBlcnJvcnMgfSA9IGVyci5yZXNwb25zZS5kYXRhO1xuXG4gIHN3aXRjaCAoZXJyLnJlc3BvbnNlLnN0YXR1cykge1xuICAgIGNhc2UgNDAxOlxuICAgICAgd2FybihcIlJlY2VpdmVkIDQwMSBVbmF1dGhvcml6ZWRcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQyMjpcbiAgICAgIHNwYWNlcigxKTtcbiAgICAgIHdhcm4oLi4uZm9ybWF0R2VuZXJpY0Vycm9yKG1lc3NhZ2UsIGVycm9ycykpO1xuICAgICAgc3BhY2VyKDEpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRHZW5lcmljRXJyb3IoXG4gIG1lc3NhZ2U/OiBzdHJpbmcsXG4gIGVycm9ycz86IHN0cmluZ1tdXG4pOiBzdHJpbmdbXSB7XG4gIGlmICghXy5pc1N0cmluZyhtZXNzYWdlKSkge1xuICAgIHJldHVybiBbXCJVbmV4cGVjdGVkIGVycm9yIGZyb20gdGhlIGNsb3VkIHNlcnZpY2VcIl07XG4gIH1cblxuICBpZiAoZXJyb3JzPy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW21lc3NhZ2UgYXMgc3RyaW5nXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIG1lc3NhZ2UgYXMgc3RyaW5nLFxuICAgIGBcbiR7KGVycm9ycyA/PyBbXSkubWFwKChlKSA9PiBgICAtICR7ZX1gKS5qb2luKFwiXFxuXCIpfVxuYCxcbiAgXTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0TGVnYWxOb3RpY2UoKSB7XG4gIHJldHVybiBgXG5Db3B5cmlnaHQgKEMpICR7bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpfSBDdXJyZW50cyBTb2Z0d2FyZSBJbmMgaHR0cHM6Ly9jdXJyZW50cy5kZXZcblRoaXMgaXMgZnJlZSBzb2Z0d2FyZSwgYW5kIHlvdSBhcmUgd2VsY29tZSB0byByZWRpc3RyaWJ1dGUgaXQgdW5kZXIgY2VydGFpblxuY29uZGl0aW9ucy4gVGhpcyBwcm9ncmFtIGNvbWVzIHdpdGggbm8gd2FycmFudHkuIFBhcnRzIG9mIHRoaXMgcHJvZ3JhbSBhcmUgTUlUXG5saWNlbnNlZC4gUmVmZXIgdG8gdGhlIGxpY2Vuc2UgZm9yIGRldGFpbHNcbmh0dHBzOi8vZ2l0aHViLmNvbS9jdXJyZW50cy1kZXYvY3lwcmVzcy1jbG91ZC9ibG9iL21haW4vTElDRU5TRS5tZFxuYDtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9hcGlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzXCI7XG4iLCAiaW1wb3J0IHsgbWFrZVJlcXVlc3QgfSBmcm9tIFwiLi4vaHR0cENsaWVudFwiO1xuaW1wb3J0IHtcbiAgQ3JlYXRlSW5zdGFuY2VDeVBheWxvYWQsXG4gIENyZWF0ZUluc3RhbmNlUGF5bG9hZCxcbiAgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSxcbiAgQ3JlYXRlSW5zdGFuY2VzUmVzcG9uc2UsXG4gIENyZWF0ZVJ1blBheWxvYWQsXG4gIENyZWF0ZVJ1blJlc3BvbnNlLFxuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzTWVyZ2VkUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2UsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBwcmludFdhcm5pbmdzIH0gZnJvbSBcIi4vd2FybmluZ3NcIjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJ1biA9IGFzeW5jIChwYXlsb2FkOiBDcmVhdGVSdW5QYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3Q8Q3JlYXRlUnVuUmVzcG9uc2UsIENyZWF0ZVJ1blBheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvcnVuc1wiLFxuICAgIGRhdGE6IHBheWxvYWQsXG4gIH0pO1xuXG4gIGlmICgocmVzcG9uc2UuZGF0YS53YXJuaW5ncz8ubGVuZ3RoID8/IDApID4gMCkge1xuICAgIHByaW50V2FybmluZ3MocmVzcG9uc2UuZGF0YS53YXJuaW5ncyk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnN0YW5jZSA9IGFzeW5jICh7XG4gIHJ1bklkLFxuICBncm91cElkLFxuICBtYWNoaW5lSWQsXG4gIHBsYXRmb3JtLFxufTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlcXVlc3Q8XG4gICAgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSxcbiAgICBDcmVhdGVJbnN0YW5jZVBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBydW5zLyR7cnVuSWR9L2luc3RhbmNlc2AsXG4gICAgZGF0YToge1xuICAgICAgcnVuSWQsXG4gICAgICBncm91cElkLFxuICAgICAgbWFjaGluZUlkLFxuICAgICAgcGxhdGZvcm0sXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyA9IGFzeW5jIChkYXRhOiBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCkgPT4ge1xuICBjb25zdCByZXNwb25lID0gYXdhaXQgbWFrZVJlcXVlc3Q8XG4gICAgQ3JlYXRlSW5zdGFuY2VzUmVzcG9uc2UsXG4gICAgQ3JlYXRlSW5zdGFuY2VDeVBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBydW5zLyR7ZGF0YS5ydW5JZH0vY3kvaW5zdGFuY2VzYCxcbiAgICBkYXRhLFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEluc3RhbmNlVGVzdHMgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWRcbikgPT5cbiAgbWFrZVJlcXVlc3Q8e30sIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS90ZXN0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVJbnN0YW5jZVJlc3VsdHMgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDxVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSwgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vcmVzdWx0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCByZXBvcnRJbnN0YW5jZVJlc3VsdHNNZXJnZWQgPSAoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgcGF5bG9hZDogVXBkYXRlSW5zdGFuY2VSZXN1bHRzTWVyZ2VkUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDxcbiAgICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSxcbiAgICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkXG4gID4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBgaW5zdGFuY2VzLyR7aW5zdGFuY2VJZH0vY3kvcmVzdWx0c2AsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSkudGhlbigocmVzdWx0KSA9PiByZXN1bHQuZGF0YSk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVJbnN0YW5jZVN0ZG91dCA9IChpbnN0YW5jZUlkOiBzdHJpbmcsIHN0ZG91dDogc3RyaW5nKSA9PlxuICBtYWtlUmVxdWVzdDxhbnksIHsgc3Rkb3V0OiBzdHJpbmcgfT4oe1xuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9zdGRvdXRgLFxuICAgIGRhdGE6IHtcbiAgICAgIHN0ZG91dCxcbiAgICB9LFxuICB9KTtcbiIsICJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBtYWdlbnRhIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5pbXBvcnQgeyBpbmZvLCBzcGFjZXIsIHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBDbG91ZFdhcm5pbmcgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRXYXJuaW5ncyh3YXJuaW5nczogQ2xvdWRXYXJuaW5nW10pIHtcbiAgd2FybihcIk5vdGljZSBmcm9tIGNsb3VkIHNlcnZpY2U6XCIpO1xuICB3YXJuaW5ncy5tYXAoKHcpID0+IHtcbiAgICBzcGFjZXIoMSk7XG4gICAgaW5mbyhtYWdlbnRhLmJvbGQody5tZXNzYWdlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMoXy5vbWl0KHcsIFwibWVzc2FnZVwiKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGluZm8oXCItICVzOiAlc1wiLCBrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICBzcGFjZXIoMSk7XG4gIH0pO1xufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL2luc3RhbmNlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ydW5cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Rlc3RcIjtcbiIsICJpbXBvcnQgeyBQbGF0Zm9ybSwgU2NyZWVuc2hvdEFydGlmYWN0IH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IFNldFRlc3RzUGF5bG9hZCwgVGVzdCB9IGZyb20gXCIuL3Rlc3RcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTY3JlZW5zaG90IHtcbiAgc2NyZWVuc2hvdElkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gIHRlc3RJZDogc3RyaW5nO1xuICB0YWtlbkF0OiBzdHJpbmc7XG4gIGhlaWdodDogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICBzY3JlZW5zaG90VVJMOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2VSZXN1bHRTdGF0cyB7XG4gIHN1aXRlczogbnVtYmVyO1xuICB0ZXN0czogbnVtYmVyO1xuICBwYXNzZXM6IG51bWJlcjtcbiAgcGVuZGluZzogbnVtYmVyO1xuICBza2lwcGVkOiBudW1iZXI7XG4gIGZhaWx1cmVzOiBudW1iZXI7XG4gIHdhbGxDbG9ja1N0YXJ0ZWRBdDogc3RyaW5nO1xuICB3YWxsQ2xvY2tFbmRlZEF0OiBzdHJpbmc7XG4gIHdhbGxDbG9ja0R1cmF0aW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVwb3J0ZXJTdGF0cyB7XG4gIHN1aXRlczogbnVtYmVyO1xuICB0ZXN0czogbnVtYmVyO1xuICBwYXNzZXM6IG51bWJlcjtcbiAgcGVuZGluZzogbnVtYmVyO1xuICBmYWlsdXJlczogbnVtYmVyO1xuICBzdGFydDogc3RyaW5nO1xuICBlbmQ6IHN0cmluZztcbiAgZHVyYXRpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDeXByZXNzQ29uZmlnIHtcbiAgdmlkZW86IGJvb2xlYW47XG4gIHZpZGVvVXBsb2FkT25QYXNzZXM6IGJvb2xlYW47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZVJlc3VsdCB7XG4gIHN0YXRzOiBJbnN0YW5jZVJlc3VsdFN0YXRzO1xuICB0ZXN0czogVGVzdFtdO1xuICBlcnJvcj86IHN0cmluZztcbiAgcmVwb3J0ZXJTdGF0czogUmVwb3J0ZXJTdGF0cztcbiAgZXhjZXB0aW9uOiBudWxsIHwgc3RyaW5nO1xuICBjeXByZXNzQ29uZmlnPzogUGlja2VkQ3lwcmVzc0NvbmZpZyB8IG51bGw7XG4gIHNjcmVlbnNob3RzOiBTY3JlZW5zaG90W107XG4gIHZpZGVvOiBib29sZWFuO1xuICB2aWRlb1VybD86IHN0cmluZztcbiAgaGFzQ292ZXJhZ2U/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2V0VXBsb2FkSW5zdHJ1Y3Rpb24ge1xuICB1cGxvYWRVcmw6IHN0cmluZztcbiAgcmVhZFVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbiBleHRlbmRzIEFzc2V0VXBsb2FkSW5zdHJ1Y3Rpb24ge1xuICBzY3JlZW5zaG90SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2V0UmVzdWx0c1Rlc3RzUGF5bG9hZCA9IFBpY2s8XG4gIFRlc3QsXG4gIFwic3RhdGVcIiB8IFwiZGlzcGxheUVycm9yXCIgfCBcImF0dGVtcHRzXCJcbj4gJiB7IGNsaWVudElkOiBzdHJpbmcgfTtcblxuZXhwb3J0IGludGVyZmFjZSBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCB7XG4gIGNvbmZpZzogUGlja2VkQ3lwcmVzc0NvbmZpZztcbiAgdGVzdHM6IEFycmF5PFNldFRlc3RzUGF5bG9hZD47XG4gIGhvb2tzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wiaG9va3NcIl07XG59XG5cbmV4cG9ydCB0eXBlIFBpY2tlZEN5cHJlc3NDb25maWcgPSBQaWNrPFxuICBDeXByZXNzQ29uZmlnLFxuICBcInZpZGVvXCIgfCBcInZpZGVvVXBsb2FkT25QYXNzZXNcIlxuPjtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkID0ge1xuICBydW5JZDogc3RyaW5nO1xuICBncm91cElkOiBzdHJpbmc7XG4gIG1hY2hpbmVJZDogc3RyaW5nO1xuICBwbGF0Zm9ybTogUGxhdGZvcm07XG59O1xuXG5leHBvcnQgdHlwZSBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCA9IENyZWF0ZUluc3RhbmNlUGF5bG9hZCAmIHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuZXhwb3J0IHR5cGUgQ3JlYXRlSW5zdGFuY2VSZXNwb25zZSA9IHtcbiAgc3BlYzogc3RyaW5nIHwgbnVsbDtcbiAgaW5zdGFuY2VJZDogc3RyaW5nIHwgbnVsbDtcbiAgY2xhaW1lZEluc3RhbmNlczogbnVtYmVyO1xuICB0b3RhbEluc3RhbmNlczogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzID0ge1xuICBzcGVjOiBzdHJpbmc7XG4gIGluc3RhbmNlSWQ6IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSA9IHtcbiAgc3BlY3M6IEFycmF5PEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlscz47XG4gIGNsYWltZWRJbnN0YW5jZXM6IG51bWJlcjtcbiAgdG90YWxJbnN0YW5jZXM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQgPSBQaWNrPFxuICBJbnN0YW5jZVJlc3VsdCxcbiAgXCJzdGF0c1wiIHwgXCJleGNlcHRpb25cIiB8IFwidmlkZW9cIiB8IFwiaGFzQ292ZXJhZ2VcIlxuPiAmIHtcbiAgdGVzdHM6IEFycmF5PFNldFJlc3VsdHNUZXN0c1BheWxvYWQ+IHwgbnVsbDtcbn0gJiB7XG4gIHJlcG9ydGVyU3RhdHM6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHRbXCJyZXBvcnRlclN0YXRzXCJdIHwgbnVsbDtcbn0gJiB7XG4gIHNjcmVlbnNob3RzOiBTY3JlZW5zaG90QXJ0aWZhY3RbXTtcbn07XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWQgPSB7XG4gIHRlc3RzOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZDtcbiAgcmVzdWx0czogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZDtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUmVzcG9uc2Uge1xuICB2aWRlb1VwbG9hZFVybD86IHN0cmluZyB8IG51bGw7XG4gIHNjcmVlbnNob3RVcGxvYWRVcmxzOiBTY3JlZW5zaG90VXBsb2FkSW5zdHJ1Y3Rpb25bXTtcbiAgY292ZXJhZ2VVcGxvYWRVcmw/OiBzdHJpbmcgfCBudWxsO1xuICBjbG91ZD86IHtcbiAgICBzaG91bGRDYW5jZWw6IGZhbHNlIHwgc3RyaW5nO1xuICB9O1xufVxuIiwgImltcG9ydCB7IENpUGFyYW1zLCBDaVByb3ZpZGVyIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvbGliL2NpUHJvdmlkZXJcIjtcbmltcG9ydCB7IFBsYXRmb3JtLCBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgR2hhRXZlbnREYXRhIH0gZnJvbSBcIi4uLy4uL2dpdFwiO1xuXG5leHBvcnQgdHlwZSBDcmVhdGVSdW5QYXlsb2FkID0ge1xuICBjaToge1xuICAgIHBhcmFtczogQ2lQYXJhbXM7XG4gICAgcHJvdmlkZXI6IENpUHJvdmlkZXI7XG4gIH07XG4gIGNpQnVpbGRJZD86IHN0cmluZztcbiAgcHJvamVjdElkOiBzdHJpbmc7XG4gIHJlY29yZEtleTogc3RyaW5nO1xuICBjb21taXQ6IHtcbiAgICBbbWVtb0tleTogc3RyaW5nXTogc3RyaW5nIHwgR2hhRXZlbnREYXRhIHwgbnVsbDtcbiAgfTtcbiAgc3BlY3M6IHN0cmluZ1tdO1xuICBncm91cD86IHN0cmluZztcbiAgcGxhdGZvcm06IFBsYXRmb3JtO1xuICBwYXJhbGxlbDogYm9vbGVhbjtcbiAgc3BlY1BhdHRlcm46IHN0cmluZ1tdO1xuICB0YWdzPzogc3RyaW5nW107XG4gIHRlc3RpbmdUeXBlOiBcImUyZVwiIHwgXCJjb21wb25lbnRcIjtcbiAgdGltZW91dD86IG51bWJlcjtcbiAgYmF0Y2hTaXplPzogbnVtYmVyO1xuICBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzW1wiYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXNcIl07XG4gIGNvdmVyYWdlRW5hYmxlZD86IGJvb2xlYW47XG4gIHByZXZpb3VzQ2lCdWlsZElkPzogc3RyaW5nO1xuICBwcm92aWRlZE1hY2hpbmVJZD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIENsb3VkV2FybmluZyA9IHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBEYXRlO1xufTtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlUnVuUmVzcG9uc2UgPSB7XG4gIHdhcm5pbmdzOiBDbG91ZFdhcm5pbmdbXTtcbiAgZ3JvdXBJZDogc3RyaW5nO1xuICBtYWNoaW5lSWQ6IHN0cmluZztcbiAgcnVuSWQ6IHN0cmluZztcbiAgcnVuVXJsOiBzdHJpbmc7XG4gIGlzTmV3UnVuOiBib29sZWFuO1xufTtcbiIsICJleHBvcnQgZW51bSBUZXN0U3RhdGUge1xuICBGYWlsZWQgPSBcImZhaWxlZFwiLFxuICBQYXNzZWQgPSBcInBhc3NlZFwiLFxuICBQZW5kaW5nID0gXCJwZW5kaW5nXCIsXG4gIFNraXBwZWQgPSBcInNraXBwZWRcIixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXN0QXR0ZW1wdCB7XG4gIHN0YXRlOiBUZXN0U3RhdGU7XG4gIGVycm9yOiBDeXByZXNzQ29tbWFuZExpbmUuVGVzdEVycm9yIHwgbnVsbDtcbiAgd2FsbENsb2NrU3RhcnRlZEF0OiBzdHJpbmcgfCBudWxsO1xuICB3YWxsQ2xvY2tEdXJhdGlvbjogbnVtYmVyIHwgbnVsbDtcbiAgdmlkZW9UaW1lc3RhbXA6IG51bWJlciB8IG51bGw7XG59XG5cbmludGVyZmFjZSBUZXN0Q29uZmlnIHtcbiAgcmV0cmllczpcbiAgICB8IHtcbiAgICAgICAgb3Blbk1vZGU6IG51bWJlcjtcbiAgICAgICAgcnVuTW9kZTogbnVtYmVyO1xuICAgICAgfVxuICAgIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RIb29rIHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbiAgdHlwZTogXCJiZWZvcmUgZWFjaFwiO1xuICB0aXRsZTogc3RyaW5nW107XG4gIGJvZHk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXN0IHtcbiAgc3RhdGU6IFRlc3RTdGF0ZTtcbiAgdGVzdElkOiBzdHJpbmc7XG4gIGRpc3BsYXlFcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgdGl0bGU6IHN0cmluZ1tdO1xuICBjb25maWc/OiBudWxsIHwgVGVzdENvbmZpZztcbiAgaG9va0lkczogc3RyaW5nW107XG4gIGJvZHk6IHN0cmluZztcbiAgYXR0ZW1wdHM6IFRlc3RBdHRlbXB0W107XG4gIGhvb2tzOiBUZXN0SG9va1tdIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgU2V0VGVzdHNQYXlsb2FkID0gUGljazxcbiAgVGVzdCxcbiAgXCJib2R5XCIgfCBcInRpdGxlXCIgfCBcImNvbmZpZ1wiIHwgXCJob29rSWRzXCJcbj4gJiB7IGNsaWVudElkOiBzdHJpbmcgfTtcbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXJnZVwiO1xuIiwgIi8qISBAcHJlc2VydmVcblxuIyMjIE1JVFxuXG5QYXJ0cyBvZiB0aGlzIGNvZGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MgYW5kIGlzIHN1YmplY3QgdG8gTUlUIGxpY2Vuc2UuXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAyMiBDeXByZXNzLmlvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBkZWJ1Z0ZuIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBHaGFFdmVudERhdGEgfSBmcm9tIFwiLi4vZ2l0XCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5jb25zdCBqb2luID0gKGNoYXI6IHN0cmluZywgLi4ucGllY2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdKSA9PiB7XG4gIHJldHVybiBfLmNoYWluKHBpZWNlcykuY29tcGFjdCgpLmpvaW4oY2hhcikudmFsdWUoKTtcbn07XG5cbmNvbnN0IHRvQ2FtZWxPYmplY3QgPSAob2JqOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBfLnNldChvYmosIF8uY2FtZWxDYXNlKGtleSksIHByb2Nlc3MuZW52W2tleV0pO1xufTtcblxuY29uc3QgZXh0cmFjdCA9IChlbnZLZXlzOiBzdHJpbmdbXSkgPT4ge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZW52S2V5cywgdG9DYW1lbE9iamVjdCwge30pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBUZWFtRm91bmRhdGlvbiBzZXJ2ZXIuXG4gKiBAc2VlIGh0dHBzOi8vdGVjaG5ldC5taWNyb3NvZnQuY29tL2VuLXVzL2hoODUwNDQ4KHY9dnMuOTIpXG4gKi9cbmNvbnN0IGlzVGVhbUZvdW5kYXRpb24gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5URl9CVUlMRCAmJiBwcm9jZXNzLmVudi5URl9CVUlMRF9CVUlMRE5VTUJFUjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gQXp1cmUgQ0kgcGlwZWxpbmUuXG4gKiBTZWUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIHRoZSBpc3N1ZSAjMzY1N1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2lzc3Vlcy8zNjU3XG4gKi9cbmNvbnN0IGlzQXp1cmVDaSA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LlRGX0JVSUxEICYmIHByb2Nlc3MuZW52LkFaVVJFX0hUVFBfVVNFUl9BR0VOVDtcbn07XG5cbmNvbnN0IGlzQVdTQ29kZUJ1aWxkID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT0RFQlVJTERfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNCYW1ib28gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5iYW1ib29fYnVpbGROdW1iZXI7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwQmFzaWMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSAmJlxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgPT09IFwiY29kZXNoaXBcIiAmJlxuICAgIHByb2Nlc3MuZW52LkNPREVTSElQXG4gICk7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwUHJvID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgJiZcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FID09PSBcImNvZGVzaGlwXCIgJiZcbiAgICAhcHJvY2Vzcy5lbnYuQ09ERVNISVBcbiAgKTtcbn07XG5cbmNvbnN0IGlzQ29uY291cnNlID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT05DT1VSU0VfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNHaXRsYWIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0lUTEFCX0NJIHx8XG4gICAgKHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FICYmIC9eR2l0TGFiLy50ZXN0KHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FKSlcbiAgKTtcbn07XG5cbmNvbnN0IGlzR29vZ2xlQ2xvdWQgPSAoKSA9PiB7XG4gIC8vIHNldCBhdXRvbWF0aWNhbGx5IGZvciB0aGUgTm9kZS5qcyA2LCBOb2RlLmpzIDggcnVudGltZXMgKG5vdCBpbiBOb2RlIDEwKVxuICAvLyBUT0RPOiBtYXkgYWxzbyBwb3RlbnRpYWxseSBoYXZlIFhfR09PR0xFXyogZW52IHZhciBzZXRcbiAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIjZW52aXJvbm1lbnRfdmFyaWFibGVzX3NldF9hdXRvbWF0aWNhbGx5XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0NQX1BST0pFQ1QgfHxcbiAgICBwcm9jZXNzLmVudi5HQ0xPVURfUFJPSkVDVCB8fFxuICAgIHByb2Nlc3MuZW52LkdPT0dMRV9DTE9VRF9QUk9KRUNUXG4gICk7XG59O1xuXG5jb25zdCBpc0plbmtpbnMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuSkVOS0lOU19VUkwgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX0hPTUUgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX1ZFUlNJT04gfHxcbiAgICBwcm9jZXNzLmVudi5IVURTT05fVVJMIHx8XG4gICAgcHJvY2Vzcy5lbnYuSFVEU09OX0hPTUVcbiAgKTtcbn07XG5cbmNvbnN0IGlzV2VyY2tlciA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LldFUkNLRVIgfHwgcHJvY2Vzcy5lbnYuV0VSQ0tFUl9NQUlOX1BJUEVMSU5FX1NUQVJURUQ7XG59O1xuXG4vKipcbiAqIFdlIGRldGVjdCBDSSBwcm92aWRlcnMgYnkgZGV0ZWN0aW5nIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiB1bmlxdWUgdG8gdGhlIHByb3ZpZGVyLCBvciBieSBjYWxsaW5nIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWVcbiAqIGZvciB0aGF0IHByb3ZpZGVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBBcHBWZXlvciBDSSBoYXMgZW52aXJvbm1lbnQgdGhlXG4gKiB2YXJpYWJsZSBcIkFQUFZFWU9SXCIgc2V0IGR1cmluZyBydW5cbiAqL1xuY29uc3QgQ0lfUFJPVklERVJTID0ge1xuICBhcHB2ZXlvcjogXCJBUFBWRVlPUlwiLFxuICBhenVyZTogaXNBenVyZUNpLFxuICBhd3NDb2RlQnVpbGQ6IGlzQVdTQ29kZUJ1aWxkLFxuICBiYW1ib286IGlzQmFtYm9vLFxuICBiaXRidWNrZXQ6IFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICBidWlsZGtpdGU6IFwiQlVJTERLSVRFXCIsXG4gIGNpcmNsZTogXCJDSVJDTEVDSVwiLFxuICBjb2Rlc2hpcEJhc2ljOiBpc0NvZGVzaGlwQmFzaWMsXG4gIGNvZGVzaGlwUHJvOiBpc0NvZGVzaGlwUHJvLFxuICBjb25jb3Vyc2U6IGlzQ29uY291cnNlLFxuICBjb2RlRnJlc2g6IFwiQ0ZfQlVJTERfSURcIixcbiAgZHJvbmU6IFwiRFJPTkVcIixcbiAgZ2l0aHViQWN0aW9uczogXCJHSVRIVUJfQUNUSU9OU1wiLFxuICBnaXRsYWI6IGlzR2l0bGFiLFxuICBnb0NEOiBcIkdPX0pPQl9OQU1FXCIsXG4gIGdvb2dsZUNsb3VkOiBpc0dvb2dsZUNsb3VkLFxuICBqZW5raW5zOiBpc0plbmtpbnMsXG4gIHNlbWFwaG9yZTogXCJTRU1BUEhPUkVcIixcbiAgc2hpcHBhYmxlOiBcIlNISVBQQUJMRVwiLFxuICB0ZWFtY2l0eTogXCJURUFNQ0lUWV9WRVJTSU9OXCIsXG4gIHRlYW1mb3VuZGF0aW9uOiBpc1RlYW1Gb3VuZGF0aW9uLFxuICB0cmF2aXM6IFwiVFJBVklTXCIsXG4gIHdlcmNrZXI6IGlzV2VyY2tlcixcbiAgbmV0bGlmeTogXCJORVRMSUZZXCIsXG4gIGxheWVyY2k6IFwiTEFZRVJDSVwiLFxufTtcblxuZnVuY3Rpb24gX2RldGVjdFByb3ZpZGVyTmFtZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IGVudiB9ID0gcHJvY2VzcztcbiAgLy8gcmV0dXJuIHRoZSBrZXkgb2YgdGhlIGZpcnN0IHByb3ZpZGVyXG4gIC8vIHdoaWNoIGlzIHRydXRoeVxuXG4gIHJldHVybiBfLmZpbmRLZXkoQ0lfUFJPVklERVJTLCAodmFsdWUpID0+IHtcbiAgICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBlbnZbdmFsdWVdO1xuICAgIH1cblxuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBkb24ndCBmb3IgYWJvdXQgYnVpbGROdW1iZXIhXG4vLyBsb29rIGF0IHRoZSBvbGQgY29tbWl0IHRoYXQgd2FzIHJlbW92ZWQgdG8gc2VlIGhvdyB3ZSBkaWQgaXRcbmNvbnN0IF9wcm92aWRlckNpUGFyYW1zID0gKCk6IFByb3ZpZGVyQ2lQYXJhbXNSZXMgPT4ge1xuICByZXR1cm4ge1xuICAgIGFwcHZleW9yOiBleHRyYWN0KFtcbiAgICAgIFwiQVBQVkVZT1JfSk9CX0lEXCIsXG4gICAgICBcIkFQUFZFWU9SX0FDQ09VTlRfTkFNRVwiLFxuICAgICAgXCJBUFBWRVlPUl9QUk9KRUNUX1NMVUdcIixcbiAgICAgIFwiQVBQVkVZT1JfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkFQUFZFWU9SX0JVSUxEX1ZFUlNJT05cIixcbiAgICAgIFwiQVBQVkVZT1JfUFVMTF9SRVFVRVNUX05VTUJFUlwiLFxuICAgICAgXCJBUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSFwiLFxuICAgIF0pLFxuICAgIGF6dXJlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfQlVJTERJRFwiLFxuICAgICAgXCJCVUlMRF9CVUlMRE5VTUJFUlwiLFxuICAgICAgXCJCVUlMRF9DT05UQUlORVJJRFwiLFxuICAgICAgXCJCVUlMRF9SRVBPU0lUT1JZX1VSSVwiLFxuICAgIF0pLFxuICAgIGF3c0NvZGVCdWlsZDogZXh0cmFjdChbXG4gICAgICBcIkNPREVCVUlMRF9CVUlMRF9JRFwiLFxuICAgICAgXCJDT0RFQlVJTERfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkNPREVCVUlMRF9SRVNPTFZFRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgXCJDT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMXCIsXG4gICAgICBcIkNPREVCVUlMRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgIF0pLFxuICAgIGJhbWJvbzogZXh0cmFjdChbXG4gICAgICBcImJhbWJvb19idWlsZE51bWJlclwiLFxuICAgICAgXCJiYW1ib29fYnVpbGRSZXN1bHRzVXJsXCIsXG4gICAgICBcImJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXBvc2l0b3J5VXJsXCIsXG4gICAgICBcImJhbWJvb19idWlsZEtleVwiLFxuICAgIF0pLFxuICAgIGJpdGJ1Y2tldDogZXh0cmFjdChbXG4gICAgICBcIkJJVEJVQ0tFVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiQklUQlVDS0VUX1JFUE9fT1dORVJcIixcbiAgICAgIFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCSVRCVUNLRVRfUEFSQUxMRUxfU1RFUFwiLFxuICAgICAgXCJCSVRCVUNLRVRfU1RFUF9SVU5fTlVNQkVSXCIsXG4gICAgICAvLyB0aGUgUFIgdmFyaWFibGVzIGFyZSBvbmx5IHNldCBvbiBwdWxsIHJlcXVlc3QgYnVpbGRzXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9JRFwiLFxuICAgICAgXCJCSVRCVUNLRVRfUFJfREVTVElOQVRJT05fQlJBTkNIXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9ERVNUSU5BVElPTl9DT01NSVRcIixcbiAgICBdKSxcbiAgICBidWlsZGtpdGU6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMREtJVEVfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfU09VUkNFXCIsXG4gICAgICBcIkJVSUxES0lURV9KT0JfSURcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxES0lURV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUX0JBU0VfQlJBTkNIXCIsXG4gICAgXSksXG4gICAgY2lyY2xlOiBleHRyYWN0KFtcbiAgICAgIFwiQ0lSQ0xFX0pPQlwiLFxuICAgICAgXCJDSVJDTEVfQlVJTERfTlVNXCIsXG4gICAgICBcIkNJUkNMRV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX05VTUJFUlwiLFxuICAgICAgXCJDSVJDTEVfUFJfUkVQT05BTUVcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX1VTRVJOQU1FXCIsXG4gICAgICBcIkNJUkNMRV9DT01QQVJFX1VSTFwiLFxuICAgICAgXCJDSVJDTEVfV09SS0ZMT1dfSURcIixcbiAgICAgIFwiQ0lSQ0xFX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJDSVJDTEVfUkVQT1NJVE9SWV9VUkxcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgY29kZXNoaXBCYXNpYzogZXh0cmFjdChbXG4gICAgICBcIkNJX0JVSUxEX0lEXCIsXG4gICAgICBcIkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJDSV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9JRFwiLFxuICAgICAgXCJDSV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgLy8gQ29kZXNoaXBQcm8gcHJvdmlkZXMgdmVyeSBmZXcgQ0kgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9kb2N1bWVudGF0aW9uLmNvZGVzaGlwLmNvbS9wcm8vYnVpbGRzLWFuZC1jb25maWd1cmF0aW9uL2Vudmlyb25tZW50LXZhcmlhYmxlcy9cbiAgICBjb2Rlc2hpcFBybzogZXh0cmFjdChbXCJDSV9CVUlMRF9JRFwiLCBcIkNJX1JFUE9fTkFNRVwiLCBcIkNJX1BST0pFQ1RfSURcIl0pLFxuICAgIC8vIGh0dHBzOi8vY29uY291cnNlLWNpLm9yZy9pbXBsZW1lbnRpbmctcmVzb3VyY2UtdHlwZXMuaHRtbCNyZXNvdXJjZS1tZXRhZGF0YVxuICAgIGNvbmNvdXJzZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxEX05BTUVcIixcbiAgICAgIFwiQlVJTERfSk9CX05BTUVcIixcbiAgICAgIFwiQlVJTERfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9URUFNX05BTUVcIixcbiAgICAgIFwiQVRDX0VYVEVSTkFMX1VSTFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vY29kZWZyZXNoLmlvL2RvY3MvZG9jcy9jb2RlZnJlc2gteWFtbC92YXJpYWJsZXMvXG4gICAgY29kZUZyZXNoOiBleHRyYWN0KFtcbiAgICAgIFwiQ0ZfQlVJTERfSURcIixcbiAgICAgIFwiQ0ZfQlVJTERfVVJMXCIsXG4gICAgICBcIkNGX0NVUlJFTlRfQVRURU1QVFwiLFxuICAgICAgXCJDRl9TVEVQX05BTUVcIixcbiAgICAgIFwiQ0ZfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJDRl9QSVBFTElORV9UUklHR0VSX0lEXCIsXG4gICAgICAvLyB2YXJpYWJsZXMgYWRkZWQgZm9yIHB1bGwgcmVxdWVzdHNcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX0lEXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9JU19GT1JLXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9OVU1CRVJcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX1RBUkdFVFwiLFxuICAgIF0pLFxuICAgIGRyb25lOiBleHRyYWN0KFtcbiAgICAgIFwiRFJPTkVfSk9CX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9CVUlMRF9MSU5LXCIsXG4gICAgICBcIkRST05FX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2hlbHAuZ2l0aHViLmNvbS9lbi9hY3Rpb25zL2F1dG9tYXRpbmcteW91ci13b3JrZmxvdy13aXRoLWdpdGh1Yi1hY3Rpb25zL3VzaW5nLWVudmlyb25tZW50LXZhcmlhYmxlcyNkZWZhdWx0LWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdpdGh1YkFjdGlvbnM6IGV4dHJhY3QoW1xuICAgICAgXCJHSVRIVUJfV09SS0ZMT1dcIixcbiAgICAgIFwiR0lUSFVCX0FDVElPTlwiLFxuICAgICAgXCJHSVRIVUJfRVZFTlRfTkFNRVwiLFxuICAgICAgXCJHSVRIVUJfUlVOX0lEXCIsXG4gICAgICBcIkdJVEhVQl9SVU5fQVRURU1QVFwiLFxuICAgICAgXCJHSVRIVUJfUkVQT1NJVE9SWVwiLFxuICAgIF0pLFxuICAgIC8vIHNlZSBodHRwczovL2RvY3MuZ2l0bGFiLmNvbS9lZS9jaS92YXJpYWJsZXMvXG4gICAgZ2l0bGFiOiBleHRyYWN0KFtcbiAgICAgIC8vIHBpcGVsaW5lIGlzIGNvbW1vbiBhbW9uZyBhbGwgam9ic1xuICAgICAgXCJDSV9QSVBFTElORV9JRFwiLFxuICAgICAgXCJDSV9QSVBFTElORV9VUkxcIixcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJDSV9CVUlMRF9JRFwiLCAvLyBidWlsZCBpZCBhbmQgam9iIGlkIGFyZSBhbGlhc2VzXG4gICAgICBcIkNJX0pPQl9JRFwiLFxuICAgICAgXCJDSV9KT0JfVVJMXCIsXG4gICAgICBcIkNJX0pPQl9OQU1FXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJHSVRMQUJfSE9TVFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX0lEXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfVVJMXCIsXG4gICAgICBcIkNJX1JFUE9TSVRPUllfVVJMXCIsXG4gICAgICBcIkNJX0VOVklST05NRU5UX1VSTFwiLFxuICAgICAgXCJDSV9ERUZBVUxUX0JSQU5DSFwiLFxuICAgICAgLy8gZm9yIFBSczogaHR0cHM6Ly9naXRsYWIuY29tL2dpdGxhYi1vcmcvZ2l0bGFiLWNlL2lzc3Vlcy8yMzkwMlxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5nb2NkLm9yZy9jdXJyZW50L2ZhcS9kZXZfdXNlX2N1cnJlbnRfcmV2aXNpb25faW5fYnVpbGQuaHRtbCNzdGFuZGFyZC1nb2NkLWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdvQ0Q6IGV4dHJhY3QoW1xuICAgICAgXCJHT19TRVJWRVJfVVJMXCIsXG4gICAgICBcIkdPX0VOVklST05NRU5UX05BTUVcIixcbiAgICAgIFwiR09fUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJHT19QSVBFTElORV9DT1VOVEVSXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX0xBQkVMXCIsXG4gICAgICBcIkdPX1NUQUdFX05BTUVcIixcbiAgICAgIFwiR09fU1RBR0VfQ09VTlRFUlwiLFxuICAgICAgXCJHT19KT0JfTkFNRVwiLFxuICAgICAgXCJHT19UUklHR0VSX1VTRVJcIixcbiAgICAgIFwiR09fUkVWSVNJT05cIixcbiAgICAgIFwiR09fVE9fUkVWSVNJT05cIixcbiAgICAgIFwiR09fRlJPTV9SRVZJU0lPTlwiLFxuICAgICAgXCJHT19NQVRFUklBTF9IQVNfQ0hBTkdFRFwiLFxuICAgIF0pLFxuICAgIGdvb2dsZUNsb3VkOiBleHRyYWN0KFtcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJQUk9KRUNUX0lEXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJSRVBPX05BTUVcIixcbiAgICAgIFwiQlJBTkNIX05BTUVcIixcbiAgICAgIFwiVEFHX05BTUVcIixcbiAgICAgIFwiQ09NTUlUX1NIQVwiLFxuICAgICAgXCJTSE9SVF9TSEFcIixcbiAgICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jbG91ZC1idWlsZC9kb2NzL2FwaS9yZWZlcmVuY2UvcmVzdC9TaGFyZWQuVHlwZXMvQnVpbGRcbiAgICBdKSxcbiAgICBqZW5raW5zOiBleHRyYWN0KFtcIkJVSUxEX0lEXCIsIFwiQlVJTERfVVJMXCIsIFwiQlVJTERfTlVNQkVSXCIsIFwiZ2hwcmJQdWxsSWRcIl0pLFxuICAgIC8vIGh0dHBzOi8vc2VtYXBob3JlY2kuY29tL2RvY3MvYXZhaWxhYmxlLWVudmlyb25tZW50LXZhcmlhYmxlcy5odG1sXG4gICAgLy8gc29tZSBjb21lIGZyb20gdjEsIHNvbWUgZnJvbSB2MiBvZiBzZW1hcGhvcmVcbiAgICBzZW1hcGhvcmU6IGV4dHJhY3QoW1xuICAgICAgXCJTRU1BUEhPUkVfQlJBTkNIX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX0NVUlJFTlRfSk9CXCIsXG4gICAgICBcIlNFTUFQSE9SRV9DVVJSRU5UX1RIUkVBRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfRVhFQ1VUQUJMRV9VVUlEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfQlJBTkNIXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfRElSXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGX1RZUEVcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9VUkxcIixcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9DT1VOVFwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX0lEXCIsIC8vIHYyXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfTkFNRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1BJUEVMSU5FX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QTEFURk9STVwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9ESVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfSEFTSF9JRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9JRFwiLCAvLyB2MlxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9OQU1FXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1JFUE9fU0xVR1wiLFxuICAgICAgXCJTRU1BUEhPUkVfVFJJR0dFUl9TT1VSQ0VcIixcbiAgICAgIFwiU0VNQVBIT1JFX1dPUktGTE9XX0lEXCIsXG4gICAgICBcIlBVTExfUkVRVUVTVF9OVU1CRVJcIiwgLy8gcHVsbCByZXF1ZXN0cyBmcm9tIGZvcmtzIE9OTFlcbiAgICBdKSxcbiAgICAvLyBzZWUgaHR0cDovL2RvY3Muc2hpcHBhYmxlLmNvbS9jaS9lbnYtdmFycy9cbiAgICBzaGlwcGFibGU6IGV4dHJhY3QoW1xuICAgICAgLy8gYnVpbGQgdmFyaWFibGVzXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9JRFwiLCAvLyBcIjViOTMzNTRjYWJmYWJiMDcwMDdmMDFmZFwiXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9OVU1CRVJcIiwgLy8gXCI0XCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTU1JVF9SQU5HRVwiLCAvLyBcInNoYTEuLi5zaGEyXCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTlRBSU5FUl9OQU1FXCIsIC8vIFwiYy5leGVjLmN5cHJlc3MtZXhhbXBsZS1raXRjaGVuc2luay40LjFcIlxuICAgICAgXCJTSElQUEFCTEVfSk9CX0lEXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9KT0JfTlVNQkVSXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9SRVBPX1NMVUdcIiwgLy8gXCI8dXNlcm5hbWU+LzxyZXBvPlwiXG4gICAgICAvLyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgU2hpcHBhYmxlIHByb3ZpZGVzXG4gICAgICBcIklTX0ZPUktcIiwgLy8gXCJ0cnVlXCJcbiAgICAgIFwiSVNfR0lUX1RBR1wiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUFJFUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiUkVQT1NJVE9SWV9VUkxcIiwgLy8gXCJodHRwczovL2dpdGh1Yi5jb20vLi4uLmdpdFwiXG4gICAgICBcIlJFUE9fRlVMTF9OQU1FXCIsIC8vIFwiPHVzZXJuYW1lPi88cmVwbz5cIlxuICAgICAgXCJSRVBPX05BTUVcIiwgLy8gXCJjeXByZXNzLWV4YW1wbGUta2l0Y2hlbnNpbmtcIlxuICAgICAgXCJCVUlMRF9VUkxcIiwgLy8gXCJodHRwczovL2FwcC5zaGlwcGFibGUuY29tL2dpdGh1Yi88dXNlcm5hbWU+LzxyZXBvPi9ydW5zLzFcIlxuICAgICAgLy8gUHVsbCByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICBcIkJBU0VfQlJBTkNIXCIsIC8vIE5hbWUgb2YgdGhlIHRhcmdldCBicmFuY2ggaW50byB3aGljaCB0aGUgcHVsbCByZXF1ZXN0IGNoYW5nZXMgd2lsbCBiZSBtZXJnZWQuXG4gICAgICBcIkhFQURfQlJBTkNIXCIsIC8vIFRoaXMgaXMgb25seSBzZXQgZm9yIHB1bGwgcmVxdWVzdHMgYW5kIGlzIHRoZSBuYW1lIG9mIHRoZSBicmFuY2ggdGhlIHB1bGwgcmVxdWVzdCB3YXMgb3BlbmVkIGZyb20uXG4gICAgICBcIklTX1BVTExfUkVRVUVTVFwiLCAvLyBcImZhbHNlXCIgb3IgXCJ0cnVlXCJcbiAgICAgIFwiUFVMTF9SRVFVRVNUXCIsIC8vIFB1bGwgcmVxdWVzdCBudW1iZXIgaWYgdGhlIGpvYiBpcyBhIHB1bGwgcmVxdWVzdC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgICAgXCJQVUxMX1JFUVVFU1RfQkFTRV9CUkFOQ0hcIiwgLy8gTmFtZSBvZiB0aGUgYnJhbmNoIHRoYXQgdGhlIHB1bGwgcmVxdWVzdCB3aWxsIGJlIG1lcmdlZCBpbnRvLiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgQkFTRV9CUkFOQ0guXG4gICAgICBcIlBVTExfUkVRVUVTVF9SRVBPX0ZVTExfTkFNRVwiLCAvLyBGdWxsIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgZnJvbSB3aGVyZSB0aGUgcHVsbCByZXF1ZXN0IG9yaWdpbmF0ZWQuXG4gICAgXSksXG4gICAgdGVhbWNpdHk6IG51bGwsXG4gICAgdGVhbWZvdW5kYXRpb246IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9CVUlMRElEXCIsXG4gICAgICBcIkJVSUxEX0JVSUxETlVNQkVSXCIsXG4gICAgICBcIkJVSUxEX0NPTlRBSU5FUklEXCIsXG4gICAgXSksXG4gICAgdHJhdmlzOiBleHRyYWN0KFtcbiAgICAgIFwiVFJBVklTX0pPQl9JRFwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfSURcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX1dFQl9VUkxcIixcbiAgICAgIFwiVFJBVklTX1JFUE9fU0xVR1wiLFxuICAgICAgXCJUUkFWSVNfSk9CX05VTUJFUlwiLFxuICAgICAgXCJUUkFWSVNfRVZFTlRfVFlQRVwiLFxuICAgICAgXCJUUkFWSVNfQ09NTUlUX1JBTkdFXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiVFJBVklTX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX0JSQU5DSFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX1NIQVwiLFxuICAgIF0pLFxuICAgIHdlcmNrZXI6IG51bGwsXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm5ldGxpZnkuY29tL2NvbmZpZ3VyZS1idWlsZHMvZW52aXJvbm1lbnQtdmFyaWFibGVzLyNkZXBsb3ktdXJscy1hbmQtbWV0YWRhdGFcbiAgICBuZXRsaWZ5OiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiQ09OVEVYVFwiLFxuICAgICAgXCJVUkxcIixcbiAgICAgIFwiREVQTE9ZX1VSTFwiLFxuICAgICAgXCJERVBMT1lfUFJJTUVfVVJMXCIsXG4gICAgICBcIkRFUExPWV9JRFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vbGF5ZXJjaS5jb20vZG9jcy9sYXllcmZpbGUtcmVmZXJlbmNlL2J1aWxkLWVudlxuICAgIGxheWVyY2k6IGV4dHJhY3QoW1xuICAgICAgXCJMQVlFUkNJX0pPQl9JRFwiLFxuICAgICAgXCJMQVlFUkNJX1JVTk5FUl9JRFwiLFxuICAgICAgXCJSRVRSWV9JTkRFWFwiLFxuICAgICAgXCJMQVlFUkNJX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fT1dORVJcIixcbiAgICAgIFwiTEFZRVJDSV9CUkFOQ0hcIixcbiAgICAgIFwiR0lUX1RBR1wiLCAvLyBzaG9ydCBoZXggZm9yIGNvbW1pdHNcbiAgICBdKSxcbiAgfTtcbn07XG5cbi8vIHRyaWVzIHRvIGdyYWIgY29tbWl0IGluZm9ybWF0aW9uIGZyb20gQ0kgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyB2ZXJ5IHVzZWZ1bCB0byBmaWxsIG1pc3NpbmcgaW5mb3JtYXRpb24gd2hlbiBHaXQgY2Fubm90IGdyYWIgY29ycmVjdCB2YWx1ZXNcbmNvbnN0IF9wcm92aWRlckNvbW1pdFBhcmFtcyA9ICgpOiBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyA9PiB7XG4gIGNvbnN0IHsgZW52IH0gPSBwcm9jZXNzO1xuXG4gIHJldHVybiB7XG4gICAgYXBwdmV5b3I6IHtcbiAgICAgIHNoYTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlULFxuICAgICAgLy8gc2luY2UgQVBQVkVZT1JfUkVQT19CUkFOQ0ggd2lsbCBiZSB0aGUgdGFyZ2V0IGJyYW5jaCBvbiBhIFBSXG4gICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBQVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSCBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBlLmcuIGlmIHlvdSBoYXZlIGEgUFI6IGRldmVsb3AgPC0gbXktZmVhdHVyZS1icmFuY2hcbiAgICAgIC8vIG15LWZlYXR1cmUtYnJhbmNoIGlzIEFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIXG4gICAgICAvLyBkZXZlbG9wICAgICAgICAgICBpcyBBUFBWRVlPUl9SRVBPX0JSQU5DSFxuICAgICAgYnJhbmNoOlxuICAgICAgICBlbnYuQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0ggfHwgZW52LkFQUFZFWU9SX1JFUE9fQlJBTkNILFxuICAgICAgbWVzc2FnZTogam9pbihcbiAgICAgICAgXCJcXG5cIixcbiAgICAgICAgZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX01FU1NBR0UsXG4gICAgICAgIGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9NRVNTQUdFX0VYVEVOREVEXG4gICAgICApLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX0FVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYXdzQ29kZUJ1aWxkOiB7XG4gICAgICBzaGE6IGVudi5DT0RFQlVJTERfUkVTT0xWRURfU09VUkNFX1ZFUlNJT04sXG4gICAgICAvLyBicmFuY2g6ID8/PyxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBhenVyZToge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQlVJTERfUkVRVUVTVEVERk9SRU1BSUwsXG4gICAgfSxcbiAgICBiYW1ib286IHtcbiAgICAgIHNoYTogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXZpc2lvbixcbiAgICAgIGJyYW5jaDogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9icmFuY2gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIGF1dGhvck5hbWU6IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfdXNlcm5hbWUsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfcmVwb3NpdG9yeVVSTCxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYml0YnVja2V0OiB7XG4gICAgICBzaGE6IGVudi5CSVRCVUNLRVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuQklUQlVDS0VUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBidWlsZGtpdGU6IHtcbiAgICAgIHNoYTogZW52LkJVSUxES0lURV9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CVUlMREtJVEVfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkJVSUxES0lURV9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkJVSUxES0lURV9CVUlMRF9DUkVBVE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5CVUlMREtJVEVfQlVJTERfQ1JFQVRPUl9FTUFJTCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkJVSUxES0lURV9SRVBPLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkJVSUxES0lURV9QSVBFTElORV9ERUZBVUxUX0JSQU5DSCxcbiAgICB9LFxuICAgIGNpcmNsZToge1xuICAgICAgc2hhOiBlbnYuQ0lSQ0xFX1NIQTEsXG4gICAgICBicmFuY2g6IGVudi5DSVJDTEVfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lSQ0xFX1VTRVJOQU1FLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lSQ0xFX1JFUE9TSVRPUllfVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBjb2Rlc2hpcEJhc2ljOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVzaGlwUHJvOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVGcmVzaDoge1xuICAgICAgc2hhOiBlbnYuQ0ZfUkVWSVNJT04sXG4gICAgICBicmFuY2g6IGVudi5DRl9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0ZfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0ZfQ09NTUlUX0FVVEhPUixcbiAgICB9LFxuICAgIGRyb25lOiB7XG4gICAgICBzaGE6IGVudi5EUk9ORV9DT01NSVRfU0hBLFxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmRyb25lLmlvL3BpcGVsaW5lL2Vudmlyb25tZW50L3JlZmVyZW5jZS9kcm9uZS1zb3VyY2UtYnJhbmNoL1xuICAgICAgYnJhbmNoOiBlbnYuRFJPTkVfU09VUkNFX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5EUk9ORV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuRFJPTkVfR0lUX0hUVFBfVVJMLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkRST05FX1JFUE9fQlJBTkNILFxuICAgIH0sXG4gICAgZ2l0aHViQWN0aW9uczoge1xuICAgICAgc2hhOiBlbnYuR0lUSFVCX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkdIX0JSQU5DSCB8fCBlbnYuR0lUSFVCX1JFRixcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5HSVRIVUJfQkFTRV9SRUYsXG4gICAgICByZW1vdGVCcmFuY2g6IGVudi5HSVRIVUJfSEVBRF9SRUYsXG4gICAgICBydW5BdHRlbXB0OiBlbnYuR0lUSFVCX1JVTl9BVFRFTVBULFxuICAgIH0sXG4gICAgZ2l0bGFiOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuQ0lfQ09NTUlUX1JFRl9OQU1FLFxuICAgICAgbWVzc2FnZTogZW52LkNJX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkdJVExBQl9VU0VSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkdJVExBQl9VU0VSX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lfUkVQT1NJVE9SWV9VUkwsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuQ0lfREVGQVVMVF9CUkFOQ0gsXG4gICAgfSxcbiAgICBnb29nbGVDbG91ZDoge1xuICAgICAgc2hhOiBlbnYuQ09NTUlUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSF9OQU1FLFxuICAgICAgLy8gbWVzc2FnZTogPz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/P1xuICAgIH0sXG4gICAgamVua2luczoge1xuICAgICAgc2hhOiBlbnYuR0lUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkdJVF9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgLy8gT25seSBmcm9tIGZvcmtzPyBodHRwczovL3NlbWFwaG9yZWNpLmNvbS9kb2NzL2F2YWlsYWJsZS1lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbFxuICAgIHNlbWFwaG9yZToge1xuICAgICAgc2hhOiBlbnYuU0VNQVBIT1JFX0dJVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5TRU1BUEhPUkVfR0lUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5TRU1BUEhPUkVfR0lUX1JFUE9fU0xVRyxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc2hpcHBhYmxlOiB7XG4gICAgICBzaGE6IGVudi5DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ09NTUlUVEVSLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc25hcDogbnVsbCxcbiAgICB0ZWFtY2l0eTogbnVsbCxcbiAgICB0ZWFtZm91bmRhdGlvbjoge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICB9LFxuICAgIHRyYXZpczoge1xuICAgICAgc2hhOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9TSEEgfHwgZW52LlRSQVZJU19DT01NSVQsXG4gICAgICAvLyBmb3IgUFJzLCBUUkFWSVNfQlJBTkNIIGlzIHRoZSBiYXNlIGJyYW5jaCBiZWluZyBtZXJnZWQgaW50b1xuICAgICAgYnJhbmNoOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9CUkFOQ0ggfHwgZW52LlRSQVZJU19CUkFOQ0gsXG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIG1lc3NhZ2U6IGVudi5UUkFWSVNfQ09NTUlUX01FU1NBR0UsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICB3ZXJja2VyOiBudWxsLFxuICAgIG5ldGxpZnk6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVF9SRUYsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5SRVBPU0lUT1JZX1VSTCxcbiAgICB9LFxuICAgIGxheWVyY2k6IHtcbiAgICAgIHNoYTogZW52LkdJVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5MQVlFUkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5HSVRfQ09NTUlUX1RJVExFLFxuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBDaVByb3ZpZGVyRGF0YSA9IHtcbiAgc2hhPzogc3RyaW5nO1xuICBicmFuY2g/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGF1dGhvck5hbWU/OiBzdHJpbmc7XG4gIGF1dGhvckVtYWlsPzogc3RyaW5nO1xuICByZW1vdGVPcmlnaW4/OiBzdHJpbmc7XG4gIGRlZmF1bHRCcmFuY2g/OiBzdHJpbmc7XG4gIHJlbW90ZUJyYW5jaD86IHN0cmluZztcbiAgcnVuQXR0ZW1wdD86IHN0cmluZztcbiAgZ2hhRXZlbnREYXRhPzogR2hhRXZlbnREYXRhIHwgbnVsbDtcbn07XG5cbmludGVyZmFjZSBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyB7XG4gIFtrZXk6IHN0cmluZ106IENpUHJvdmlkZXJEYXRhIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFByb3ZpZGVyQ2lQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgX2dldCA9IChmbjogKCkgPT4gUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgfCBQcm92aWRlckNpUGFyYW1zUmVzKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlck5hbWUpIHJldHVybiB7fTtcblxuICByZXR1cm4gXy5jaGFpbihmbigpKS5nZXQocHJvdmlkZXJOYW1lKS52YWx1ZSgpO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBubyBidWlsZCBJRCBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYnkgdXNlclxuICogQ2hlY2sgaWYgd2UgY2FuIGZldGNoIGl0IGF1dG9tYXRpY2FsbHkgZnJvbSBDSSB2YXJpYWJsZXMuXG4gKiBUaGUgcHJvY2VzcyB3aWxsIHN0b3AgaWYgd2UgY2Fubm90IGRvIGl0XG4gKiBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvcmVmZXJlbmNlcy9lcnJvci1tZXNzYWdlcyNXZS1jb3VsZC1ub3QtZGV0ZXJtaW5lLWEtdW5pcXVlLUNJLWJ1aWxkLUlEXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShjaVByb3ZpZGVyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChjaVByb3ZpZGVyICYmIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKS5pbmNsdWRlcyhjaVByb3ZpZGVyKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIENJIGJ1aWxkIElEIGZyb20gdGhlIGVudmlyb25tZW50LiBQbGVhc2UgcHJvdmlkZSBhIHVuaXF1ZSBDSSBidWlsZCBJRCB1c2luZyB0aGUgLS1jaS1idWlsZC1pZCBDTEkgZmxhZyBvciAnY2lCdWlsZElkJyBwYXJhbWV0ZXIgZm9yICdydW4nIG1ldGhvZC5gXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0KCkge1xuICByZXR1cm4gXy5rZXlzKENJX1BST1ZJREVSUyk7XG59XG5cbi8vIGdyYWIgYWxsIGRldGVjdGFibGUgcHJvdmlkZXJzXG4vLyB0aGF0IHdlIGNhbiBleHRyYWN0IGNpQnVpbGRJZCBmcm9tXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0YWJsZUNpQnVpbGRJZFByb3ZpZGVycygpIHtcbiAgcmV0dXJuIF8uY2hhaW4oX3Byb3ZpZGVyQ2lQYXJhbXMoKSkub21pdEJ5KF8uaXNOdWxsKS5rZXlzKCkudmFsdWUoKTtcbn1cblxuZXhwb3J0IHR5cGUgQ2lQcm92aWRlciA9IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaVByb3ZpZGVyKCk6IENpUHJvdmlkZXIge1xuICByZXR1cm4gX2RldGVjdFByb3ZpZGVyTmFtZSgpIHx8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIENpUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNpUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFBhcmFtcygpIHtcbiAgcmV0dXJuIF9nZXQoX3Byb3ZpZGVyQ29tbWl0UGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENJKGNpQnVpbGRJZD86IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSBnZXRDaVBhcmFtcygpIGFzIENpUGFyYW1zO1xuICBjb25zdCBwcm92aWRlciA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFjaUJ1aWxkSWQpIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShwcm92aWRlcik7XG5cbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwcm92aWRlcjogJXNcIiwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcImRldGVjdGVkIENJIHBhcmFtczogJU9cIiwgcGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcHJvdmlkZXIsXG4gIH07XG59XG4iLCAiaW1wb3J0IGRlYnVnRm4gZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbmltcG9ydCB7IEdoYUV2ZW50RGF0YSB9IGZyb20gXCIuLi9naXRcIjtcbmltcG9ydCB7IENpUHJvdmlkZXIsIENpUHJvdmlkZXJEYXRhLCBnZXRDb21taXRQYXJhbXMgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWl0RGVmYXVsdHMoZXhpc3RpbmdJbmZvOiBDaVByb3ZpZGVyRGF0YSkge1xuICBkZWJ1ZyhcImdpdCBjb21taXQgZXhpc3RpbmcgaW5mb1wiKTtcbiAgZGVidWcoZXhpc3RpbmdJbmZvKTtcblxuICBjb25zdCBjb21taXRQYXJhbXNPYmogPSBnZXRDb21taXRQYXJhbXMoKTtcblxuICBkZWJ1ZyhcImNvbW1pdCBpbmZvIGZyb20gcHJvdmlkZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzOiAlT1wiLCBjb21taXRQYXJhbXNPYmopO1xuXG4gIC8vIGJhc2VkIG9uIHRoZSBleGlzdGluZ0luZm8gcHJvcGVydGllc1xuICAvLyBtZXJnZSBpbiB0aGUgY29tbWl0UGFyYW1zIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gIC8vIGRlZmF1bHRpbmcgYmFjayB0byBudWxsIGlmIGFsbCBmYWlsc1xuICAvLyBOT1RFOiBvbmx5IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBcImV4aXN0aW5nSW5mb1wiIHdpbGwgYmUgcmV0dXJuZWRcbiAgY29uc3QgY29tYmluZWQgPSBfLnRyYW5zZm9ybShcbiAgICBleGlzdGluZ0luZm8sXG4gICAgKFxuICAgICAgbWVtbzogeyBbbWVtb0tleTogc3RyaW5nXTogc3RyaW5nIHwgR2hhRXZlbnREYXRhIHwgbnVsbCB9LFxuICAgICAgdmFsdWU6IHN0cmluZyB8IEdoYUV2ZW50RGF0YSB8IG51bGwsXG4gICAgICBrZXk6IHN0cmluZ1xuICAgICkgPT4ge1xuICAgICAgcmV0dXJuIChtZW1vW2tleV0gPSBfLmRlZmF1bHRUbyhcbiAgICAgICAgdmFsdWUgfHxcbiAgICAgICAgICAoY29tbWl0UGFyYW1zT2JqID8gY29tbWl0UGFyYW1zT2JqW2tleSBhcyBrZXlvZiBDaVByb3ZpZGVyXSA6IG51bGwpLFxuICAgICAgICBudWxsXG4gICAgICApKTtcbiAgICB9XG4gICk7XG5cbiAgZGVidWcoXCJjb21iaW5lZCBnaXQgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHByb3ZpZGVyXCIpO1xuICBkZWJ1Zyhjb21iaW5lZCk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuIiwgImltcG9ydCBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q292ZXJhZ2VGaWxlUGF0aCA9IGFzeW5jIChcbiAgY292ZXJhZ2VGaWxlID0gXCIuLy5ueWNfb3V0cHV0L291dC5qc29uXCJcbikgPT4ge1xuICBjb25zdCBwYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCBjb3ZlcmFnZUZpbGUpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMuYWNjZXNzKHBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGZhbHNlLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcixcbiAgICB9O1xuICB9XG59O1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL2N5cHJlc3NcIjtcbiIsICJpbXBvcnQgY3lwcmVzcyBmcm9tIFwiY3lwcmVzc1wiO1xuaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBDeXByZXNzUmVzdWx0LFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50c0NvbmZpZywgZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IHNhZmUgfSBmcm9tIFwiLi4vbGFuZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldFdTU1BvcnQgfSBmcm9tIFwiLi4vd3NcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmN5cHJlc3NcIik7XG5pbnRlcmZhY2UgUnVuQ3lwcmVzc1NwZWNGaWxlIHtcbiAgc3BlYzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuQmFyZUN5cHJlc3MocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSB7fSkge1xuICAvLyByZXZlcnQgY3VycmVudHMgcGFyYW1zIHRvIGN5cHJlc3MgcGFyYW1zXG4gIC8vIGV4Y2x1ZGUgcmVjb3JkIG1vZGUgcGFyYW1zXG4gIGNvbnN0IHAgPSB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGNpQnVpbGRJZDogdW5kZWZpbmVkLFxuICAgIHRhZzogdW5kZWZpbmVkLFxuICAgIHBhcmFsbGVsOiB1bmRlZmluZWQsXG4gICAgcmVjb3JkOiBmYWxzZSxcbiAgICBncm91cDogdW5kZWZpbmVkLFxuICAgIHNwZWM6IF8uZmxhdHRlbihwYXJhbXMuc3BlYykuam9pbihcIixcIiksXG4gIH07XG4gIGRlYnVnKFwiUnVubmluZyBiYXJlIEN5cHJlc3Mgd2l0aCBwYXJhbXMgJW9cIiwgcCk7XG4gIHJldHVybiBjeXByZXNzLnJ1bihwKTtcbn1cblxuLyoqXG4gKiBSdW4gQ3lwcmVzcyB0ZXN0cywgd2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIHN0cmlwcGVkIG9wdGlvbnMgYXMgaWYgd2UndmUgcmVjZWl2ZWQgdGhlbSBmcm9tIHRoZSBDTElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blNwZWNGaWxlKFxuICB7IHNwZWMgfTogUnVuQ3lwcmVzc1NwZWNGaWxlLFxuICBjeXByZXNzUnVuT3B0aW9uczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pIHtcbiAgY29uc3QgcnVuQVBJT3B0aW9ucyA9IGdldEN5cHJlc3NSdW5BUElQYXJhbXMoY3lwcmVzc1J1bk9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ucnVuQVBJT3B0aW9ucyxcbiAgICBjb25maWc6IHtcbiAgICAgIC4uLnJ1bkFQSU9wdGlvbnMuY29uZmlnLFxuICAgICAgdHJhc2hBc3NldHNCZWZvcmVSdW5zOiBmYWxzZSxcbiAgICB9LFxuICAgIGVudjoge1xuICAgICAgLi4ucnVuQVBJT3B0aW9ucy5lbnYsXG4gICAgICBjdXJyZW50c193czogZ2V0V1NTUG9ydCgpLFxuICAgIH0sXG4gICAgc3BlYyxcbiAgfTtcblxuICBkZWJ1ZyhcInJ1bm5pbmcgY3lwcmVzcyB3aXRoIG9wdGlvbnMgJW9cIiwgb3B0aW9ucyk7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBjeXByZXNzLnJ1bihvcHRpb25zKTtcblxuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IGN1cnJlbnRzQ29uZmlnID0gYXdhaXQgZ2V0Q3VycmVudHNDb25maWcoKTtcblxuICB3aGlsZSAoXG4gICAgY3VycmVudHNDb25maWcucmV0cnkgJiZcbiAgICByZXRyaWVzIDwgKGN1cnJlbnRzQ29uZmlnLnJldHJ5LmhhcmRGYWlsdXJlTWF4UmV0cmllcyA/PyAwKSAmJlxuICAgIHJlc3VsdC5zdGF0dXMgPT09IFwiZmFpbGVkXCJcbiAgKSB7XG4gICAgd2FybihcIkN5cHJlc3MgcnVubmVyIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICVzXCIsIHJlc3VsdC5tZXNzYWdlKTtcbiAgICB3YXJuKFxuICAgICAgXCJbcmV0cnkgJWQvJWRdIFJldHJ5aW5nIHRoZSBmb2xsb3dpbmcgc3BlYyBmaWxlcyBiZWNhdXNlIG9mIHJldHJ5IGNvbmZpZzogJXNcIixcbiAgICAgIHJldHJpZXMgKyAxLFxuICAgICAgY3VycmVudHNDb25maWcucmV0cnkuaGFyZEZhaWx1cmVNYXhSZXRyaWVzLFxuICAgICAgc3BlY1xuICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgIC5tYXAoKGkpID0+IGBcXG4gLSAke2l9YClcbiAgICAgICAgLmpvaW4oXCJcIilcbiAgICApO1xuICAgIHJlc3VsdCA9IGF3YWl0IGN5cHJlc3MucnVuKG9wdGlvbnMpO1xuICAgIHJldHJpZXMrKztcbiAgfVxuXG4gIGlmIChjdXJyZW50c0NvbmZpZy5yZXRyeSAmJiByZXRyaWVzID4gMCkge1xuICAgIHdhcm4oXG4gICAgICBcIkV4aGF1c3RlZCBtYXggcmV0cmllczogJWQvJWRcIixcbiAgICAgIHJldHJpZXMsXG4gICAgICBjdXJyZW50c0NvbmZpZy5yZXRyeS5oYXJkRmFpbHVyZU1heFJldHJpZXNcbiAgICApO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICB3YXJuKCdDeXByZXNzIHJ1bm5lciBmYWlsZWQgd2l0aCBtZXNzYWdlOiBcIiVzXCInLCByZXN1bHQubWVzc2FnZSk7XG4gICAgd2FybihcbiAgICAgIFwiVGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIHdpbGwgYmUgbWFya2VkIGFzIGZhaWxlZDogJXNcIixcbiAgICAgIHNwZWNcbiAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAubWFwKChpKSA9PiBgXFxuIC0gJHtpfWApXG4gICAgICAgIC5qb2luKFwiXCIpXG4gICAgKTtcbiAgfVxuXG4gIGRlYnVnKFwiY3lwcmVzcyBydW4gcmVzdWx0ICVvXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjb25zdCBydW5TcGVjRmlsZVNhZmUgPSAoXG4gIHNwZWM6IFJ1bkN5cHJlc3NTcGVjRmlsZSxcbiAgY3lwcmVzc1J1bk9wdGlvbnM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxDeXByZXNzUmVzdWx0PiA9PlxuICBzYWZlKFxuICAgIHJ1blNwZWNGaWxlLFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDeXByZXNzIHJ1bm5uZXIgY3Jhc2hlZCB3aXRoIGFuIGVycm9yOlxcbiR7XG4gICAgICAgIChlcnJvciBhcyBFcnJvcikubWVzc2FnZVxuICAgICAgfVxcbiR7KGVycm9yIGFzIEVycm9yKS5zdGFja319YDtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBydW4gZXhjZXB0aW9uICVvXCIsIGVycm9yKTtcbiAgICAgIHdhcm4oJ0N5cHJlc3MgcnVubmVyIGNyYXNoZWQ6IFwiJXNcIicsIG1lc3NhZ2UpO1xuICAgICAgd2FybihcbiAgICAgICAgXCJUaGUgZm9sbG93aW5nIHNwZWMgZmlsZXMgd2lsbCBiZSBtYXJrZWQgYXMgZmFpbGVkOiAlc1wiLFxuICAgICAgICBzcGVjLnNwZWNcbiAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgLm1hcCgoaSkgPT4gYFxcbiAtICR7aX1gKVxuICAgICAgICAgIC5qb2luKFwiXCIpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcImZhaWxlZFwiIGFzIGNvbnN0LFxuICAgICAgICBmYWlsdXJlczogMSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICAoKSA9PiB7fVxuICApKHNwZWMsIGN5cHJlc3NSdW5PcHRpb25zKTtcbiIsICJpbXBvcnQgYmx1ZWJpcmQgZnJvbSBcImJsdWViaXJkXCI7XG5cbmJsdWViaXJkLlByb21pc2UuY29uZmlnKHtcbiAgY2FuY2VsbGF0aW9uOiB0cnVlLFxufSk7XG5leHBvcnQgY29uc3QgQlByb21pc2UgPSBibHVlYmlyZC5Qcm9taXNlO1xuXG5leHBvcnQgY29uc3Qgc2FmZSA9XG4gIDxUIGV4dGVuZHMgYW55W10sIFIgZXh0ZW5kcyBhbnksIEYgZXh0ZW5kcyBhbnk+KFxuICAgIGZuOiAoLi4uYXJnczogVCkgPT4gUHJvbWlzZTxSPixcbiAgICBpZkZhbGVkOiAoZTogdW5rbm93bikgPT4gRixcbiAgICBpZlN1Y2NlZWQ6ICgpID0+IGFueVxuICApID0+XG4gIGFzeW5jICguLi5hcmdzOiBUKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICAgIGlmU3VjY2VlZCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGlmRmFsZWQoZSk7XG4gICAgfVxuICB9O1xuIiwgImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IG1hdGNoLCBQIH0gZnJvbSBcInRzLXBhdHRlcm5cIjtcbmltcG9ydCB7IEN1cnJlbnRzUnVuUGFyYW1ldGVycywgRGVidWdNb2RlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmVudW0gRGVidWdUb2tlbnMge1xuICBDdXJyZW50cyA9IFwiY3VycmVudHM6KlwiLFxuICBDeXByZXNzID0gXCJjeXByZXNzOipcIixcbiAgQ29tbWl0SW5mbyA9IFwiY29tbWl0LWluZm9cIixcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZURlYnVnKG1vZGU6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1tcImNsb3VkRGVidWdcIl0pIHtcbiAgbWF0Y2gobW9kZSlcbiAgICAud2l0aChQLmluc3RhbmNlT2YoQXJyYXkpLCAoaSkgPT4gaS5mb3JFYWNoKHNldERlYnVnTW9kZSkpXG4gICAgLndpdGgodHJ1ZSwgKCkgPT4gc2V0RGVidWdNb2RlKERlYnVnTW9kZS5BbGwpKVxuICAgIC53aXRoKFxuICAgICAgUC51bmlvbihcbiAgICAgICAgRGVidWdNb2RlLkFsbCxcbiAgICAgICAgRGVidWdNb2RlLkN1cnJlbnRzLFxuICAgICAgICBEZWJ1Z01vZGUuQ3lwcmVzcyxcbiAgICAgICAgRGVidWdNb2RlLkNvbW1pdEluZm9cbiAgICAgICksXG4gICAgICAoaSkgPT4gc2V0RGVidWdNb2RlKGkpXG4gICAgKVxuICAgIC5vdGhlcndpc2UoKCkgPT4gc2V0RGVidWdNb2RlKERlYnVnTW9kZS5Ob25lKSk7XG59XG5cbmZ1bmN0aW9uIHNldERlYnVnTW9kZShtb2RlOiBzdHJpbmcpIHtcbiAgaWYgKG1vZGUgPT09IERlYnVnTW9kZS5Ob25lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdG9rZW5zID0gbmV3IFNldChwcm9jZXNzLmVudi5ERUJVRyA/IHByb2Nlc3MuZW52LkRFQlVHLnNwbGl0KFwiLFwiKSA6IFtdKTtcbiAgbWF0Y2gobW9kZSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQWxsLCAoKSA9PiB7XG4gICAgICB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkNvbW1pdEluZm8pO1xuICAgICAgdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DdXJyZW50cyk7XG4gICAgICB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN5cHJlc3MpO1xuICAgIH0pXG4gICAgLndpdGgoRGVidWdNb2RlLkN1cnJlbnRzLCAoKSA9PiB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN1cnJlbnRzKSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQ3lwcmVzcywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5DeXByZXNzKSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQ29tbWl0SW5mbywgKCkgPT4gdG9rZW5zLmFkZChEZWJ1Z1Rva2Vucy5Db21taXRJbmZvKSlcbiAgICAub3RoZXJ3aXNlKCgpID0+IHt9KTtcblxuICBkZWJ1Zy5lbmFibGUoQXJyYXkuZnJvbSh0b2tlbnMpLmpvaW4oXCIsXCIpKTtcbn1cbiIsICJleHBvcnQgdHlwZSBJbnN0YW5jZUlkID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgVGVzdGluZ1R5cGUgPSBDeXByZXNzLlRlc3RpbmdUeXBlO1xuZXhwb3J0IHR5cGUgU3BlY1R5cGUgPSBcImNvbXBvbmVudFwiIHwgXCJpbnRlZ3JhdGlvblwiO1xuZXhwb3J0IHR5cGUgQXJyYXlJdGVtVHlwZTxUPiA9IFQgZXh0ZW5kcyAoaW5mZXIgVSlbXSA/IFUgOiBUO1xuZXhwb3J0IHR5cGUgTm9uRW1wdHlBcnJheTxUPiA9IFtULCAuLi5UW11dO1xuXG5leHBvcnQgdHlwZSBDeXByZXNzUnVuID0gQXJyYXlJdGVtVHlwZTxcbiAgQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRbXCJydW5zXCJdXG4+O1xuZXhwb3J0IHR5cGUgQ3lwcmVzc1Rlc3QgPSBBcnJheUl0ZW1UeXBlPEN5cHJlc3NSdW5bXCJ0ZXN0c1wiXT47XG5leHBvcnQgdHlwZSBDeXByZXNzVGVzdEF0dGVtcHQgPSBBcnJheUl0ZW1UeXBlPEN5cHJlc3NUZXN0W1wiYXR0ZW1wdHNcIl0+O1xuZXhwb3J0IHR5cGUgQ3lwcmVzc1NjcmVlbnNob3QgPSBBcnJheUl0ZW1UeXBlPFxuICBDeXByZXNzVGVzdEF0dGVtcHRbXCJzY3JlZW5zaG90c1wiXVxuPjtcblxuZXhwb3J0IHR5cGUgQ3lwcmVzc1Jlc3VsdCA9XG4gIHwgQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbiAgfCBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc0ZhaWxlZFJ1blJlc3VsdDtcblxuZXhwb3J0IHR5cGUgUGxhdGZvcm0gPSB7XG4gIG9zTmFtZTogc3RyaW5nO1xuICBvc1ZlcnNpb246IHN0cmluZztcbiAgYnJvd3Nlck5hbWU6IHN0cmluZztcbiAgYnJvd3NlclZlcnNpb246IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIERldGVjdGVkQnJvd3NlciA9IHtcbiAgbmFtZTogc3RyaW5nOyAvLyBvciBlbnVtPyBub3Qgc3VyZVxuICBmYW1pbHk6IHN0cmluZztcbiAgY2hhbm5lbDogc3RyaW5nO1xuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbiAgbWluU3VwcG9ydGVkVmVyc2lvbjogbnVtYmVyO1xuICBtYWpvclZlcnNpb246IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZFNwZWNzPFQ+IHtcbiAgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgdGVzdGluZ1R5cGU6IFRlc3RpbmdUeXBlO1xuICAvKipcbiAgICogVGhpcyBjYW4gYmUgb3Zlci1yaWRkZW4gYnkgdGhlIC0tc3BlYyBhcmd1bWVudCAocnVuIG1vZGUgb25seSlcbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwgYmUgdGhlIHNhbWUgYXMgYGNvbmZpZ1NwZWNQYXR0ZXJuYFxuICAgKi9cbiAgc3BlY1BhdHRlcm46IFQ7XG4gIC8qKlxuICAgKiBUaGUgc3BlY1BhdHRlcm4gcmVzb2x2ZWQgZnJvbSBlMmUuc3BlY1BhdHRlcm4gb3IgY29tcG9uZW50LnNwZWNQYXR0ZXJuXG4gICAqIGluc2lkZSBvZiBgY3lwcmVzcy5jb25maWdgLlxuICAgKi9cbiAgY29uZmlnU3BlY1BhdHRlcm46IFQ7XG4gIC8qKlxuICAgKiBVc2VyIGNhbiBvcHQgdG8gZXhjbHVkZSBjZXJ0YWluIHBhdHRlcm5zIGluIGN5cHJlc3MuY29uZmlnLlxuICAgKi9cbiAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBUO1xuICAvKipcbiAgICogSWYgaW4gY29tcG9uZW50IHRlc3RpbmcgbW9kZSwgd2UgZXhjbHVkZSBhbGwgc3BlY3MgbWF0Y2hpbmcgdGhlIGUyZS5zcGVjUGF0dGVybi5cbiAgICovXG4gIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VTcGVjIHtcbiAgbmFtZTogc3RyaW5nO1xuICByZWxhdGl2ZTogc3RyaW5nO1xuICBhYnNvbHV0ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwZWNGaWxlIGV4dGVuZHMgQmFzZVNwZWMge1xuICBiYXNlTmFtZTogc3RyaW5nO1xuICBmaWxlTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvdW5kU3BlYyBleHRlbmRzIFNwZWNGaWxlIHtcbiAgc3BlY0ZpbGVFeHRlbnNpb246IHN0cmluZztcbiAgZmlsZUV4dGVuc2lvbjogc3RyaW5nO1xuICBzcGVjVHlwZTogU3BlY1R5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BlY1dpdGhSZWxhdGl2ZVJvb3QgZXh0ZW5kcyBGb3VuZFNwZWMge1xuICByZWxhdGl2ZVRvQ29tbW9uUm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbiB7XG4gIHNjcmVlbnNob3RJZDogc3RyaW5nO1xuICB1cGxvYWRVcmw6IHN0cmluZztcbiAgcmVhZFVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTY3JlZW5zaG90QXJ0aWZhY3QgPSBDeXByZXNzQ29tbWFuZExpbmUuU2NyZWVuc2hvdEluZm9ybWF0aW9uICYge1xuICB0ZXN0SWQ6IHN0cmluZztcbiAgdGVzdEF0dGVtcHRJbmRleDogbnVtYmVyO1xuICBzY3JlZW5zaG90SWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCBlbnVtIERlYnVnTW9kZSB7XG4gIE5vbmUgPSBcIm5vbmVcIixcbiAgQWxsID0gXCJhbGxcIixcbiAgQ3VycmVudHMgPSBcImN1cnJlbnRzXCIsXG4gIEN5cHJlc3MgPSBcImN5cHJlc3NcIixcbiAgQ29tbWl0SW5mbyA9IFwiY29tbWl0LWluZm9cIixcbn1cblxuLy8gRXhwbGljaXRseSBmaWx0ZXIgY3lwcmVzcyByZWNvcmQtcmVsYXRlZCBmbGFncyAtIHByZXZlbnQgdHJpZ2dlcmluZyByZWNvcmRpbmcgbW9kZSB0byBhdm9pZCBjb25mdXNpb25cbmV4cG9ydCB0eXBlIFN0cmlwcGVkQ3lwcmVzc01vZHVsZUFQSU9wdGlvbnMgPSBPbWl0PFxuICBQYXJ0aWFsPEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuT3B0aW9ucz4sXG4gIHwgXCJhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlc1wiXG4gIHwgXCJ0YWdcIlxuICB8IFwic3BlY1wiXG4gIHwgXCJleGl0XCJcbiAgfCBcImhlYWRlZFwiXG4gIHwgXCJyZWNvcmRcIlxuICB8IFwiaGVhZGxlc3NcIlxuICB8IFwibm9FeGl0XCJcbiAgfCBcInBhcmFsbGVsXCJcbiAgfCBcImtleVwiXG4gIHwgXCJ0YWdcIlxuICB8IFwiZ3JvdXBcIlxuICB8IFwiY2lCdWlsZElkXCJcbiAgfCBcImNsb3VkQ29uZmlnRmlsZVwiXG4+O1xuXG4vLyBVc2VkIHRvIHJ1biBDeXByZXNzIHZpYSBtb2R1bGUgQVBJIGFuZCB2aWEgQ0xJXG5leHBvcnQgdHlwZSBDeXByZXNzUnVuUGFyYW1ldGVycyA9IFN0cmlwcGVkQ3lwcmVzc01vZHVsZUFQSU9wdGlvbnMgJiB7XG4gIHJlY29yZDogZmFsc2U7XG59O1xuXG5leHBvcnQgdHlwZSBDdXJyZW50c1J1blBhcmFtZXRlcnMgPSBTdHJpcHBlZEN5cHJlc3NNb2R1bGVBUElPcHRpb25zICYge1xuICAvKiogVGhlIENJIGJ1aWxkIElEIHRvIHVzZSBmb3IgdGhlIHJ1biAqL1xuICBjaUJ1aWxkSWQ/OiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBiYXRjaCBzaXplIGRlZmluZXMgaG93IG1hbnkgc3BlYyBmaWxlcyB3aWxsIGJlIHNlcnZlZCBpbiBvbmUgb3JjaGVzdHJhdGlvbiBcImJhdGNoXCIuIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgdXNlIHRoZSBwcm9qZWN0SWQgZnJvbSBjdXJyZW50cy5jb25maWcuanMsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIDEgKGkuZS4gbm8gYmF0Y2hpbmcpICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcblxuICAvKiogV2hldGhlciB0byBhY3RpdmF0ZSByZWNvcmQgbW9kZSBhbmQgY29ubmVjdCB0byBjbG91ZCBvcmNoZXN0cmF0aW9uIHNlcnZpY2UgKi9cbiAgcmVjb3JkPzogYm9vbGVhbjtcblxuICAvKiogVGhlIFVSTCBvZiB0aGUgY3VycmVudHMgc2VydmVyIHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgd2lsbCB1c2UgdGhlIG9uZSBmcm9tIGN1cnJlbnRzLmNvbmZpZy5qcyAqL1xuICBjbG91ZFNlcnZpY2VVcmw/OiBzdHJpbmc7XG4gIC8qKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIHVzZSBmb3IgdGhlIHJ1biAqL1xuICBlbnY/OiBvYmplY3Q7XG5cbiAgLyoqIFRoZSBncm91cCBpZCB0byB1c2UgZm9yIHRoZSBydW4gKi9cbiAgZ3JvdXA/OiBzdHJpbmc7XG5cbiAgLyoqICBUaGUgcmVjb3JkIGtleSB0byB1c2UgKi9cbiAgcmVjb3JkS2V5Pzogc3RyaW5nO1xuXG4gIC8qKiBXaGV0aGVyIHRvIHJ1biB0aGUgc3BlYyBmaWxlcyBpbiBwYXJhbGxlbCAqL1xuICBwYXJhbGxlbD86IGJvb2xlYW47XG5cbiAgLyoqIFRoZSBwcm9qZWN0IElEIHRvIHVzZS4gKi9cbiAgcHJvamVjdElkPzogc3RyaW5nO1xuXG4gIC8qKiBDb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHNwZWMgZ2xvYiBwYXR0ZXJuIGZvciB0aGUgZXhlY3V0aW9uICovXG4gIHNwZWM/OiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICAvKiogQ29tbWEtc2VwYXJhdGVkIHN0cmluZyBvciBhbiBhcnJheSBvZiB0YWdzICovXG4gIHRhZz86IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIC8qKiBcImUyZVwiIG9yIFwiY29tcG9uZW50XCIsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiZTJlXCIgKi9cbiAgdGVzdGluZ1R5cGU/OiBUZXN0aW5nVHlwZTtcblxuICAvKiogQXV0b21hdGljYWxseSBhYm9ydCB0aGUgcnVuIGFmdGVyIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGZhaWxlZCB0ZXN0cy4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHByb2plY3Qgc2V0dGluZ3MuIElmIHNldCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgXCJmYWxzZVwiIHRvIGRpc2FibGUgKEN1cnJlbnRzLW9ubHkpICovXG4gIGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzPzogbnVtYmVyIHwgZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gbGF1bmNoIGN5cHJlc3MgaW4gaGVhZGVkIG1vZGUuIElmIHNldCwgbXVzdCBiZSBhIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgaGVhZGVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmaWxlIG5hbWUgb3IgYWJzb2x1dGUgcGF0aC4gRGVmYXVsdCB2YWx1ZSBpcyAnY3VycmVudHMuY29uZmlnLmpzJywgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgZmlsZSB3aWxsIGJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZSBwcm9qZWN0IHJvb3QsIHVubGVzcyBpdCdzIGFuIGFic29sdXRlIHBhdGguXG4gICAqL1xuICBjbG91ZENvbmZpZ0ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBkZWJ1ZyBtb2RlIGZvciBjeXByZXNzLWNsb3VkLCB0aGlzIHdpbGwgcHJpbnQgb3V0IGxvZ3MgZm9yIHRyb3VibGVzaG9vdGluZy5cbiAgICovXG4gIGNsb3VkRGVidWc/OiBEZWJ1Z01vZGUgfCB0cnVlIHwgc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIGNvdmVyYWdlIHJlc3VsdHMuIElmIHNldCwgbXVzdCBiZSBhIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsQ292ZXJhZ2VSZWNvcmRpbmc/OiBib29sZWFuO1xufTtcblxuLy8gVXNlci1mYWNpbmcgYHJ1bmAgaW50ZXJmYWNlXG4vLyBXZSBjYW4gcmVzb2x2ZSB0aGUgcHJvamVjdElkIGFuZCByZWNvcmRLZXkgZnJvbSBkaWZmZXJlbnQgc291cmNlcywgc28gd2UgY2FuJ3QgcmVhbGx5IGVuZm9yY2UgdGhlbSB2aWEgdGhlIHR5cGUgZGVmaW5pdGlvblxuZXhwb3J0IGludGVyZmFjZSBDdXJyZW50c1J1bkFQSSBleHRlbmRzIEN1cnJlbnRzUnVuUGFyYW1ldGVycyB7fVxuXG4vLyBQYXJhbXMgYWZ0ZXIgdmFsaWRhdGlvbiBhbmQgcmVzb2x1dGlvblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMgZXh0ZW5kcyBDdXJyZW50c1J1blBhcmFtZXRlcnMge1xuICByZWFkb25seSBwcm9qZWN0SWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgY2xvdWRTZXJ2aWNlVXJsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGJhdGNoU2l6ZTogbnVtYmVyO1xuICByZWFkb25seSB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIHJlYWRvbmx5IHJlY29yZEtleTogc3RyaW5nO1xuICByZWFkb25seSB0YWc6IHN0cmluZ1tdO1xuICByZWFkb25seSBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlczogbnVtYmVyIHwgZmFsc2UgfCB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHsgZ2V0QVBJQmFzZVVybCB9IGZyb20gXCIuL2h0dHBDbGllbnQvY29uZmlnXCI7XG5cbmV4cG9ydCBjb25zdCBpc0N1cnJlbnRzID0gKCkgPT5cbiAgISFwcm9jZXNzLmVudi5DVVJSRU5UU19FTkZPUkNFX0lTX0NVUlJFTlRTIHx8XG4gIGdldEFQSUJhc2VVcmwoKSA9PT0gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IGNvbW1pdEluZm8gfSBmcm9tIFwiQGN1cnJlbnRzL2NvbW1pdC1pbmZvXCI7XG5pbXBvcnQgeyBnZXRDb21taXREZWZhdWx0cyB9IGZyb20gXCIuL2NpUHJvdmlkZXJcIjtcblxuZXhwb3J0IHR5cGUgR2hhRXZlbnREYXRhID0ge1xuICBoZWFkUmVmOiBzdHJpbmc7XG4gIGhlYWRTaGE6IHN0cmluZztcbiAgYmFzZVJlZjogc3RyaW5nO1xuICBiYXNlU2hhOiBzdHJpbmc7XG4gIGlzc3VlVXJsOiBzdHJpbmc7XG4gIGh0bWxVcmw6IHN0cmluZztcbiAgcHJUaXRsZTogc3RyaW5nO1xuICBzZW5kZXJBdmF0YXJVcmw6IHN0cmluZztcbiAgc2VuZGVySHRtbFVybDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEdpdEluZm8gPSBhc3luYyAocHJvamVjdFJvb3Q6IHN0cmluZykgPT4ge1xuICBjb25zdCBjb21taXQgPSBhd2FpdCBjb21taXRJbmZvKHByb2plY3RSb290KTtcbiAgcmV0dXJuIGdldENvbW1pdERlZmF1bHRzKHtcbiAgICBicmFuY2g6IGNvbW1pdC5icmFuY2gsXG4gICAgcmVtb3RlT3JpZ2luOiBjb21taXQucmVtb3RlLFxuICAgIGF1dGhvckVtYWlsOiBjb21taXQuZW1haWwsXG4gICAgYXV0aG9yTmFtZTogY29tbWl0LmF1dGhvcixcbiAgICBtZXNzYWdlOiBjb21taXQubWVzc2FnZSxcbiAgICBzaGE6IGNvbW1pdC5zaGEsXG4gICAgZ2hhRXZlbnREYXRhOiBjb21taXQuZ2hhRXZlbnREYXRhLFxuICB9KTtcbn07XG4iLCAiaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgZ3Vlc3NCcm93c2VyIH0gZnJvbSBcIi4vYnJvd3NlclwiO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm1JbmZvIH0gZnJvbSBcIi4vcGxhdGZvcm1cIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXRmb3JtKHtcbiAgYnJvd3NlcixcbiAgY29uZmlnLFxufToge1xuICBicm93c2VyPzogc3RyaW5nO1xuICBjb25maWc6IE1lcmdlZENvbmZpZztcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi4oYXdhaXQgZ2V0UGxhdGZvcm1JbmZvKCkpLFxuICAgIC4uLmd1ZXNzQnJvd3Nlcihicm93c2VyID8/IFwiZWxlY3Ryb25cIiwgY29uZmlnLnJlc29sdmVkPy5icm93c2VycyksXG4gIH07XG59XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRGV0ZWN0ZWRCcm93c2VyLCBQbGF0Zm9ybSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmJyb3dzZXJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBndWVzc0Jyb3dzZXIoXG4gIGJyb3dzZXI6IHN0cmluZyxcbiAgYXZhaWxhYmxlQnJvd3NlcnM6IERldGVjdGVkQnJvd3NlcltdID0gW11cbik6IFBpY2s8UGxhdGZvcm0sIFwiYnJvd3Nlck5hbWVcIiB8IFwiYnJvd3NlclZlcnNpb25cIj4ge1xuICBkZWJ1ZyhcbiAgICBcImd1ZXNzaW5nIGJyb3dzZXIgZnJvbSAnJXMnLCBhdmFpbGFibGUgYnJvd3NlcnM6ICVvXCIsXG4gICAgYnJvd3NlcixcbiAgICBhdmFpbGFibGVCcm93c2Vyc1xuICApO1xuICAvLyB0cnkgaWRlbnRpZnlpbmcgdGhlIGJyb3dzZXIgYnkgbmFtZSBmaXJzdFxuICBsZXQgcmVzdWx0ID0gYXZhaWxhYmxlQnJvd3NlcnMuZmluZCgoYikgPT4gYi5uYW1lID09PSBicm93c2VyKTtcblxuICBpZiAocmVzdWx0KSB7XG4gICAgZGVidWcoXCJpZGVudGlmaWVkIGJyb3dzZXIgYnkgbmFtZTogJW9cIiwgcmVzdWx0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3Nlck5hbWU6IHJlc3VsdC5kaXNwbGF5TmFtZSxcbiAgICAgIGJyb3dzZXJWZXJzaW9uOiByZXN1bHQudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCB0cnkgaWRlbnRpZnlpbmcgYnkgdGhlIHBhdGhcbiAgcmVzdWx0ID0gYXZhaWxhYmxlQnJvd3NlcnMuZmluZCgoYikgPT4gYi5wYXRoID09PSBicm93c2VyKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGRlYnVnKFwiaWRlbnRpZmllZCBicm93c2VyIGJ5IHBhdGg6ICVvXCIsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUgPz8gcmVzdWx0Lm5hbWUsXG4gICAgICBicm93c2VyVmVyc2lvbjogcmVzdWx0LnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIHdhcm4oXCJVbmFibGUgdG8gaWRlbnRpZnkgYnJvd3NlciBuYW1lIGFuZCB2ZXJzaW9uXCIpO1xuXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIGR1bW15IGJyb3dzZXJcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyTmFtZTogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclZlcnNpb246IFwidW5rbm93blwiLFxuICB9O1xufVxuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBnZXRvcyBmcm9tIFwiZ2V0b3NcIjtcbmltcG9ydCB7IGNwdXMsIGZyZWVtZW0sIHBsYXRmb3JtLCByZWxlYXNlLCB0b3RhbG1lbSB9IGZyb20gXCJvc1wiO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSBcInV0aWxcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnBsYXRmb3JtXCIpO1xuXG5jb25zdCBnZXRPc1ZlcnNpb24gPSBhc3luYyAoKSA9PiB7XG4gIGlmIChwbGF0Zm9ybSgpID09PSBcImxpbnV4XCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGludXhPcyA9IGF3YWl0IHByb21pc2lmeShnZXRvcykoKTtcbiAgICAgIGlmIChcImRpc3RcIiBpbiBsaW51eE9zICYmIFwicmVsZWFzZVwiIGluIGxpbnV4T3MpIHtcbiAgICAgICAgcmV0dXJuIFtsaW51eE9zLmRpc3QsIGxpbnV4T3MucmVsZWFzZV0uam9pbihcIiAtIFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVsZWFzZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFBsYXRmb3JtSW5mbyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3Qgb3NWZXJzaW9uID0gYXdhaXQgZ2V0T3NWZXJzaW9uKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBvc05hbWU6IHBsYXRmb3JtKCksXG4gICAgb3NWZXJzaW9uLFxuICAgIG9zQ3B1czogY3B1cygpLFxuICAgIG9zTWVtb3J5OiB7XG4gICAgICBmcmVlOiBmcmVlbWVtKCksXG4gICAgICB0b3RhbDogdG90YWxtZW0oKSxcbiAgICB9LFxuICB9O1xuICBkZWJ1ZyhcInBsYXRmb3JtIGluZm86ICVvXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL3Jlc3VsdHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RhYmxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91cGxvYWRSZXN1bHRzXCI7XG4iLCAiaW1wb3J0IHsgQ3lwcmVzc1Jlc3VsdCwgU2NyZWVuc2hvdEFydGlmYWN0IH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7XG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBUZXN0U3RhdGUsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQsXG59IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IE1lcmdlZENvbmZpZyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXN1bHRzXCIpO1xuXG5leHBvcnQgY29uc3QgaXNTdWNjZXNzUmVzdWx0ID0gKFxuICByZXN1bHQ6IEN5cHJlc3NSZXN1bHRcbik6IHJlc3VsdCBpcyBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCA9PiB7XG4gIHJldHVybiByZXN1bHQuc3RhdHVzID09PSBcImZpbmlzaGVkXCI7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2NyZWVuc2hvdHNTdW1tYXJ5ID0gKFxuICB0ZXN0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlRlc3RSZXN1bHRbXSA9IFtdXG4pOiBTY3JlZW5zaG90QXJ0aWZhY3RbXSA9PiB7XG4gIHJldHVybiB0ZXN0cy5mbGF0TWFwKCh0ZXN0LCBpKSA9PlxuICAgIHRlc3QuYXR0ZW1wdHMuZmxhdE1hcCgoYSwgYWkpID0+XG4gICAgICBhLnNjcmVlbnNob3RzLmZsYXRNYXAoKHMpID0+ICh7XG4gICAgICAgIC4uLnMsXG4gICAgICAgIHRlc3RJZDogYHIke2l9YCxcbiAgICAgICAgdGVzdEF0dGVtcHRJbmRleDogYWksXG4gICAgICAgIHNjcmVlbnNob3RJZDogbmFub2lkKCksXG4gICAgICB9KSlcbiAgICApXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3RhdHMgPSAoc3RhdHM6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHRbXCJzdGF0c1wiXSkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRzLFxuICAgIHdhbGxDbG9ja0R1cmF0aW9uOiBzdGF0cy5kdXJhdGlvbixcbiAgICB3YWxsQ2xvY2tTdGFydGVkQXQ6IHN0YXRzLnN0YXJ0ZWRBdCxcbiAgICB3YWxsQ2xvY2tFbmRlZEF0OiBzdGF0cy5lbmRlZEF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRlc3RBdHRlbXB0ID0gKGF0dGVtcHQ6IEN5cHJlc3NDb21tYW5kTGluZS5BdHRlbXB0UmVzdWx0KSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0ZW1wdCxcbiAgICBzdGF0ZTogYXR0ZW1wdC5zdGF0ZSBhcyBUZXN0U3RhdGUsXG4gICAgd2FsbENsb2NrRHVyYXRpb246IGF0dGVtcHQuZHVyYXRpb24sXG4gICAgd2FsbENsb2NrU3RhcnRlZEF0OiBhdHRlbXB0LnN0YXJ0ZWRBdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZ1xuKTogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCA9PiB7XG4gIHJldHVybiB7XG4gICAgc3RhdHM6IGdldFN0YXRzKHJ1blJlc3VsdC5zdGF0cyksXG4gICAgcmVwb3J0ZXJTdGF0czogcnVuUmVzdWx0LnJlcG9ydGVyU3RhdHMsXG4gICAgZXhjZXB0aW9uOiBydW5SZXN1bHQuZXJyb3IgPz8gbnVsbCxcbiAgICB2aWRlbzogISFydW5SZXN1bHQudmlkZW8sIC8vIERpZCB0aGUgaW5zdGFuY2UgZ2VuZXJhdGUgYSB2aWRlbz9cbiAgICBzY3JlZW5zaG90czogZ2V0U2NyZWVuc2hvdHNTdW1tYXJ5KHJ1blJlc3VsdC50ZXN0cyA/PyBbXSksXG4gICAgaGFzQ292ZXJhZ2U6ICEhY292ZXJhZ2VGaWxlUGF0aCxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICBkaXNwbGF5RXJyb3I6IHRlc3QuZGlzcGxheUVycm9yLFxuICAgICAgICBzdGF0ZTogdGVzdC5zdGF0ZSBhcyBUZXN0U3RhdGUsXG4gICAgICAgIGhvb2tzOiBydW5SZXN1bHQuaG9va3MsXG4gICAgICAgIGF0dGVtcHRzOiB0ZXN0LmF0dGVtcHRzPy5tYXAoZ2V0VGVzdEF0dGVtcHQpID8/IFtdLFxuICAgICAgICBjbGllbnRJZDogYHIke2l9YCxcbiAgICAgIH0pKSA/PyBbXSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24oXG4gIGVycm9yOiBzdHJpbmcsXG4gIHN0YXRzOiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0W1wic3RhdHNcIl1cbikge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICAgIGJvZHk6IFwiXCIsXG4gICAgZGlzcGxheUVycm9yOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICBob29rczogW10sXG4gICAgYXR0ZW1wdHM6IFtcbiAgICAgIGdldFRlc3RBdHRlbXB0KHtcbiAgICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5zcGxpdChcIlxcblwiKVswXSxcbiAgICAgICAgICBzdGFjazogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGF0cy5zdGFydGVkQXQsXG4gICAgICAgIHZpZGVvVGltZXN0YW1wOiAwLFxuICAgICAgfSksXG4gICAgXSxcbiAgICBjbGllbnRJZDogXCJyMFwiLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPSAoXG4gIHJ1blJlc3VsdDogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdCxcbiAgY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9uc1xuKTogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICB0ZXN0czpcbiAgICAgIHJ1blJlc3VsdC50ZXN0cz8ubWFwKCh0ZXN0LCBpKSA9PiAoe1xuICAgICAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgICBib2R5OiB0ZXN0LmJvZHksXG4gICAgICAgIGNsaWVudElkOiBgciR7aX1gLFxuICAgICAgICBob29rSWRzOiBbXSxcbiAgICAgIH0pKSA/PyBbXSxcbiAgICBob29rczogcnVuUmVzdWx0Lmhvb2tzLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcml6ZVRlc3RSZXN1bHRzID0gKFxuICBpbnB1dDogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRbXSxcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgaWYgKCFpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhjb25maWcpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcmFsbCA9IGlucHV0LnJlZHVjZShcbiAgICAoXG4gICAgICBhY2MsXG4gICAgICB7XG4gICAgICAgIHRvdGFsRHVyYXRpb24sXG4gICAgICAgIHRvdGFsRmFpbGVkLFxuICAgICAgICB0b3RhbFBhc3NlZCxcbiAgICAgICAgdG90YWxQZW5kaW5nLFxuICAgICAgICB0b3RhbFNraXBwZWQsXG4gICAgICAgIHRvdGFsVGVzdHMsXG4gICAgICAgIHRvdGFsU3VpdGVzLFxuICAgICAgfVxuICAgICkgPT4gKHtcbiAgICAgIHRvdGFsRHVyYXRpb246IGFjYy50b3RhbER1cmF0aW9uICsgdG90YWxEdXJhdGlvbixcbiAgICAgIHRvdGFsU3VpdGVzOiBhY2MudG90YWxTdWl0ZXMgKyB0b3RhbFN1aXRlcyxcbiAgICAgIHRvdGFsUGVuZGluZzogYWNjLnRvdGFsUGVuZGluZyArIHRvdGFsUGVuZGluZyxcbiAgICAgIHRvdGFsRmFpbGVkOiBhY2MudG90YWxGYWlsZWQgKyB0b3RhbEZhaWxlZCxcbiAgICAgIHRvdGFsU2tpcHBlZDogYWNjLnRvdGFsU2tpcHBlZCArIHRvdGFsU2tpcHBlZCxcbiAgICAgIHRvdGFsUGFzc2VkOiBhY2MudG90YWxQYXNzZWQgKyB0b3RhbFBhc3NlZCxcbiAgICAgIHRvdGFsVGVzdHM6IGFjYy50b3RhbFRlc3RzICsgdG90YWxUZXN0cyxcbiAgICB9KSxcbiAgICBlbXB0eVN0YXRzXG4gICk7XG4gIGNvbnN0IGZpcnN0UmVzdWx0ID0gaW5wdXRbMF07XG4gIGNvbnN0IHN0YXJ0SXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuc3RhcnRlZFRlc3RzQXQpLnNvcnQoKTtcbiAgY29uc3QgZW5kSXRlbXMgPSBpbnB1dC5tYXAoKGkpID0+IGkuZW5kZWRUZXN0c0F0KS5zb3J0KCk7XG4gIGNvbnN0IHJ1bnMgPSBpbnB1dC5tYXAoKGkpID0+IGkucnVucykuZmxhdCgpO1xuICByZXR1cm4ge1xuICAgIC4uLm92ZXJhbGwsXG4gICAgcnVucyxcbiAgICBzdGFydGVkVGVzdHNBdDogXy5maXJzdChzdGFydEl0ZW1zKSBhcyBzdHJpbmcsXG4gICAgZW5kZWRUZXN0c0F0OiBfLmxhc3QoZW5kSXRlbXMpIGFzIHN0cmluZyxcbiAgICAuLi5fLnBpY2soXG4gICAgICBmaXJzdFJlc3VsdCxcbiAgICAgIFwiYnJvd3Nlck5hbWVcIixcbiAgICAgIFwiYnJvd3NlclZlcnNpb25cIixcbiAgICAgIFwiYnJvd3NlclBhdGhcIixcbiAgICAgIFwib3NOYW1lXCIsXG4gICAgICBcIm9zVmVyc2lvblwiLFxuICAgICAgXCJjeXByZXNzVmVyc2lvblwiLFxuICAgICAgXCJjb25maWdcIlxuICAgICksXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlDeXByZXNzUmVzdWx0cyhcbiAgY29uZmlnOiBNZXJnZWRDb25maWdcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5lbXB0eVN0YXRzLFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgcnVuczogW10sXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbmZpZyxcbiAgfTtcbn1cbmNvbnN0IGVtcHR5U3RhdHMgPSB7XG4gIHRvdGFsRHVyYXRpb246IDAsXG4gIHRvdGFsU3VpdGVzOiAwLFxuICB0b3RhbFBlbmRpbmc6IDAsXG4gIHRvdGFsRmFpbGVkOiAwLFxuICB0b3RhbFNraXBwZWQ6IDAsXG4gIHRvdGFsUGFzc2VkOiAwLFxuICB0b3RhbFRlc3RzOiAwLFxufTtcblxuY29uc3QgZ2V0RHVtbXlGYWlsZWRUZXN0ID0gKHN0YXJ0OiBzdHJpbmcsIGVycm9yOiBzdHJpbmcpID0+ICh7XG4gIHRpdGxlOiBbXCJVbmtub3duXCJdLFxuICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgYm9keTogXCIvLyBUaGlzIHRlc3QgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZHVlIHRvIGV4ZWN1dGlvbiBmYWlsdXJlXCIsXG4gIGRpc3BsYXlFcnJvcjogZXJyb3IsXG4gIGF0dGVtcHRzOiBbXG4gICAge1xuICAgICAgc3RhdGU6IFwiZmFpbGVkXCIsXG4gICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICB2aWRlb1RpbWVzdGFtcDogMCxcbiAgICAgIHNjcmVlbnNob3RzOiBbXSxcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIG5hbWU6IFwiQ3lwcmVzc0V4ZWN1dGlvbkVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICBzdGFjazogXCJcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFpbGVkRHVtbXlSZXN1bHQoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHNwZWNzLFxuICAgIGVycm9yLFxuICB9OiB7XG4gICAgc3BlY3M6IHN0cmluZ1tdO1xuICAgIGVycm9yOiBzdHJpbmc7XG4gIH1cbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnOiBjb25maWdTdGF0ZS5nZXRDb25maWcoKSA/PyB7fSxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICBzdGFydGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGVuZGVkVGVzdHNBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHRvdGFsRHVyYXRpb246IDAsXG4gICAgdG90YWxTdWl0ZXM6IDEsXG4gICAgdG90YWxGYWlsZWQ6IDEsXG4gICAgdG90YWxQYXNzZWQ6IDAsXG4gICAgdG90YWxQZW5kaW5nOiAwLFxuICAgIHRvdGFsU2tpcHBlZDogMCxcbiAgICB0b3RhbFRlc3RzOiAxLFxuICAgIGJyb3dzZXJOYW1lOiBcInVua25vd25cIixcbiAgICBicm93c2VyVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgYnJvd3NlclBhdGg6IFwidW5rbm93blwiLFxuICAgIG9zTmFtZTogXCJ1bmtub3duXCIsXG4gICAgb3NWZXJzaW9uOiBcInVua25vd25cIixcbiAgICBjeXByZXNzVmVyc2lvbjogXCJ1bmtub3duXCIsXG4gICAgcnVuczogc3BlY3MubWFwKChzKSA9PiAoe1xuICAgICAgc3RhdHM6IHtcbiAgICAgICAgc3VpdGVzOiAxLFxuICAgICAgICB0ZXN0czogMSxcbiAgICAgICAgcGFzc2VzOiAwLFxuICAgICAgICBwZW5kaW5nOiAwLFxuICAgICAgICBza2lwcGVkOiAwLFxuICAgICAgICBmYWlsdXJlczogMSxcbiAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcbiAgICAgICAgZW5kZWRBdDogZW5kLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgIH0sXG4gICAgICByZXBvcnRlcjogXCJzcGVjXCIsXG4gICAgICByZXBvcnRlclN0YXRzOiB7fSxcbiAgICAgIGhvb2tzOiBbXSxcbiAgICAgIGVycm9yLFxuICAgICAgdmlkZW86IG51bGwsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIG5hbWU6IHMsXG4gICAgICAgIHJlbGF0aXZlOiBzLFxuICAgICAgICBhYnNvbHV0ZTogcyxcbiAgICAgICAgcmVsYXRpdmVUb0NvbW1vblJvb3Q6IHMsXG4gICAgICB9LFxuICAgICAgdGVzdHM6IFtnZXREdW1teUZhaWxlZFRlc3Qoc3RhcnQsIGVycm9yKV0sXG4gICAgICBzaG91bGRVcGxvYWRWaWRlbzogZmFsc2UsXG4gICAgICBza2lwcGVkU3BlYzogZmFsc2UsXG4gICAgfSkpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMoXG4gIHNwZWM6IHN0cmluZyxcbiAgY3lwcmVzc1Jlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgfCB1bmRlZmluZWQge1xuICBpZiAoIWlzU3VjY2Vzc1Jlc3VsdChjeXByZXNzUmVzdWx0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJ1biA9IGN5cHJlc3NSZXN1bHQucnVucy5maW5kKChyKSA9PiByLnNwZWMucmVsYXRpdmUgPT09IHNwZWMpO1xuICBpZiAoIXJ1bikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0cyA9IGdldFN0YXRzKHJ1bi5zdGF0cyk7XG4gIC8vIGFkanVzdCB0aGUgcmVzdWx0IGZvciBzaW5nZSBzcGVjXG4gIHJldHVybiB7XG4gICAgLi4uY3lwcmVzc1Jlc3VsdCxcbiAgICBydW5zOiBbcnVuXSxcbiAgICB0b3RhbFN1aXRlczogMSxcbiAgICB0b3RhbER1cmF0aW9uOiBzdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICB0b3RhbFRlc3RzOiBzdGF0cy50ZXN0cyxcbiAgICB0b3RhbEZhaWxlZDogc3RhdHMuZmFpbHVyZXMsXG4gICAgdG90YWxQYXNzZWQ6IHN0YXRzLnBhc3NlcyxcbiAgICB0b3RhbFBlbmRpbmc6IHN0YXRzLnBlbmRpbmcsXG4gICAgdG90YWxTa2lwcGVkOiBzdGF0cy5za2lwcGVkLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZW5kZWRUZXN0c0F0OiBzdGF0cy53YWxsQ2xvY2tFbmRlZEF0LFxuICB9O1xufVxuIiwgImltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBwcmV0dHlNUyBmcm9tIFwicHJldHR5LW1zXCI7XG5pbXBvcnQgeyB0YWJsZSB9IGZyb20gXCJ0YWJsZVwiO1xuaW1wb3J0IHsgY3lhbiwgZ3JheSwgZ3JlZW4sIHJlZCwgd2hpdGUgfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGZhaWx1cmVJY29uID0gcmVkKFwiXHUyNzE2XCIpO1xuY29uc3Qgc3VjY2Vzc0ljb24gPSBncmVlbihcIlx1MjcxNFwiKTtcblxuZXhwb3J0IGNvbnN0IHN1bW1hcnlUYWJsZSA9IChyOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCkgPT4ge1xuICBjb25zdCBvdmVyYWxsU3BlY0NvdW50ID0gci5ydW5zLmxlbmd0aDtcbiAgY29uc3QgZmFpbGVkU3BlY3NDb3VudCA9IF8uc3VtKFxuICAgIHIucnVucy5maWx0ZXIoKHYpID0+IHYuc3RhdHMuZmFpbHVyZXMgKyB2LnN0YXRzLnNraXBwZWQgPiAwKS5tYXAoKCkgPT4gMSlcbiAgKTtcbiAgY29uc3QgaGFzRmFpbGVkID0gZmFpbGVkU3BlY3NDb3VudCA+IDA7XG5cbiAgY29uc3QgdmVyZGljdCA9IGhhc0ZhaWxlZFxuICAgID8gcmVkKGAke2ZhaWxlZFNwZWNzQ291bnR9IG9mICR7b3ZlcmFsbFNwZWNDb3VudH0gZmFpbGVkYClcbiAgICA6IG92ZXJhbGxTcGVjQ291bnQgPiAwXG4gICAgPyBcIkFsbCBzcGVjcyBwYXNzZWQhXCJcbiAgICA6IFwiTm8gc3BlY3MgZXhlY3V0ZWRcIjtcblxuICBjb25zdCBkYXRhID0gci5ydW5zLm1hcCgocikgPT4gW1xuICAgIHIuc3RhdHMuZmFpbHVyZXMgKyByLnN0YXRzLnNraXBwZWQgPiAwID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbixcbiAgICByLnNwZWMucmVsYXRpdmVUb0NvbW1vblJvb3QsXG4gICAgZ3JheShwcmV0dHlNUyhyLnN0YXRzLmR1cmF0aW9uKSksXG4gICAgd2hpdGUoci5zdGF0cy50ZXN0cyA/PyAwKSxcbiAgICByLnN0YXRzLnBhc3NlcyA/IGdyZWVuKHIuc3RhdHMucGFzc2VzKSA6IGdyYXkoXCItXCIpLFxuICAgIHIuc3RhdHMuZmFpbHVyZXMgPyByZWQoci5zdGF0cy5mYWlsdXJlcykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnBlbmRpbmcgPyBjeWFuKHIuc3RhdHMucGVuZGluZykgOiBncmF5KFwiLVwiKSxcbiAgICByLnN0YXRzLnNraXBwZWQgPyByZWQoci5zdGF0cy5za2lwcGVkKSA6IGdyYXkoXCItXCIpLFxuICBdKTtcblxuICByZXR1cm4gdGFibGUoXG4gICAgW1xuICAgICAgW1xuICAgICAgICBcIlwiLCAvLyBtYXJrZXJcbiAgICAgICAgZ3JheShcIlNwZWNcIiksXG4gICAgICAgIFwiXCIsXG4gICAgICAgIGdyYXkoXCJUZXN0c1wiKSxcbiAgICAgICAgZ3JheShcIlBhc3NpbmdcIiksXG4gICAgICAgIGdyYXkoXCJGYWlsaW5nXCIpLFxuICAgICAgICBncmF5KFwiUGVuZGluZ1wiKSxcbiAgICAgICAgZ3JheShcIlNraXBwZWRcIiksXG4gICAgICBdLFxuICAgICAgLi4uZGF0YSxcbiAgICAgIFtcbiAgICAgICAgaGFzRmFpbGVkID8gZmFpbHVyZUljb24gOiBzdWNjZXNzSWNvbiwgLy8gbWFya2VyXG4gICAgICAgIHZlcmRpY3QsXG4gICAgICAgIGdyYXkocHJldHR5TVMoci50b3RhbER1cmF0aW9uID8/IDApKSxcbiAgICAgICAgb3ZlcmFsbFNwZWNDb3VudCA+IDAgPyB3aGl0ZShyLnRvdGFsVGVzdHMgPz8gMCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBhc3NlZCA/IGdyZWVuKHIudG90YWxQYXNzZWQpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxGYWlsZWQgPyByZWQoci50b3RhbEZhaWxlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbFBlbmRpbmcgPyBjeWFuKHIudG90YWxQZW5kaW5nKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsU2tpcHBlZCA/IHJlZChyLnRvdGFsU2tpcHBlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgIF0sXG4gICAgXSxcbiAgICB7XG4gICAgICBib3JkZXIsXG4gICAgICBjb2x1bW5EZWZhdWx0OiB7XG4gICAgICAgIHdpZHRoOiA4LFxuICAgICAgfSxcbiAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwibGVmdFwiLCB3aWR0aDogMiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJsZWZ0XCIsIHdpZHRoOiAzMCB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgXSxcbiAgICAgIC8vIHNpbmdsZUxpbmU6IHRydWUsXG4gICAgICBkcmF3SG9yaXpvbnRhbExpbmU6IChsaW5lSW5kZXgsIHJvd0NvdW50KSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbGluZUluZGV4ID09PSAxIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSAwIHx8XG4gICAgICAgICAgbGluZUluZGV4ID09PSByb3dDb3VudCAtIDEgfHxcbiAgICAgICAgICBsaW5lSW5kZXggPT09IHJvd0NvdW50XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgZHJhd1ZlcnRpY2FsTGluZTogKGxpbmVJbmRleCwgcm93Q291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gMCB8fCByb3dDb3VudCA9PT0gbGluZUluZGV4O1xuICAgICAgfSxcbiAgICB9XG4gICk7XG59O1xuXG5jb25zdCBib3JkZXIgPSBfLm1hcFZhbHVlcyhcbiAge1xuICAgIHRvcEJvZHk6IGBcdTI1MDBgLFxuICAgIHRvcEpvaW46IGBcdTI1MkNgLFxuICAgIHRvcExlZnQ6IGAgIFx1MjUwQ2AsXG4gICAgdG9wUmlnaHQ6IGBcdTI1MTBgLFxuXG4gICAgYm90dG9tQm9keTogYFx1MjUwMGAsXG4gICAgYm90dG9tSm9pbjogYFx1MjUzNGAsXG4gICAgYm90dG9tTGVmdDogYCAgXHUyNTE0YCxcbiAgICBib3R0b21SaWdodDogYFx1MjUxOGAsXG5cbiAgICBib2R5TGVmdDogYCAgXHUyNTAyYCxcbiAgICBib2R5UmlnaHQ6IGBcdTI1MDJgLFxuICAgIGJvZHlKb2luOiBgXHUyNTAyYCxcblxuICAgIGpvaW5Cb2R5OiBgXHUyNTAwYCxcbiAgICBqb2luTGVmdDogYCAgXHUyNTFDYCxcbiAgICBqb2luUmlnaHQ6IGBcdTI1MjRgLFxuICAgIGpvaW5Kb2luOiBgXHUyNTNDYCxcbiAgfSxcbiAgKHYpID0+IGdyYXkodilcbik7XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHtcbiAgcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkLFxuICBzZXRJbnN0YW5jZVRlc3RzLFxuICBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCxcbiAgdXBkYXRlSW5zdGFuY2VSZXN1bHRzLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgeyB1cGxvYWRBcnRpZmFjdHMsIHVwbG9hZFN0ZG91dFNhZmUgfSBmcm9tIFwiLi4vYXJ0aWZhY3RzXCI7XG5pbXBvcnQgeyBzZXRDYW5jZWxsYXRpb25SZWFzb24gfSBmcm9tIFwiLi4vY2FuY2VsbGF0aW9uXCI7XG5pbXBvcnQgeyBnZXRJbml0aWFsT3V0cHV0IH0gZnJvbSBcIi4uL2NhcHR1cmVcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi4vZW52XCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcbmltcG9ydCB7IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZCwgZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQgfSBmcm9tIFwiLi9yZXN1bHRzXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cmVzdWx0c1wiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlcG9ydFJlc3VsdHNUYXNrKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBzdGRvdXQ6IHN0cmluZyxcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBleGVjdXRpb25TdGF0ZS5nZXRJbnN0YW5jZVJlc3VsdHMoY29uZmlnU3RhdGUsIGluc3RhbmNlSWQpO1xuICBjb25zdCBydW4gPSByZXN1bHRzLnJ1bnNbMF07XG4gIGlmICghcnVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcnVuIGZvdW5kIGluIEN5cHJlc3MgcmVzdWx0c1wiKTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZVJlc3VsdHMgPSBnZXRJbnN0YW5jZVJlc3VsdFBheWxvYWQocnVuLCBjb3ZlcmFnZUZpbGVQYXRoKTtcbiAgY29uc3QgaW5zdGFuY2VUZXN0cyA9IGdldEluc3RhbmNlVGVzdHNQYXlsb2FkKHJ1biwgcmVzdWx0cy5jb25maWcpO1xuICBjb25zdCB7IHZpZGVvVXBsb2FkVXJsLCBzY3JlZW5zaG90VXBsb2FkVXJscywgY292ZXJhZ2VVcGxvYWRVcmwsIGNsb3VkIH0gPVxuICAgIGF3YWl0IHJlcG9ydFJlc3VsdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VUZXN0cywgaW5zdGFuY2VSZXN1bHRzKTtcblxuICBpZiAoY2xvdWQ/LnNob3VsZENhbmNlbCkge1xuICAgIGRlYnVnKFwiaW5zdGFuY2UgJXMgc2hvdWxkIGNhbmNlbFwiLCBpbnN0YW5jZUlkKTtcbiAgICBzZXRDYW5jZWxsYXRpb25SZWFzb24oY2xvdWQuc2hvdWxkQ2FuY2VsKTtcbiAgfVxuXG4gIGRlYnVnKFwiaW5zdGFuY2UgJXMgYXJ0aWZhY3QgdXBsb2FkIGluc3RydWN0aW9ucyAlb1wiLCBpbnN0YW5jZUlkLCB7XG4gICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gICAgY292ZXJhZ2VVcGxvYWRVcmwsXG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgdXBsb2FkQXJ0aWZhY3RzKHtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgICB2aWRlb1BhdGg6IHJ1bi52aWRlbyxcbiAgICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICAgICAgc2NyZWVuc2hvdHM6IGluc3RhbmNlUmVzdWx0cy5zY3JlZW5zaG90cyxcbiAgICAgIGNvdmVyYWdlVXBsb2FkVXJsLFxuICAgICAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgICB9KSxcbiAgICB1cGxvYWRTdGRvdXRTYWZlKGluc3RhbmNlSWQsIGdldEluaXRpYWxPdXRwdXQoKSArIHN0ZG91dCksXG4gIF0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXBvcnRSZXN1bHRzKFxuICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gIGluc3RhbmNlVGVzdHM6IFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBpbnN0YW5jZVJlc3VsdHM6IFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWRcbikge1xuICBkZWJ1ZyhcInJlcG9ydGluZyBpbnN0YW5jZSAlcyByZXN1bHRzLi4uXCIsIGluc3RhbmNlSWQpO1xuICBpZiAoaXNDdXJyZW50cygpKSB7XG4gICAgcmV0dXJuIHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZChpbnN0YW5jZUlkLCB7XG4gICAgICB0ZXN0czogaW5zdGFuY2VUZXN0cyxcbiAgICAgIHJlc3VsdHM6IGluc3RhbmNlUmVzdWx0cyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJ1biBvbmUgYWZ0ZXIgYW5vdGhlclxuICBhd2FpdCBzZXRJbnN0YW5jZVRlc3RzKGluc3RhbmNlSWQsIGluc3RhbmNlVGVzdHMpO1xuICByZXR1cm4gdXBkYXRlSW5zdGFuY2VSZXN1bHRzKGluc3RhbmNlSWQsIGluc3RhbmNlUmVzdWx0cyk7XG59XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgU2NyZWVuc2hvdEFydGlmYWN0LCBTY3JlZW5zaG90VXBsb2FkSW5zdHJ1Y3Rpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHVwZGF0ZUluc3RhbmNlU3Rkb3V0IH0gZnJvbSBcIi4vYXBpXCI7XG5pbXBvcnQgeyBzYWZlIH0gZnJvbSBcIi4vbGFuZ1wiO1xuaW1wb3J0IHsgZGltIH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQgeyBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XG5pbXBvcnQgeyB1cGxvYWRJbWFnZSwgdXBsb2FkSnNvbiwgdXBsb2FkVmlkZW8gfSBmcm9tIFwiLi91cGxvYWRcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czphcnRpZmFjdHNcIik7XG5pbnRlcmZhY2UgVXBsb2FkQXJ0aWZhY3RzIHtcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlO1xuICB2aWRlb1BhdGg6IHN0cmluZyB8IG51bGw7XG4gIHZpZGVvVXBsb2FkVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgc2NyZWVuc2hvdHM6IFNjcmVlbnNob3RBcnRpZmFjdFtdO1xuICBzY3JlZW5zaG90VXBsb2FkVXJsczogU2NyZWVuc2hvdFVwbG9hZEluc3RydWN0aW9uW107XG4gIGNvdmVyYWdlVXBsb2FkVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgY292ZXJhZ2VGaWxlUGF0aD86IHN0cmluZyB8IG51bGw7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXJ0aWZhY3RzKHtcbiAgZXhlY3V0aW9uU3RhdGUsXG4gIHZpZGVvUGF0aCxcbiAgdmlkZW9VcGxvYWRVcmwsXG4gIHNjcmVlbnNob3RzLFxuICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgY292ZXJhZ2VVcGxvYWRVcmwsXG59OiBVcGxvYWRBcnRpZmFjdHMpIHtcbiAgZGVidWcoXCJ1cGxvYWRpbmcgYXJ0aWZhY3RzOiAlb1wiLCB7XG4gICAgdmlkZW9QYXRoLFxuICAgIHZpZGVvVXBsb2FkVXJsLFxuICAgIHNjcmVlbnNob3RzLFxuICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICAgIGNvdmVyYWdlRmlsZVBhdGgsXG4gICAgY292ZXJhZ2VVcGxvYWRVcmwsXG4gIH0pO1xuXG4gIGNvbnN0IHRvdGFsVXBsb2FkcyA9XG4gICAgKHZpZGVvUGF0aCA/IDEgOiAwKSArIHNjcmVlbnNob3RzLmxlbmd0aCArIChjb3ZlcmFnZVVwbG9hZFVybCA/IDEgOiAwKTtcbiAgaWYgKHRvdGFsVXBsb2FkcyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVwbG9hZCB2aWRlb1xuICBpZiAodmlkZW9VcGxvYWRVcmwgJiYgdmlkZW9QYXRoKSB7XG4gICAgYXdhaXQgc2FmZShcbiAgICAgIHVwbG9hZFZpZGVvLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZGVidWcoXCJmYWlsZWQgdXBsb2FkaW5nIHZpZGVvICVzLiBFcnJvcjogJW9cIiwgdmlkZW9QYXRoLCBlKTtcbiAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICBgRmFpbGVkIHVwbG9hZGluZyB2aWRlbyAke3ZpZGVvUGF0aH0uXFxuJHtkaW0oZSl9YFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgdmlkZW9QYXRoKVxuICAgICkodmlkZW9QYXRoLCB2aWRlb1VwbG9hZFVybCk7XG4gIH1cbiAgLy8gdXBsb2FkIHNjcmVlbnNob3RzXG4gIGlmIChzY3JlZW5zaG90VXBsb2FkVXJscyAmJiBzY3JlZW5zaG90VXBsb2FkVXJscy5sZW5ndGgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNjcmVlbnNob3RzLm1hcCgoc2NyZWVuc2hvdCkgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBzY3JlZW5zaG90VXBsb2FkVXJscy5maW5kKFxuICAgICAgICAgICh1cmxzKSA9PiB1cmxzLnNjcmVlbnNob3RJZCA9PT0gc2NyZWVuc2hvdC5zY3JlZW5zaG90SWRcbiAgICAgICAgKT8udXBsb2FkVXJsO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgXCJObyB1cGxvYWQgdXJsIGZvciBzY3JlZW5zaG90ICVvLCBzY3JlZW5zaG90VXBsb2FkVXJsczogJW9cIixcbiAgICAgICAgICAgIHNjcmVlbnNob3QsXG4gICAgICAgICAgICBzY3JlZW5zaG90VXBsb2FkVXJsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgIGBObyB1cGxvYWQgVVJMIGZvciBzY3JlZW5zaG90ICR7c2NyZWVuc2hvdC5wYXRofWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZShcbiAgICAgICAgICB1cGxvYWRJbWFnZSxcbiAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgIFwiZmFpbGVkIHVwbG9hZGluZyBzY3JlZW5zaG90ICVzLiBFcnJvcjogJW9cIixcbiAgICAgICAgICAgICAgc2NyZWVuc2hvdC5wYXRoLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhlY3V0aW9uU3RhdGUuYWRkV2FybmluZyhcbiAgICAgICAgICAgICAgYEZhaWxlZCB1cGxvYWRpbmcgc2NyZWVuc2hvdCAke3NjcmVlbnNob3QucGF0aH0uXFxuJHtkaW0oZSl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgc2NyZWVuc2hvdC5wYXRoKVxuICAgICAgICApKHNjcmVlbnNob3QucGF0aCwgdXJsKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvLyB1cGxvYWQgY292ZXJhZ2VcbiAgaWYgKGNvdmVyYWdlVXBsb2FkVXJsICYmIGNvdmVyYWdlRmlsZVBhdGgpIHtcbiAgICBhd2FpdCBzYWZlKFxuICAgICAgdXBsb2FkSnNvbixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIFwiZmFpbGVkIHVwbG9hZGluZyBjb3ZlcmFnZSBmaWxlICVzLiBFcnJvcjogJW9cIixcbiAgICAgICAgICBjb3ZlcmFnZUZpbGVQYXRoLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcblxuICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgIGBGYWlsZWQgdXBsb2FkaW5nIGNvdmVyYWdlIGZpbGUgJHtjb3ZlcmFnZUZpbGVQYXRofS5cXG4ke2RpbShlKX1gXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICAoKSA9PiBkZWJ1ZyhcInN1Y2Nlc3MgdXBsb2FkaW5nXCIsIGNvdmVyYWdlRmlsZVBhdGgpXG4gICAgKShjb3ZlcmFnZUZpbGVQYXRoLCBjb3ZlcmFnZVVwbG9hZFVybCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwbG9hZFN0ZG91dFNhZmUgPSBzYWZlKFxuICB1cGRhdGVJbnN0YW5jZVN0ZG91dCxcbiAgKCkgPT4ge30sXG4gICgpID0+IHt9XG4pO1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IG1ha2VSZXF1ZXN0IH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuY29uc3QgcmVhZEZpbGUgPSBmcy5wcm9taXNlcy5yZWFkRmlsZTtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czp1cGxvYWRcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRWaWRlbyhmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJ2aWRlby9tcDRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRJbWFnZShmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cGxvYWRGaWxlKGZpbGUsIHVybCwgXCJpbWFnZS9wbmdcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRKc29uKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG59XG5cbnR5cGUgVXBsb2FkVHlwZXMgPVxuICB8IFwidmlkZW8vbXA0XCJcbiAgfCBcImltYWdlL3BuZ1wiXG4gIHwgXCJwbGFpbi90ZXh0XCJcbiAgfCBcImFwcGxpY2F0aW9uL2pzb25cIjtcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZTogc3RyaW5nLCB1cmw6IHN0cmluZywgdHlwZTogVXBsb2FkVHlwZXMpIHtcbiAgZGVidWcoJ3VwbG9hZGluZyBmaWxlIFwiJXNcIiB0byBcIiVzXCInLCBmaWxlLCB1cmwpO1xuICBjb25zdCBmID0gYXdhaXQgcmVhZEZpbGUoZmlsZSk7XG4gIGF3YWl0IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIGRhdGE6IGYsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogdHlwZSxcbiAgICAgIFwiQ29udGVudC1EaXNwb3NpdGlvblwiOiBgaW5saW5lYCxcbiAgICB9LFxuICB9KTtcbn1cbiIsICJleHBvcnQgKiBmcm9tIFwiLi9jYW5jZWxsYXRpb25cIjtcbiIsICJpbXBvcnQgeyBFdmVudCwgcHVic3ViIH0gZnJvbSBcIi4uL3B1YnN1YlwiO1xuXG5pbnRlcmZhY2UgRXhlY3V0aW9uU3RhdGUge1xuICBjYW5jZWxsYXRpb25SZWFzb246IHN0cmluZyB8IG51bGw7XG59XG5jb25zdCBzdGF0ZTogRXhlY3V0aW9uU3RhdGUgPSB7XG4gIGNhbmNlbGxhdGlvblJlYXNvbjogbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRDYW5jZWxsYXRpb25SZWFzb24gPSAocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgaWYgKHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb24gPSByZWFzb247XG4gIHB1YnN1Yi5lbWl0KEV2ZW50LlJVTl9DQU5DRUxMRUQsIHJlYXNvbik7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FuY2VsbGF0aW9uUmVhc29uID0gKCkgPT4gc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uO1xuIiwgImV4cG9ydCAqIGZyb20gXCIuL2NhbmNlbGxhYmxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZXBvcnRUYXNrXCI7XG4iLCAiaW1wb3J0IHsgQlByb21pc2UgfSBmcm9tIFwiLi4vbGFuZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5pbXBvcnQgeyBydW5UaWxsRG9uZSB9IGZyb20gXCIuL3J1bm5lclwiO1xuXG5sZXQgY2FuY2VsbGFibGU6IHtcbiAgY2FuY2VsOiAoKSA9PiB2b2lkO1xufSB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBvblJ1bkNhbmNlbGxlZChyZWFzb246IHN0cmluZykge1xuICB3YXJuKFxuICAgIGBSdW4gY2FuY2VsbGVkOiAlcy4gV2FpdGluZyBmb3IgdXBsb2FkcyB0byBjb21wbGV0ZSBhbmQgc3RvcHBpbmcgZXhlY3V0aW9uLi4uYCxcbiAgICByZWFzb25cbiAgKTtcbiAgY2FuY2VsbGFibGU/LmNhbmNlbCgpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lT3JDYW5jZWxsZWQoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHJ1blRpbGxEb25lPlxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICBjYW5jZWxsYWJsZSA9IG5ldyBCUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgaWYgKCFvbkNhbmNlbCkge1xuICAgICAgICBfcmVqZWN0KG5ldyBFcnJvcihcIkJsdWVCaXJkIGlzIG1pc2NvbmZpZ3VyZWQ6IG9uQ2FuY2VsIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uQ2FuY2VsKCgpID0+IF9yZXNvbHZlKHZvaWQgMCkpO1xuICAgICAgcnVuVGlsbERvbmUoLi4uYXJncykudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBfcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICBfcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHB1YnN1Yi5hZGRMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIHB1YnN1Yi5yZW1vdmVMaXN0ZW5lcihFdmVudC5SVU5fQ0FOQ0VMTEVELCBvblJ1bkNhbmNlbGxlZCk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7XG4gIFNwZWNXaXRoUmVsYXRpdmVSb290LFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRDYXB0dXJlZE91dHB1dCwgcmVzZXRDYXB0dXJlIH0gZnJvbSBcIi4uL2NhcHR1cmVcIjtcblxuaW1wb3J0IHsgZ2V0Q3lwcmVzc1J1blJlc3VsdEZvclNwZWMgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQge1xuICBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzLFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkLFxuICBJbnN0YW5jZVJlc3BvbnNlU3BlY0RldGFpbHMsXG59IGZyb20gXCIuLi9hcGlcIjtcblxuaW1wb3J0IHsgcnVuU3BlY0ZpbGVTYWZlIH0gZnJvbSBcIi4uL2N5cHJlc3NcIjtcbmltcG9ydCB7IGlzQ3VycmVudHMgfSBmcm9tIFwiLi4vZW52XCI7XG5pbXBvcnQgeyBkaXZpZGVyLCBpbmZvLCB0aXRsZSwgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgY3JlYXRlUmVwb3J0VGFzaywgcmVwb3J0VGFza3MgfSBmcm9tIFwiLi9yZXBvcnRUYXNrXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpydW5uZXJcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5UaWxsRG9uZShcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHtcbiAgICBydW5JZCxcbiAgICBncm91cElkLFxuICAgIG1hY2hpbmVJZCxcbiAgICBwbGF0Zm9ybSxcbiAgICBzcGVjczogYWxsU3BlY3MsXG4gIH06IENyZWF0ZUluc3RhbmNlUGF5bG9hZCAmIHtcbiAgICBzcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXTtcbiAgfSxcbiAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnNcbikge1xuICBsZXQgaGFzTW9yZSA9IHRydWU7XG5cbiAgd2hpbGUgKGhhc01vcmUpIHtcbiAgICBjb25zdCBuZXdUYXNrcyA9IGF3YWl0IHJ1bkJhdGNoKGV4ZWN1dGlvblN0YXRlLCBjb25maWdTdGF0ZSwge1xuICAgICAgcnVuTWV0YToge1xuICAgICAgICBydW5JZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgbWFjaGluZUlkLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgIH0sXG4gICAgICBhbGxTcGVjcyxcbiAgICAgIHBhcmFtcyxcbiAgICB9KTtcbiAgICBpZiAoIW5ld1Rhc2tzLmxlbmd0aCkge1xuICAgICAgZGVidWcoXCJObyBtb3JlIHRhc2tzIHRvIHJ1bi4gVXBsb2FkcyBxdWV1ZTogJWRcIiwgcmVwb3J0VGFza3MubGVuZ3RoKTtcbiAgICAgIGhhc01vcmUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuZXdUYXNrcy5mb3JFYWNoKCh0KSA9PlxuICAgICAgY3JlYXRlUmVwb3J0VGFzayhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIHQuaW5zdGFuY2VJZClcbiAgICApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkJhdGNoKFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHJ1bk1ldGEsXG4gICAgcGFyYW1zLFxuICAgIGFsbFNwZWNzLFxuICB9OiB7XG4gICAgcnVuTWV0YToge1xuICAgICAgcnVuSWQ6IHN0cmluZztcbiAgICAgIGdyb3VwSWQ6IHN0cmluZztcbiAgICAgIG1hY2hpbmVJZDogc3RyaW5nO1xuICAgICAgcGxhdGZvcm06IENyZWF0ZUluc3RhbmNlUGF5bG9hZFtcInBsYXRmb3JtXCJdO1xuICAgIH07XG4gICAgYWxsU3BlY3M6IFNwZWNXaXRoUmVsYXRpdmVSb290W107XG4gICAgcGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG4gIH1cbikge1xuICBsZXQgYmF0Y2ggPSB7XG4gICAgc3BlY3M6IFtdIGFzIEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlsc1tdLFxuICAgIGNsYWltZWRJbnN0YW5jZXM6IDAsXG4gICAgdG90YWxJbnN0YW5jZXM6IDAsXG4gIH07XG5cbiAgaWYgKGlzQ3VycmVudHMoKSkge1xuICAgIGRlYnVnKFwiR2V0dGluZyBiYXRjaGVkIHRhc2tzOiAlZFwiLCBwYXJhbXMuYmF0Y2hTaXplKTtcbiAgICBiYXRjaCA9IGF3YWl0IGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMoe1xuICAgICAgLi4ucnVuTWV0YSxcbiAgICAgIGJhdGNoU2l6ZTogcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICB9KTtcbiAgICBkZWJ1ZyhcIkdvdCBiYXRjaGVkIHRhc2tzOiAlb1wiLCBiYXRjaCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVJbnN0YW5jZShydW5NZXRhKTtcblxuICAgIGlmIChyZXNwb25zZS5zcGVjICE9PSBudWxsICYmIHJlc3BvbnNlLmluc3RhbmNlSWQgIT09IG51bGwpIHtcbiAgICAgIGJhdGNoLnNwZWNzLnB1c2goe1xuICAgICAgICBzcGVjOiByZXNwb25zZS5zcGVjLFxuICAgICAgICBpbnN0YW5jZUlkOiByZXNwb25zZS5pbnN0YW5jZUlkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoLmNsYWltZWRJbnN0YW5jZXMgPSByZXNwb25zZS5jbGFpbWVkSW5zdGFuY2VzO1xuICAgIGJhdGNoLnRvdGFsSW5zdGFuY2VzID0gcmVzcG9uc2UudG90YWxJbnN0YW5jZXM7XG4gIH1cblxuICBpZiAoYmF0Y2guc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhdGNoIGNhbiBoYXZlIG11bHRpcGxlIHNwZWNzLiBXaGlsZSBydW5uaW5nIHRoZSBzcGVjcyxcbiAgICogY3lwcmVzcyBjYW4gaGFyZC1jcmFzaCB3aXRob3V0IHJlcG9ydGluZyBhbnkgcmVzdWx0LlxuICAgKlxuICAgKiBXaGVuIGNyYXNoZWQsIGlkZWFsbHksIHdlIG5lZWQgdG86XG4gICAqIC0gZGV0ZXJtaW5lIHdoaWNoIHNwZWMgY3Jhc2hlZFxuICAgKiAtIGFzc29jaWF0ZSB0aGUgY3Jhc2ggd2l0aCB0aGUgc3BlY1xuICAgKiAtIHJ1biB0aGUgcmVzdCBvZiB1bnJlcG9ydGVkIHNwZWNzIGluIHRoZSBiYXRjaFxuICAgKlxuICAgKiBCdXQgZGV0ZWN0aW5nIHRoZSBjcmFzaGVkIHNwZWMgaXMgZXJyb3ItcHJvbmUgYW5kIGluYWNjdXJhdGUsXG4gICAqIHNvIHdlIGZhbGwgYmFjayB0byByZXBvcnRpbmcgaGFyZCBjcmFzaCB0byBhbGwgc3Vic2VxdWVudFxuICAgKiBzcGVjcyBpbiB0aGUgYmF0Y2guXG4gICAqXG4gICAqIFdvcnN0LWNhc2Ugc2NlbmFyaW86IHdlIHJlcG9ydCBoYXJkIGNyYXNoIHRvIGFsbCBzcGVjcyBpbiB0aGUgYmF0Y2guXG4gICAqL1xuXG4gIC8vICVzdGF0ZVxuICBiYXRjaC5zcGVjcy5mb3JFYWNoKChpKSA9PiBleGVjdXRpb25TdGF0ZS5pbml0SW5zdGFuY2UoaSkpO1xuXG4gIGRpdmlkZXIoKTtcbiAgaW5mbyhcbiAgICBcIlJ1bm5pbmc6ICVzICglZC8lZClcIixcbiAgICBiYXRjaC5zcGVjcy5tYXAoKHMpID0+IHMuc3BlYykuam9pbihcIiwgXCIpLFxuICAgIGJhdGNoLmNsYWltZWRJbnN0YW5jZXMsXG4gICAgYmF0Y2gudG90YWxJbnN0YW5jZXNcbiAgKTtcblxuICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCBydW5TcGVjRmlsZVNhZmUoXG4gICAge1xuICAgICAgLy8gdXNlIGFic29sdXRlIHBhdGhzIC0gdXNlciBjYW4gcnVuIHRoZSBwcm9ncmFtIGZyb20gYSBkaWZmZXJlbnQgZGlyZWN0b3J5LCBlLmcuIG54IG9yIGEgbW9ub3JlcG8gd29ya3NwYWNlXG4gICAgICAvLyBjeXByZXNzIHN0aWxsIHJlcG9ydCB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgcHJvamVjdCByb290XG4gICAgICBzcGVjOiBiYXRjaC5zcGVjc1xuICAgICAgICAubWFwKChicykgPT4gZ2V0U3BlY0Fic29sdXRlUGF0aChhbGxTcGVjcywgYnMuc3BlYykpXG4gICAgICAgIC5qb2luKFwiLFwiKSxcbiAgICB9LFxuICAgIHBhcmFtc1xuICApO1xuXG4gIHRpdGxlKFwiYmx1ZVwiLCBcIlJlcG9ydGluZyByZXN1bHRzIGFuZCBhcnRpZmFjdHMgaW4gYmFja2dyb3VuZC4uLlwiKTtcblxuICBjb25zdCBvdXRwdXQgPSBnZXRDYXB0dXJlZE91dHB1dCgpO1xuXG4gIC8vICVzdGF0ZVxuICBiYXRjaC5zcGVjcy5mb3JFYWNoKChzcGVjKSA9PiB7XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0SW5zdGFuY2VPdXRwdXQoc3BlYy5pbnN0YW5jZUlkLCBvdXRwdXQpO1xuICAgIGNvbnN0IHNwZWNSdW5SZXN1bHQgPSBnZXRDeXByZXNzUnVuUmVzdWx0Rm9yU3BlYyhzcGVjLnNwZWMsIHJhd1Jlc3VsdCk7XG4gICAgaWYgKCFzcGVjUnVuUmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV4ZWN1dGlvblN0YXRlLnNldEluc3RhbmNlUmVzdWx0KFxuICAgICAgY29uZmlnU3RhdGUsXG4gICAgICBzcGVjLmluc3RhbmNlSWQsXG4gICAgICBzcGVjUnVuUmVzdWx0XG4gICAgKTtcbiAgfSk7XG5cbiAgcmVzZXRDYXB0dXJlKCk7XG5cbiAgcmV0dXJuIGJhdGNoLnNwZWNzO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjQWJzb2x1dGVQYXRoKFxuICBhbGxTcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXSxcbiAgcmVsYXRpdmU6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IGFic29sdXRlUGF0aCA9IGFsbFNwZWNzLmZpbmQoKGkpID0+IGkucmVsYXRpdmUgPT09IHJlbGF0aXZlKT8uYWJzb2x1dGU7XG4gIGlmICghYWJzb2x1dGVQYXRoKSB7XG4gICAgd2FybihcbiAgICAgICdDYW5ub3QgZmluZCBhYnNvbHV0ZSBwYXRoIGZvciBzcGVjLiBTcGVjOiBcIiVzXCIsIGNhbmRpZGF0ZXM6ICVvJyxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgYWxsU3BlY3NcbiAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYWJzb2x1dGUgcGF0aCBmb3Igc3BlY2ApO1xuICB9XG4gIHJldHVybiBhYnNvbHV0ZVBhdGg7XG59XG4iLCAiaW1wb3J0IHsgSW5zdGFuY2VJZCB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldFJlcG9ydFJlc3VsdHNUYXNrIH0gZnJvbSBcIi4uL3Jlc3VsdHNcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cmVwb3J0VGFza1wiKTtcblxuZXhwb3J0IGNvbnN0IHJlcG9ydFRhc2tzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVwb3J0VGFzayA9IChcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGluc3RhbmNlSWQ6IEluc3RhbmNlSWRcbikgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IGV4ZWN1dGlvblN0YXRlLmdldEluc3RhbmNlKGluc3RhbmNlSWQpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgZXJyb3IoXCJDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlICVzXCIsIGluc3RhbmNlSWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5zdGFuY2UucmVwb3J0U3RhcnRlZEF0KSB7XG4gICAgZGVidWcoXCJSZXBvcnQgdGFzayBhbHJlYWR5IGNyZWF0ZWQgZm9yIGluc3RhbmNlICVzXCIsIGluc3RhbmNlSWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGluc3RhbmNlLnJlcG9ydFN0YXJ0ZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgZGVidWcoXCJDcmVhdGluZyByZXBvcnQgdGFzayBmb3IgaW5zdGFuY2VJZCAlc1wiLCBpbnN0YW5jZUlkKTtcbiAgcmVwb3J0VGFza3MucHVzaChcbiAgICBnZXRSZXBvcnRSZXN1bHRzVGFzayhcbiAgICAgIGluc3RhbmNlSWQsXG4gICAgICBjb25maWdTdGF0ZSxcbiAgICAgIGV4ZWN1dGlvblN0YXRlLFxuICAgICAgaW5zdGFuY2Uub3V0cHV0ID8/IFwibm8gb3V0cHV0IGNhcHR1cmVkXCIsXG4gICAgICBpbnN0YW5jZS5jb3ZlcmFnZUZpbGVQYXRoXG4gICAgKS5jYXRjaChlcnJvcilcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXBvcnRUYXNrU3BlYyA9IChcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIHNwZWM6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IGkgPSBleGVjdXRpb25TdGF0ZS5nZXRTcGVjKHNwZWMpO1xuICBpZiAoIWkpIHtcbiAgICBlcnJvcihcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyAlc1wiLCBzcGVjKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVidWcoXCJDcmVhdGluZyByZXBvcnQgdGFzayBmb3Igc3BlYyAlc1wiLCBzcGVjKTtcbiAgcmV0dXJuIGNyZWF0ZVJlcG9ydFRhc2soY29uZmlnU3RhdGUsIGV4ZWN1dGlvblN0YXRlLCBpLmluc3RhbmNlSWQpO1xufTtcbiIsICJpbXBvcnQgeyBzdG9wV1NTIH0gZnJvbSBcIi4vd3NcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNodXRkb3duKCkge1xuICBhd2FpdCBzdG9wV1NTKCk7XG59XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vZ2V0U3BlY0ZpbGVzXCI7XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGZpbmRTcGVjcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRTcGVjRmlsZXMgPSBhc3luYyAoe1xuICBjb25maWcsXG4gIHBhcmFtcyxcbn06IHtcbiAgY29uZmlnOiBNZXJnZWRDb25maWc7XG4gIHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzO1xufSkgPT4ge1xuICBjb25zdCBzcGVjUGF0dGVybiA9IGdldFNwZWNQYXR0ZXJuKGNvbmZpZy5zcGVjUGF0dGVybiwgcGFyYW1zLnNwZWMpO1xuICAvLyBmaW5kIHRoZSBzcGVjIGZpbGVzIGFjY29yZGluZyB0byB0aGUgcmVzb2x2ZWQgY29uZmlndXJhdGlvblxuICBjb25zdCBzcGVjcyA9IGF3YWl0IGZpbmRTcGVjcyh7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2d1aWRlcy9jb21tYW5kLWxpbmUjY3lwcmVzcy1ydW4tc3BlYy1sdC1zcGVjLWd0XG4gICAgcHJvamVjdFJvb3Q6IHBhcmFtcy5wcm9qZWN0ID8/IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICB0ZXN0aW5nVHlwZTogcGFyYW1zLnRlc3RpbmdUeXBlLFxuICAgIHNwZWNQYXR0ZXJuLFxuICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOiBjb25maWcuZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuOiBjb25maWcuYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gIH0pO1xuICBpZiAoc3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgd2FybihcbiAgICAgIFwiRm91bmQgbm8gc3BlYyBmaWxlcy4gV2FzIGxvb2tpbmcgZm9yIHNwZWMgZmlsZXMgdGhhdCBtYXRjaCBib3RoIGNvbmZpZ1NwZWNQYXR0ZXJuIGFuZCBzcGVjUGF0dGVybiByZWxhdGl2ZSB0byBwcm9qZWN0Um9vdC4gQ29uZmlndXJhdGlvbjogJU9cIixcbiAgICAgIHtcbiAgICAgICAgcHJvamVjdFJvb3Q6IGNvbmZpZy5wcm9qZWN0Um9vdCxcbiAgICAgICAgc3BlY1BhdHRlcm4sXG4gICAgICAgIGNvbmZpZ1NwZWNQYXR0ZXJuOiBjb25maWcuc3BlY1BhdHRlcm4sXG4gICAgICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjogW1xuICAgICAgICAgIGNvbmZpZy5leGNsdWRlU3BlY1BhdHRlcm4sXG4gICAgICAgICAgY29uZmlnLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICAgICAgICBdLmZsYXQoMiksXG4gICAgICAgIHRlc3RpbmdUeXBlOiBwYXJhbXMudGVzdGluZ1R5cGUsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4geyBzcGVjcywgc3BlY1BhdHRlcm4gfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNwZWNQYXR0ZXJuKFxuICBjb25maWdQYXR0ZXJuOiBNZXJnZWRDb25maWdbXCJzcGVjUGF0dGVyblwiXSxcbiAgZXhwbGljaXQ/OiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJzcGVjXCJdXG4pIHtcbiAgcmV0dXJuIGV4cGxpY2l0IHx8IGNvbmZpZ1BhdHRlcm47XG59XG4iLCAiLyohIEBwcmVzZXJ2ZVxuXG4jIyMgTUlUXG5cblBhcnRzIG9mIHRoaXMgY29kZSB3YXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcyBhbmQgaXMgc3ViamVjdCB0byBNSVQgbGljZW5zZS5cblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDIyIEN5cHJlc3MuaW9cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcblxuaW1wb3J0IGNvbW1vblBhdGhQcmVmaXggZnJvbSBcImNvbW1vbi1wYXRoLXByZWZpeFwiO1xuaW1wb3J0IGdsb2JieSwgeyBHbG9iYnlPcHRpb25zIH0gZnJvbSBcImdsb2JieVwiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0IHtcbiAgRmluZFNwZWNzLFxuICBTcGVjVHlwZSxcbiAgU3BlY1dpdGhSZWxhdGl2ZVJvb3QsXG4gIFRlc3RpbmdUeXBlLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRvQXJyYXksIHRvUG9zaXggfSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnNwZWNzXCIpO1xuXG50eXBlIEdsb2JQYXR0ZXJuID0gc3RyaW5nIHwgc3RyaW5nW107XG5cbi8qKlxuICogUmVwbGljYXRlIGhvdyBjeXByZXNzIGlzIGRpc2NvdmVyaW5nIHNwZWMgZmlsZXNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9iYzllZGI0NDUyM2Q2MmNhOTM0ODI3YjhlODcwZjM4Zjg2NjM0Y2E0L3BhY2thZ2VzL2RhdGEtY29udGV4dC9zcmMvc291cmNlcy9Qcm9qZWN0RGF0YVNvdXJjZS50cyNMMjUwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvYmM5ZWRiNDQ1MjNkNjJjYTkzNDgyN2I4ZTg3MGYzOGY4NjYzNGNhNC9wYWNrYWdlcy9kYXRhLWNvbnRleHQvc3JjL2FjdGlvbnMvUHJvamVjdEFjdGlvbnMudHMjTDQxN1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZFNwZWNzKHtcbiAgcHJvamVjdFJvb3QsXG4gIHRlc3RpbmdUeXBlLFxuICBzcGVjUGF0dGVybixcbiAgY29uZmlnU3BlY1BhdHRlcm4sXG4gIGV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG59OiBGaW5kU3BlY3M8c3RyaW5nW10gfCBzdHJpbmc+KTogUHJvbWlzZTxTcGVjV2l0aFJlbGF0aXZlUm9vdFtdPiB7XG4gIGNvbmZpZ1NwZWNQYXR0ZXJuID0gdG9BcnJheShjb25maWdTcGVjUGF0dGVybik7XG4gIHNwZWNQYXR0ZXJuID0gdG9BcnJheShzcGVjUGF0dGVybik7XG4gIGV4Y2x1ZGVTcGVjUGF0dGVybiA9IHRvQXJyYXkoZXhjbHVkZVNwZWNQYXR0ZXJuKSB8fCBbXTtcblxuICAvLyBleGNsdWRlIGFsbCBzcGVjcyBtYXRjaGluZyBlMmUgaWYgaW4gY29tcG9uZW50IHRlc3RpbmdcbiAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4gPSB0b0FycmF5KGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuKSB8fCBbXTtcblxuICBkZWJ1ZyhcImV4cGxvcmluZyBzcGVjIGZpbGVzIGZvciBleGVjdXRpb24gJU9cIiwge1xuICAgIHRlc3RpbmdUeXBlLFxuICAgIHByb2plY3RSb290LFxuICAgIHNwZWNQYXR0ZXJuLFxuICAgIGNvbmZpZ1NwZWNQYXR0ZXJuLFxuICAgIGV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgfSk7XG5cbiAgaWYgKCFzcGVjUGF0dGVybiB8fCAhY29uZmlnU3BlY1BhdHRlcm4pIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGdsb2IgcGF0dGVybnMgZm9yIGV4cGxvcmluZyBzcGVjc1wiKTtcbiAgfVxuXG4gIGxldCBzcGVjQWJzb2x1dGVQYXRocyA9IGF3YWl0IGdldEZpbGVzQnlHbG9iKHByb2plY3RSb290LCBzcGVjUGF0dGVybiwge1xuICAgIGFic29sdXRlOiB0cnVlLFxuICAgIGlnbm9yZTogWy4uLmV4Y2x1ZGVTcGVjUGF0dGVybiwgLi4uYWRkaXRpb25hbElnbm9yZVBhdHRlcm5dLFxuICB9KTtcblxuICAvLyBJZiB0aGUgc3BlY1BhdHRlcm4gYW5kIGNvbmZpZ1NwZWNQYXR0ZXJuIGFyZSBkaWZmZXJlbnQsXG4gIC8vIGl0IG1lYW5zIHRoZSB1c2VyIHBhc3NlZCBzb21ldGhpbmcgbm9uLWRlZmF1bHQgdmlhIC0tc3BlYyAocnVuIG1vZGUgb25seSlcbiAgLy8gaW4gdGhpcyBzY2VuYXJpbywgd2Ugd2FudCB0byBncmFiIGV2ZXJ5dGhpbmcgdGhhdCBtYXRjaGVzIGAtLXNwZWNgXG4gIC8vIHRoYXQgZmFsbHMgd2l0aGluIHRoZWlyIGRlZmF1bHQgc3BlY1BhdHRlcm4uIFRoZSByZWFzb24gaXMgc28gd2UgYXZvaWRcbiAgLy8gYXR0ZW1wdGluZyB0byBydW4gdGhpbmdzIHRoYXQgYXJlIG5vdCBzcGVjcywgZWcgc291cmNlIGNvZGUsIHZpZGVvcywgZXRjLlxuICAvL1xuICAvLyBFeGFtcGxlOiBkZXZlbG9wZXIgd2FudHMgdG8gcnVuIHRlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aW1lcnMgaW4gcGFja2FnZXMvZHJpdmVyXG4gIC8vIFNvIHRoZXkgcnVuIHlhcm4gY3lwcmVzczpydW4gLS1zcGVjICoqL3RpbWVycypcbiAgLy8gd2UgZG8gKipub3QqKiB3YW50IHRvIGNhcHR1cmUgYHRpbWVycy50c2AgKHNvdXJjZSBjb2RlKSBvciBhIHZpZGVvIGluXG4gIC8vIGN5cHJlc3MvdmlkZW9zL3RpbWVycy5jeS50cy5tcDQsIHNvIHdlIHRha2UgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHNwZWNQYXR0ZXJuXG4gIC8vIGFuZCAtLXNwZWMuXG4gIGlmICghXy5pc0VxdWFsKHNwZWNQYXR0ZXJuLCBjb25maWdTcGVjUGF0dGVybikpIHtcbiAgICBjb25zdCBkZWZhdWx0U3BlY0Fic29sdXRlUGF0aHMgPSBhd2FpdCBnZXRGaWxlc0J5R2xvYihcbiAgICAgIHByb2plY3RSb290LFxuICAgICAgY29uZmlnU3BlY1BhdHRlcm4sXG4gICAgICB7XG4gICAgICAgIGFic29sdXRlOiB0cnVlLFxuICAgICAgICBpZ25vcmU6IFsuLi5leGNsdWRlU3BlY1BhdHRlcm4sIC4uLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuXSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgc3BlY0Fic29sdXRlUGF0aHMgPSBfLmludGVyc2VjdGlvbihcbiAgICAgIHNwZWNBYnNvbHV0ZVBhdGhzLFxuICAgICAgZGVmYXVsdFNwZWNBYnNvbHV0ZVBhdGhzXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkU3BlY3Moe1xuICAgIHByb2plY3RSb290LFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIHNwZWNBYnNvbHV0ZVBhdGhzLFxuICAgIHNwZWNQYXR0ZXJuLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZXNCeUdsb2IoXG4gIHByb2plY3RSb290OiBzdHJpbmcsXG4gIGdsb2I6IEdsb2JQYXR0ZXJuLFxuICBnbG9iT3B0aW9uczogR2xvYmJ5T3B0aW9uc1xuKSB7XG4gIGNvbnN0IHdvcmtpbmdEaXJlY3RvcnlQcmVmaXggPSBwYXRoLmpvaW4ocHJvamVjdFJvb3QsIHBhdGguc2VwKTtcbiAgY29uc3QgZ2xvYnMgPSAoW10gYXMgc3RyaW5nW10pXG4gICAgLmNvbmNhdChnbG9iKVxuICAgIC5tYXAoKGdsb2JQYXR0ZXJuKSA9PlxuICAgICAgZ2xvYlBhdHRlcm4uc3RhcnRzV2l0aChcIi4vXCIpID8gZ2xvYlBhdHRlcm4ucmVwbGFjZShcIi4vXCIsIFwiXCIpIDogZ2xvYlBhdHRlcm5cbiAgICApXG4gICAgLm1hcCgoZ2xvYlBhdHRlcm4pID0+IHtcbiAgICAgIC8vIElmIHRoZSBwYXR0ZXJuIGluY2x1ZGVzIHRoZSB3b3JraW5nIGRpcmVjdG9yeSwgd2Ugc3RyaXAgaXQgZnJvbSB0aGUgcGF0dGVybi5cbiAgICAgIC8vIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBwYXRoIG1heSBpbmNsdWRlIGNoYXJhY3RlcnMgdGhhdCBjb25mbGljdCB3aXRoIGdsb2JcbiAgICAgIC8vIHN5bnRheCAoYnJhY2tldHMsIHBhcmVudGhlc2VzLCBldGMuKSBhbmQgY2F1c2Ugb3VyIHNlYXJjaGVzIHRvIGluYWR2ZXJ0ZW50bHkgZmFpbC5cbiAgICAgIC8vIFdlIHNjb3BlIG91ciBzZWFyY2ggdG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IHVzaW5nIHRoZSBgY3dkYCBnbG9iYnkgb3B0aW9uLlxuICAgICAgaWYgKGdsb2JQYXR0ZXJuLnN0YXJ0c1dpdGgod29ya2luZ0RpcmVjdG9yeVByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXR0ZXJuLnJlcGxhY2Uod29ya2luZ0RpcmVjdG9yeVByZWZpeCwgXCJcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnbG9iUGF0dGVybjtcbiAgICB9KTtcblxuICBpZiAob3MucGxhdGZvcm0oKSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgLy8gZ2xvYmJ5IGNhbid0IHdvcmsgd2l0aCBiYWNrd2FyZHMgc2xhc2hlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ2xvYmJ5L2lzc3Vlcy8xNzlcbiAgICBkZWJ1ZyhcInVwZGF0aW5nIGdsb2IgcGF0dGVybnMgdG8gUE9TSVhcIik7XG4gICAgZm9yIChjb25zdCBpIGluIGdsb2JzKSB7XG4gICAgICBjb25zdCBjdXIgPSBnbG9ic1tpXTtcblxuICAgICAgaWYgKCFjdXIpIHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCBnbG9iIHJlY2VpdmVkXCIpO1xuXG4gICAgICBnbG9ic1tpXSA9IHRvUG9zaXgoY3VyKTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGRlYnVnKFwiZ2xvYmJpbmcgcGF0dGVybihzKTogJW9cIiwgZ2xvYnMpO1xuICAgIGRlYnVnKFwid2l0aGluIGRpcmVjdG9yeTogJXNcIiwgcHJvamVjdFJvb3QpO1xuXG4gICAgcmV0dXJuIG1hdGNoR2xvYnMoZ2xvYnMsIHtcbiAgICAgIG9ubHlGaWxlczogdHJ1ZSxcbiAgICAgIGFic29sdXRlOiB0cnVlLFxuICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgIC4uLmdsb2JPcHRpb25zLFxuICAgICAgaWdub3JlOiAoZ2xvYk9wdGlvbnM/Lmlnbm9yZSA/PyBbXSkuY29uY2F0KFwiKiovbm9kZV9tb2R1bGVzLyoqXCIpLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoXCJlcnJvciBpbiBnZXRGaWxlc0J5R2xvYiAlb1wiLCBlKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuY29uc3QgbWF0Y2hHbG9icyA9IGFzeW5jIChnbG9iczogR2xvYlBhdHRlcm4sIGdsb2JieU9wdGlvbnM6IEdsb2JieU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGF3YWl0IGdsb2JieShnbG9icywgZ2xvYmJ5T3B0aW9ucyk7XG59O1xuXG5pbnRlcmZhY2UgTWF0Y2hlZFNwZWNzIHtcbiAgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgdGVzdGluZ1R5cGU6IFRlc3RpbmdUeXBlO1xuICBzcGVjQWJzb2x1dGVQYXRoczogc3RyaW5nW107XG4gIHNwZWNQYXR0ZXJuOiBzdHJpbmcgfCBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlZFNwZWNzKHtcbiAgcHJvamVjdFJvb3QsXG4gIHRlc3RpbmdUeXBlLFxuICBzcGVjQWJzb2x1dGVQYXRocyxcbn06IE1hdGNoZWRTcGVjcykge1xuICBkZWJ1ZyhcImZvdW5kIHNwZWNzICVvXCIsIHNwZWNBYnNvbHV0ZVBhdGhzKTtcblxuICBsZXQgY29tbW9uUm9vdCA9IFwiXCI7XG5cbiAgaWYgKHNwZWNBYnNvbHV0ZVBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbW1vblJvb3QgPSBwYXRoLmRpcm5hbWUoc3BlY0Fic29sdXRlUGF0aHNbMF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbW1vblJvb3QgPSBjb21tb25QYXRoUHJlZml4KHNwZWNBYnNvbHV0ZVBhdGhzKTtcbiAgfVxuXG4gIHJldHVybiBzcGVjQWJzb2x1dGVQYXRocy5tYXAoKGFic29sdXRlKSA9PlxuICAgIHRyYW5zZm9ybVNwZWMoe1xuICAgICAgcHJvamVjdFJvb3QsXG4gICAgICBhYnNvbHV0ZSxcbiAgICAgIHRlc3RpbmdUeXBlLFxuICAgICAgY29tbW9uUm9vdCxcbiAgICAgIHBsYXRmb3JtOiBvcy5wbGF0Zm9ybSgpLFxuICAgICAgc2VwOiBwYXRoLnNlcCxcbiAgICB9KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybVNwZWMge1xuICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICBhYnNvbHV0ZTogc3RyaW5nO1xuICB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIGNvbW1vblJvb3Q6IHN0cmluZztcbiAgcGxhdGZvcm06IE5vZGVKUy5QbGF0Zm9ybTtcbiAgc2VwOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWMoe1xuICBwcm9qZWN0Um9vdCxcbiAgYWJzb2x1dGUsXG4gIHRlc3RpbmdUeXBlLFxuICBjb21tb25Sb290LFxuICBwbGF0Zm9ybSxcbiAgc2VwLFxufTogVHJhbnNmb3JtU3BlYykge1xuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGFic29sdXRlID0gdG9Qb3NpeChhYnNvbHV0ZSwgc2VwKTtcbiAgICBwcm9qZWN0Um9vdCA9IHRvUG9zaXgocHJvamVjdFJvb3QsIHNlcCk7XG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUocHJvamVjdFJvb3QsIGFic29sdXRlKTtcbiAgY29uc3QgcGFyc2VkRmlsZSA9IHBhdGgucGFyc2UoYWJzb2x1dGUpO1xuICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGFic29sdXRlKTtcblxuICBjb25zdCBzcGVjRmlsZUV4dGVuc2lvbiA9XG4gICAgW1wiLnNwZWNcIiwgXCIudGVzdFwiLCBcIi1zcGVjXCIsIFwiLXRlc3RcIiwgXCIuY3lcIl1cbiAgICAgIC5tYXAoKGV4dCkgPT4gZXh0ICsgZmlsZUV4dGVuc2lvbilcbiAgICAgIC5maW5kKChleHQpID0+IGFic29sdXRlLmVuZHNXaXRoKGV4dCkpIHx8IGZpbGVFeHRlbnNpb247XG5cbiAgY29uc3QgcGFydHMgPSBhYnNvbHV0ZS5zcGxpdChwcm9qZWN0Um9vdCk7XG4gIGxldCBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gfHwgXCJcIjtcblxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEpO1xuICB9XG5cbiAgY29uc3QgTEVBRElOR19TTEFTSCA9IC9eXFwvfC9nO1xuICBjb25zdCByZWxhdGl2ZVRvQ29tbW9uUm9vdCA9IGFic29sdXRlXG4gICAgLnJlcGxhY2UoY29tbW9uUm9vdCwgXCJcIilcbiAgICAucmVwbGFjZShMRUFESU5HX1NMQVNILCBcIlwiKTtcblxuICByZXR1cm4ge1xuICAgIGZpbGVFeHRlbnNpb24sXG4gICAgYmFzZU5hbWU6IHBhcnNlZEZpbGUuYmFzZSxcbiAgICBmaWxlTmFtZTogcGFyc2VkRmlsZS5iYXNlLnJlcGxhY2Uoc3BlY0ZpbGVFeHRlbnNpb24sIFwiXCIpLFxuICAgIHNwZWNGaWxlRXh0ZW5zaW9uLFxuICAgIHJlbGF0aXZlVG9Db21tb25Sb290LFxuICAgIHNwZWNUeXBlOiAodGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCJcbiAgICAgID8gXCJjb21wb25lbnRcIlxuICAgICAgOiBcImludGVncmF0aW9uXCIpIGFzIFNwZWNUeXBlLFxuICAgIG5hbWUsXG4gICAgcmVsYXRpdmUsXG4gICAgYWJzb2x1dGUsXG4gIH07XG59XG4iLCAiaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkodmFsPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgcmV0dXJuIHZhbCA/ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gW3ZhbF0gOiB2YWwpIDogW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Bvc2l4KGZpbGU6IHN0cmluZywgc2VwOiBzdHJpbmcgPSBwYXRoLnNlcCkge1xuICByZXR1cm4gZmlsZS5zcGxpdChzZXApLmpvaW4ocGF0aC5wb3NpeC5zZXApO1xufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL2NvbmZpZ1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZXhlY3V0aW9uXCI7XG4iLCAiZXhwb3J0IGNsYXNzIENvbmZpZ1N0YXRlIHtcbiAgcHJpdmF0ZSBfY29uZmlnOiBDeXByZXNzLlJlc29sdmVkQ29uZmlnT3B0aW9ucyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHVibGljIHNldENvbmZpZyhjOiB0eXBlb2YgdGhpcy5fY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gYztcbiAgfVxuICBwdWJsaWMgZ2V0Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBJbnN0YW5jZUlkIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IGVycm9yLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0RmFpbGVkRHVtbXlSZXN1bHQgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuaW1wb3J0IHtcbiAgYmFja2ZpbGxFeGNlcHRpb24sXG4gIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyxcbn0gZnJvbSBcIi4uL3Jlc3VsdHMvbWFwUmVzdWx0XCI7XG5pbXBvcnQgeyBTcGVjUmVzdWx0IH0gZnJvbSBcIi4uL3J1bm5lci9zcGVjLnR5cGVcIjtcblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUgfSBmcm9tIFwiLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpzdGF0ZVwiKTtcblxudHlwZSBJbnN0YW5jZUV4ZWN1dGlvblN0YXRlID0ge1xuICBpbnN0YW5jZUlkOiBJbnN0YW5jZUlkO1xuICBzcGVjOiBzdHJpbmc7XG4gIG91dHB1dD86IHN0cmluZztcbiAgc3BlY0JlZm9yZT86IERhdGU7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgcnVuUmVzdWx0cz86IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0O1xuICBydW5SZXN1bHRzUmVwb3J0ZWRBdD86IERhdGU7XG4gIHNwZWNBZnRlcj86IERhdGU7XG4gIHNwZWNBZnRlclJlc3VsdHM/OiBTcGVjUmVzdWx0O1xuICByZXBvcnRTdGFydGVkQXQ/OiBEYXRlO1xuICBjb3ZlcmFnZUZpbGVQYXRoPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvblN0YXRlIHtcbiAgcHJpdmF0ZSB3YXJuaW5ncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIHN0YXRlOiBSZWNvcmQ8SW5zdGFuY2VJZCwgSW5zdGFuY2VFeGVjdXRpb25TdGF0ZT4gPSB7fTtcblxuICBwdWJsaWMgZ2V0V2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMud2FybmluZ3M7XG4gIH1cblxuICBwdWJsaWMgYWRkV2FybmluZyh3YXJuaW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLndhcm5pbmdzLmFkZCh3YXJuaW5nKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZXN1bHRzKGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUpLm1hcCgoaSkgPT5cbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2VSZXN1bHRzKGNvbmZpZ1N0YXRlLCBpLmluc3RhbmNlSWQpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnN0YW5jZShpbnN0YW5jZUlkOiBJbnN0YW5jZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gIH1cblxuICBwdWJsaWMgZ2V0U3BlYyhzcGVjOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlKS5maW5kKChpKSA9PiBpLnNwZWMgPT09IHNwZWMpO1xuICB9XG5cbiAgcHVibGljIGluaXRJbnN0YW5jZSh7XG4gICAgaW5zdGFuY2VJZCxcbiAgICBzcGVjLFxuICB9OiB7XG4gICAgaW5zdGFuY2VJZDogSW5zdGFuY2VJZDtcbiAgICBzcGVjOiBzdHJpbmc7XG4gIH0pIHtcbiAgICBkZWJ1ZygnSW5pdCBleGVjdXRpb24gc3RhdGUgZm9yIFwiJXNcIicsIHNwZWMpO1xuICAgIHRoaXMuc3RhdGVbaW5zdGFuY2VJZF0gPSB7XG4gICAgICBpbnN0YW5jZUlkLFxuICAgICAgc3BlYyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNCZWZvcmUoc3BlYzogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpLnNwZWNCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNDb3ZlcmFnZShzcGVjOiBzdHJpbmcsIGNvdmVyYWdlRmlsZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVidWcoXCJFeHBlcmltZW50YWw6IGNvdmVyYWdlRmlsZVBhdGggd2FzIHNldFwiKTtcbiAgICBpLmNvdmVyYWdlRmlsZVBhdGggPSBjb3ZlcmFnZUZpbGVQYXRoO1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNBZnRlcihzcGVjOiBzdHJpbmcsIHJlc3VsdHM6IFNwZWNSZXN1bHQpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLnNwZWNBZnRlciA9IG5ldyBEYXRlKCk7XG4gICAgaS5zcGVjQWZ0ZXJSZXN1bHRzID0gcmVzdWx0cztcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjT3V0cHV0KHNwZWM6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEluc3RhbmNlT3V0cHV0KGkuaW5zdGFuY2VJZCwgb3V0cHV0KTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnN0YW5jZU91dHB1dChpbnN0YW5jZUlkOiBzdHJpbmcsIG91dHB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5vdXRwdXQpIHtcbiAgICAgIGRlYnVnKCdJbnN0YW5jZSBcIiVzXCIgYWxyZWFkeSBoYXMgb3V0cHV0JywgaW5zdGFuY2VJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGkub3V0cHV0ID0gb3V0cHV0O1xuICB9XG5cbiAgcHVibGljIHNldEluc3RhbmNlUmVzdWx0KFxuICAgIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gICAgcmVzdWx0czogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbiAgKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLnJ1blJlc3VsdHMgPSByZXN1bHRzO1xuICAgIGkucnVuUmVzdWx0c1JlcG9ydGVkQXQgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIGdldEluc3RhbmNlUmVzdWx0cyhcbiAgICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gICAgaW5zdGFuY2VJZDogc3RyaW5nXG4gICk6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRJbnN0YW5jZShpbnN0YW5jZUlkKTtcblxuICAgIGlmICghaSkge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgXCIlc1wiJywgaW5zdGFuY2VJZCk7XG5cbiAgICAgIHJldHVybiBnZXRGYWlsZWREdW1teVJlc3VsdChjb25maWdTdGF0ZSwge1xuICAgICAgICBzcGVjczogW1widW5rbm93blwiXSxcbiAgICAgICAgZXJyb3I6IFwiQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZVwiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdXNlIHNwZWM6YWZ0ZXIgcmVzdWx0cyAtIGl0IGNhbiBiZWNvbWUgYXZhaWxhYmxlIGJlZm9yZSBydW4gcmVzdWx0c1xuICAgIGlmIChpLnNwZWNBZnRlclJlc3VsdHMpIHtcbiAgICAgIHJldHVybiBiYWNrZmlsbEV4Y2VwdGlvbihcbiAgICAgICAgc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzKGNvbmZpZ1N0YXRlLCBpLnNwZWNBZnRlclJlc3VsdHMpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpLnJ1blJlc3VsdHMpIHtcbiAgICAgIHJldHVybiBiYWNrZmlsbEV4Y2VwdGlvbihpLnJ1blJlc3VsdHMpO1xuICAgIH1cblxuICAgIGRlYnVnKCdObyByZXN1bHRzIGRldGVjdGVkIGZvciBcIiVzXCInLCBpLnNwZWMpO1xuICAgIHJldHVybiBnZXRGYWlsZWREdW1teVJlc3VsdChjb25maWdTdGF0ZSwge1xuICAgICAgc3BlY3M6IFtpLnNwZWNdLFxuICAgICAgZXJyb3I6IGBObyByZXN1bHRzIGRldGVjdGVkIGZvciB0aGUgc3BlYyBmaWxlLiBUaGF0IHVzdWFsbHkgaGFwcGVucyBiZWNhdXNlIG9mIGN5cHJlc3MgY3Jhc2guIFNlZSB0aGUgY29uc29sZSBvdXRwdXQgZm9yIGRldGFpbHMuYCxcbiAgICB9KTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEN5cHJlc3NSdW4sXG4gIEN5cHJlc3NTY3JlZW5zaG90LFxuICBDeXByZXNzVGVzdCxcbiAgQ3lwcmVzc1Rlc3RBdHRlbXB0LFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuXG5pbXBvcnQgKiBhcyBTcGVjQWZ0ZXIgZnJvbSBcIi4uL3J1bm5lci9zcGVjLnR5cGVcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5pbXBvcnQgeyBnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24gfSBmcm9tIFwiLi9yZXN1bHRzXCI7XG5cbmZ1bmN0aW9uIGdldFNjcmVlbnNob3QoczogU3BlY0FmdGVyLlNjcmVlbnNob3QpOiBDeXByZXNzU2NyZWVuc2hvdCB7XG4gIHJldHVybiB7XG4gICAgLi4ucyxcbiAgICBuYW1lOiBzLm5hbWUgPz8gXCJzY3JlZW5zaG90XCIsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRlc3RBdHRlbXB0KFxuICBhdHRlbXB0OiBTcGVjQWZ0ZXIuVGVzdEF0dGVtcHQsXG4gIHNjcmVlbnNob3RzOiBTcGVjQWZ0ZXIuU2NyZWVuc2hvdFtdXG4pOiBDeXByZXNzVGVzdEF0dGVtcHQge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGVtcHQsXG4gICAgc3RhcnRlZEF0OiBhdHRlbXB0LndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICBkdXJhdGlvbjogYXR0ZW1wdC53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICBzY3JlZW5zaG90czogc2NyZWVuc2hvdHMubWFwKGdldFNjcmVlbnNob3QpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUZXN0KFxuICB0OiBTcGVjQWZ0ZXIuVGVzdCxcbiAgc2NyZWVuc2hvdHM6IFNwZWNBZnRlci5TY3JlZW5zaG90W11cbik6IEN5cHJlc3NUZXN0IHtcbiAgY29uc3QgX3NjcmVlbnNob3RzID0gc2NyZWVuc2hvdHMuZmlsdGVyKChzKSA9PiBzLnRlc3RJZCA9PT0gdC50ZXN0SWQpO1xuICByZXR1cm4ge1xuICAgIC4uLnQsXG4gICAgYXR0ZW1wdHM6IHQuYXR0ZW1wdHMubWFwKChhLCBpKSA9PlxuICAgICAgZ2V0VGVzdEF0dGVtcHQoXG4gICAgICAgIGEsXG4gICAgICAgIF9zY3JlZW5zaG90cy5maWx0ZXIoKHMpID0+IHMudGVzdEF0dGVtcHRJbmRleCA9PT0gaSlcbiAgICAgIClcbiAgICApLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIHNwZWNBZnRlclJlc3VsdDogU3BlY0FmdGVyLlNwZWNSZXN1bHRcbik6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnOiBjb25maWdTdGF0ZS5nZXRDb25maWcoKSxcbiAgICB0b3RhbER1cmF0aW9uOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRHVyYXRpb24sXG4gICAgdG90YWxTdWl0ZXM6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5zdWl0ZXMsXG4gICAgdG90YWxUZXN0czogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnRlc3RzLFxuICAgIHRvdGFsRmFpbGVkOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMuZmFpbHVyZXMsXG4gICAgdG90YWxQYXNzZWQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5wYXNzZXMsXG4gICAgdG90YWxQZW5kaW5nOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMucGVuZGluZyxcbiAgICB0b3RhbFNraXBwZWQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5za2lwcGVkLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgIGVuZGVkVGVzdHNBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0VuZGVkQXQsXG4gICAgcnVuczogW1xuICAgICAge1xuICAgICAgICBzdGF0czoge1xuICAgICAgICAgIC4uLnNwZWNBZnRlclJlc3VsdC5zdGF0cyxcbiAgICAgICAgICBzdGFydGVkQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgICAgICAgZW5kZWRBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0VuZGVkQXQsXG4gICAgICAgICAgZHVyYXRpb246IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgcmVwb3J0ZXI6IHNwZWNBZnRlclJlc3VsdC5yZXBvcnRlcixcbiAgICAgICAgcmVwb3J0ZXJTdGF0czogc3BlY0FmdGVyUmVzdWx0LnJlcG9ydGVyU3RhdHMgPz8ge30sXG4gICAgICAgIHNwZWM6IHNwZWNBZnRlclJlc3VsdC5zcGVjLFxuICAgICAgICBlcnJvcjogc3BlY0FmdGVyUmVzdWx0LmVycm9yLFxuICAgICAgICB2aWRlbzogc3BlY0FmdGVyUmVzdWx0LnZpZGVvLFxuICAgICAgICBzaG91bGRVcGxvYWRWaWRlbzogdHJ1ZSwgLy8gbm90IHJlYWxseSB1c2VkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gd3JvbmcgdHlwZWRlZiBmb3IgQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbiAgICAgICAgLy8gYWN0dWFsIEhvb2tOYW1lIGlzIFwiYmVmb3JlIGFsbFwiIHwgXCJiZWZvcmUgZWFjaFwiIHwgXCJhZnRlciBhbGxcIiB8IFwiYWZ0ZXIgZWFjaFwiXG4gICAgICAgIGhvb2tzOiBzcGVjQWZ0ZXJSZXN1bHQuaG9va3MsXG4gICAgICAgIHRlc3RzOiAoc3BlY0FmdGVyUmVzdWx0LnRlc3RzID8/IFtdKS5tYXAoKHQpID0+XG4gICAgICAgICAgZ2V0VGVzdCh0LCBzcGVjQWZ0ZXJSZXN1bHQuc2NyZWVuc2hvdHMpXG4gICAgICAgICksXG4gICAgICB9LFxuICAgIF0sXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBiYWNrZmlsbEV4Y2VwdGlvbiA9IChcbiAgcmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFxuKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdWx0LFxuICAgIHJ1bnM6IHJlc3VsdC5ydW5zLm1hcChiYWNrZmlsbEV4Y2VwdGlvblJ1biksXG4gIH07XG59O1xuXG5jb25zdCBiYWNrZmlsbEV4Y2VwdGlvblJ1biA9IChydW46IEN5cHJlc3NSdW4pID0+IHtcbiAgaWYgKCFydW4uZXJyb3IpIHtcbiAgICByZXR1cm4gcnVuO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ydW4sXG4gICAgdGVzdHM6IFtnZXRGYWtlVGVzdEZyb21FeGNlcHRpb24ocnVuLmVycm9yLCBydW4uc3RhdHMpXSxcbiAgfTtcbn07XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vY2xpXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wcm9ncmFtXCI7XG4iLCAiaW1wb3J0IHsgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLCBUZXN0aW5nVHlwZSB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBhY3RpdmF0ZURlYnVnIH0gZnJvbSBcIi4uLy4uL2xpYi9kZWJ1Z1wiO1xuaW1wb3J0IHsgc2FuaXRpemVBbmRDb252ZXJ0TmVzdGVkQXJncyB9IGZyb20gXCIuL3BhcnNlclwiO1xuaW1wb3J0IHsgcHJvZ3JhbSB9IGZyb20gXCIuL3Byb2dyYW1cIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmNsaVwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ0xJT3B0aW9ucyhcbiAgX3Byb2dyYW06IHR5cGVvZiBwcm9ncmFtID0gcHJvZ3JhbSxcbiAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgcHJvZ3JhbS5wYXJzZT5cbikge1xuICBjb25zdCBvcHRzID0gX3Byb2dyYW0ucGFyc2UoLi4uYXJncykub3B0cygpO1xuXG4gIGFjdGl2YXRlRGVidWcob3B0cy5jbG91ZERlYnVnKTtcbiAgZGVidWcoXCJwYXJzZWQgQ0xJIGZsYWdzICVvXCIsIG9wdHMpO1xuXG4gIGNvbnN0IHsgZTJlLCBjb21wb25lbnQgfSA9IG9wdHM7XG4gIGlmIChlMmUgJiYgY29tcG9uZW50KSB7XG4gICAgX3Byb2dyYW0uZXJyb3IoXCJDYW5ub3QgdXNlIGJvdGggZTJlIGFuZCBjb21wb25lbnQgb3B0aW9uc1wiKTtcbiAgfVxuXG4gIHJldHVybiBnZXRSdW5QYXJhbWV0ZXJzRnJvbUNMSShvcHRzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBDTEkgb3B0aW9ucyBpbnRvIHRoZSBmb3JtYXQgdGhhdCB0aGUgYHJ1bmAgQVBJIGV4cGVjdHNcbiAqXG4gKiBAcGFyYW0gY2xpT3B0aW9uc1xuICogQHJldHVybnMgQ3VycmVudHMgcnVuIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1blBhcmFtZXRlcnNGcm9tQ0xJKFxuICBjbGlPcHRpb25zOiBSZXR1cm5UeXBlPHR5cGVvZiBwcm9ncmFtLm9wdHM+XG4pOiBDdXJyZW50c1J1blBhcmFtZXRlcnMge1xuICBjb25zdCB7IGNvbXBvbmVudCwgZTJlLCAuLi5yZXN0T3B0aW9ucyB9ID0gY2xpT3B0aW9ucztcbiAgY29uc3QgdGVzdGluZ1R5cGU6IFRlc3RpbmdUeXBlID0gY29tcG9uZW50ID8gXCJjb21wb25lbnRcIiA6IFwiZTJlXCI7XG5cbiAgY29uc3QgcmVzdWx0OiBQYXJ0aWFsPEN1cnJlbnRzUnVuUGFyYW1ldGVycz4gPSB7XG4gICAgLi4ucmVzdE9wdGlvbnMsXG4gICAgY29uZmlnOiBzYW5pdGl6ZUFuZENvbnZlcnROZXN0ZWRBcmdzKGNsaU9wdGlvbnMuY29uZmlnLCBcImNvbmZpZ1wiKSxcbiAgICBlbnY6IHNhbml0aXplQW5kQ29udmVydE5lc3RlZEFyZ3MoY2xpT3B0aW9ucy5lbnYsIFwiZW52XCIpLFxuICAgIHJlcG9ydGVyT3B0aW9uczogc2FuaXRpemVBbmRDb252ZXJ0TmVzdGVkQXJncyhcbiAgICAgIGNsaU9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLFxuICAgICAgXCJyZXBvcnRlck9wdGlvbnNcIlxuICAgICksXG4gICAgdGVzdGluZ1R5cGUsXG4gICAgcmVjb3JkS2V5OiBjbGlPcHRpb25zLmtleSxcbiAgfTtcblxuICBkZWJ1ZyhcInBhcnNlZCBydW4gcGFyYW1zOiAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIiwgIi8qISBAcHJlc2VydmVcblxuIyMjIE1JVFxuXG5QYXJ0cyBvZiB0aGlzIGNvZGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MgYW5kIGlzIHN1YmplY3QgdG8gTUlUIGxpY2Vuc2UuXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAyMiBDeXByZXNzLmlvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBhc3NlcnQgZnJvbSBcIm5vZGU6YXNzZXJ0XCI7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCIuLi8uLi9saWIvbG9nXCI7XG5cbmNvbnN0IG5lc3RlZE9iamVjdHNJbkN1cmx5QnJhY2VzUmUgPSAvXFx7KC4rPylcXH0vZztcbmNvbnN0IG5lc3RlZEFycmF5c0luU3F1YXJlQnJhY2tldHNSZSA9IC9cXFsoLis/KVxcXS9nO1xuY29uc3QgZXZlcnl0aGluZ0FmdGVyRmlyc3RFcXVhbFJlID0gLz0oLiopLztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2FmYjY2YWJjNzAyM2NlNzFlMjg5M2NiNmRlNjdkMjQ3MDZmZjdhMWYvcGFja2FnZXMvc2VydmVyL2xpYi91dGlsL2FyZ3MuanMjTDE2MlxuZXhwb3J0IGNvbnN0IHNhbml0aXplQW5kQ29udmVydE5lc3RlZEFyZ3MgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgc3RyOiB1bmtub3duLFxuICBhcmdOYW1lOiB1bmtub3duXG4pOiBUIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KF8uaXNTdHJpbmcoYXJnTmFtZSkgJiYgYXJnTmFtZS50cmltKCkgIT09IFwiXCIpO1xuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBzdHIgYXMgVDtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGlzIHZhbGlkIEpTT04gdGhlbiBqdXN0XG4gICAgLy8gcGFyc2UgaXQgYW5kIGNhbGwgaXQgYSBkYXlcbiAgICBjb25zdCBwYXJzZWQgPSB0cnlKU09OUGFyc2Uoc3RyIGFzIHN0cmluZyk7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIC8vIGludmFsaWQgSlNPTiwgc28gYXNzdW1lIG1peGVkIHVzYWdlXG4gICAgLy8gZmlyc3QgZmluZCBmb289e2E6YixiOmN9IGFuZCBiYXI9WzEsMiwzXVxuICAgIC8vIHN5bnRheCBhbmQgdHVybiB0aG9zZSBpbnRvXG4gICAgLy8gZm9vOiBhOmJ8YjpjXG4gICAgLy8gYmFyOiAxfDJ8M1xuXG4gICAgcmV0dXJuIF8uY2hhaW4oc3RyKVxuICAgICAgLnJlcGxhY2UobmVzdGVkT2JqZWN0c0luQ3VybHlCcmFjZXNSZSwgY29tbWFzVG9QaXBlcylcbiAgICAgIC5yZXBsYWNlKG5lc3RlZEFycmF5c0luU3F1YXJlQnJhY2tldHNSZSwgY29tbWFzVG9QaXBlcylcbiAgICAgIC5zcGxpdChcIixcIilcbiAgICAgIC5tYXAoKHBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhaXIuc3BsaXQoZXZlcnl0aGluZ0FmdGVyRmlyc3RFcXVhbFJlKTtcbiAgICAgIH0pXG4gICAgICAuZnJvbVBhaXJzKClcbiAgICAgIC5tYXBWYWx1ZXMoSlNPTk9yQ29lcmNlKVxuICAgICAgLnZhbHVlKCkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gYXMgVDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IoXCJjb3VsZCBub3QgcGFyc2UgQ0xJIG9wdGlvbiAnJXMnIHZhbHVlOiAlc1wiLCBhcmdOYW1lLCBzdHIpO1xuICAgIGVycm9yKFwiZXJyb3IgJW9cIiwgZXJyKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5jb25zdCB0cnlKU09OUGFyc2UgPSAoc3RyOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpID09PSBJbmZpbml0eSA/IG51bGwgOiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5jb25zdCBjb21tYXNUb1BpcGVzID0gKG1hdGNoOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIG1hdGNoLnNwbGl0KFwiLFwiKS5qb2luKFwifFwiKTtcbn07XG5cbi8vIGZvbz1iYXIsdmVyc2lvbj0xLjIuM1xuY29uc3QgcGlwZXNUb0NvbW1hcyA9IChzdHI6IHN0cmluZykgPT4ge1xuICByZXR1cm4gc3RyLnNwbGl0KFwifFwiKS5qb2luKFwiLFwiKTtcbn07XG5cbmNvbnN0IEpTT05PckNvZXJjZSA9IChzdHI6IHN0cmluZykgPT4ge1xuICAvLyB2YWxpZCBKU09OPyBob3JyYXlcbiAgY29uc3QgcGFyc2VkID0gdHJ5SlNPTlBhcnNlKHN0cik7XG5cbiAgaWYgKHBhcnNlZCkge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvLyBjb252ZXJ0IGJhcnMgYmFjayB0byBjb21tYXNcbiAgc3RyID0gcGlwZXNUb0NvbW1hcyhzdHIpO1xuXG4gIC8vIHRyeSB0byBwYXJzZSBhZ2Fpbj9cbiAgY29uc3QgcGFyc2VkMiA9IHRyeUpTT05QYXJzZShzdHIpO1xuXG4gIGlmIChwYXJzZWQyKSB7XG4gICAgcmV0dXJuIHBhcnNlZDI7XG4gIH1cblxuICAvLyBudXBlIDotKFxuICByZXR1cm4gY29lcmNlKHN0cik7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgY29uc3QgbnVtID0gXy50b051bWJlcih2YWx1ZSk7XG5cbiAgaWYgKF8uaW52b2tlKG51bSwgXCJ0b1N0cmluZ1wiKSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG5cbiAgY29uc3QgYm9vbCA9IHRvQm9vbGVhbih2YWx1ZSk7XG5cbiAgaWYgKF8uaW52b2tlKGJvb2wsIFwidG9TdHJpbmdcIikgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH1cblxuICBjb25zdCBvYmogPSB0cnlKU09OUGFyc2UodmFsdWUpO1xuXG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjb25zdCBhcnIgPSBfLnRvQXJyYXkodmFsdWUpO1xuXG4gIGlmIChfLmludm9rZShhcnIsIFwidG9TdHJpbmdcIikgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vY3VycmVudHMtZGV2L2N5cHJlc3MtY2xvdWQvaXNzdWVzLzcxXG4vLyBrZWVwIHRoZSBsb2NhbCBjb3B5IHRvIHByZXZlbnQgZnJvbSBpbXBvcnRpbmdcbi8vIGNvbW1hbmRlci5qcyBmcm9tIHRoZSBnbG9iYWwgbm9kZV9tb2R1bGVzXG5pbXBvcnQgeyBnZXRMZWdhbE5vdGljZSB9IGZyb20gXCIuLi8uLi9sZWdhbFwiO1xuaW1wb3J0IHsgRGVidWdNb2RlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tIFwiLi9AY29tbWFuZGVyLWpzL2V4dHJhLXR5cGluZ3NcIjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVByb2dyYW0gPSAoY29tbWFuZDogQ29tbWFuZCA9IG5ldyBDb21tYW5kKCkpID0+XG4gIGNvbW1hbmRcbiAgICAubmFtZShcImN5cHJlc3MtY2xvdWRcIilcbiAgICAuZGVzY3JpcHRpb24oXG4gICAgICBgXG5SdW4gQ3lwcmVzcyB0ZXN0cyBvbiBDSSB1c2luZyBodHRwczovL2N1cnJlbnRzLmRldiBvciBodHRwczovL3NvcnJ5LWN5cHJlc3MuZGV2IGFzIGFuIG9yY2hlc3RyYXRpb24gYW5kIHJlcG9ydGluZyBzZXJ2aWNlXG5cbiR7Z2V0TGVnYWxOb3RpY2UoKX1cbiAgICAgIGBcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLWIsIC0tYnJvd3NlciA8YnJvd3Nlci1uYW1lLW9yLXBhdGg+XCIsXG4gICAgICBcInJ1bnMgQ3lwcmVzcyBpbiB0aGUgYnJvd3NlciB3aXRoIHRoZSBnaXZlbiBuYW1lOyBpZiBhIGZpbGVzeXN0ZW0gcGF0aCBpcyBzdXBwbGllZCwgQ3lwcmVzcyB3aWxsIGF0dGVtcHQgdG8gdXNlIHRoZSBicm93c2VyIGF0IHRoYXQgcGF0aFwiXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi0tY2ktYnVpbGQtaWQgPGlkPlwiLFxuICAgICAgXCJ0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGEgcnVuLCB0aGlzIHZhbHVlIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIG1vc3QgQ0kgcHJvdmlkZXJzXCJcbiAgICApXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXCItLWNvbXBvbmVudFwiLCBcInJ1bnMgQ3lwcmVzcyBjb21wb25lbnQgdGVzdFwiKVxuICAgICAgICAuZGVmYXVsdChmYWxzZSlcbiAgICAgICAgLmltcGxpZXMoe1xuICAgICAgICAgIGUyZTogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi1jLCAtLWNvbmZpZyA8Y29uZmlnPlwiLFxuICAgICAgXCJzZXRzIEN5cHJlc3MgY29uZmlndXJhdGlvbiB2YWx1ZXMuIHNlcGFyYXRlIG11bHRpcGxlIHZhbHVlcyB3aXRoIGEgY29tbWEuIG92ZXJyaWRlcyBhbnkgdmFsdWUgaW4gY3lwcmVzcy5jb25maWcue2pzLHRzLG1qcyxjanN9XCJcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLWUsIC0tZW52IDxlbnY+XCIsXG4gICAgICBcInNldHMgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBzZXBhcmF0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aCBhIGNvbW1hLiBvdmVycmlkZXMgYW55IHZhbHVlIGluIGN5cHJlc3MuY29uZmlnLntqcyx0cyxtanMsY2pzfSBvciBjeXByZXNzLmVudi5qc29uXCJcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLUMsIC0tY29uZmlnLWZpbGUgPGNvbmZpZy1maWxlPlwiLFxuICAgICAgJ3NwZWNpZnkgQ3lwcmVzcyBjb25maWcgZmlsZSwgcGF0aCB0byBzY3JpcHQgZmlsZSB3aGVyZSBDeXByZXNzIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGFyZSBzZXQuIGRlZmF1bHRzIHRvIFwiY3lwcmVzcy5jb25maWcue2pzLHRzLG1qcyxjanN9XCInXG4gICAgKVxuICAgIC5hZGRPcHRpb24obmV3IE9wdGlvbihcIi0tZTJlXCIsIFwicnVucyBlbmQgdG8gZW5kIHRlc3RzXCIpLmRlZmF1bHQodHJ1ZSkpXG4gICAgLm9wdGlvbihcIi0tZ3JvdXAgPG5hbWU+XCIsIFwiYSBuYW1lZCBncm91cCBmb3IgcmVjb3JkZWQgcnVucyBpbiBDdXJyZW50c1wiKVxuICAgIC5hZGRPcHRpb24oXG4gICAgICBuZXcgT3B0aW9uKFxuICAgICAgICBcIi1rLCAtLWtleSA8cmVjb3JkLWtleT5cIixcbiAgICAgICAgXCJ5b3VyIHNlY3JldCBSZWNvcmQgS2V5IG9idGFpbmVkIGZyb20gQ3VycmVudHMuIHlvdSBjYW4gb21pdCB0aGlzIGlmIHlvdSBzZXQgYSBDVVJSRU5UU19SRUNPUkRfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXCJcbiAgICAgICkuZW52KFwiQ1VSUkVOVFNfUkVDT1JEX0tFWVwiKVxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItLXBhcmFsbGVsXCIsXG4gICAgICBcImVuYWJsZXMgY29uY3VycmVudCBydW5zIGFuZCBhdXRvbWF0aWMgbG9hZCBiYWxhbmNpbmcgb2Ygc3BlY3MgYWNyb3NzIG11bHRpcGxlIG1hY2hpbmVzIG9yIHByb2Nlc3Nlc1wiLFxuICAgICAgZmFsc2VcbiAgICApXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXG4gICAgICAgIFwiLXAsIC0tcG9ydCA8bnVtYmVyPlwiLFxuICAgICAgICBcInJ1bnMgQ3lwcmVzcyBvbiBhIHNwZWNpZmljIHBvcnQuIG92ZXJyaWRlcyBhbnkgdmFsdWUgaW4gY3lwcmVzcy5jb25maWcue2pzLHRzLG1qcyxjanN9XCJcbiAgICAgICkuYXJnUGFyc2VyKChpKSA9PiBwYXJzZUludChpLCAxMCkpXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi1QLCAtLXByb2plY3QgPHByb2plY3QtcGF0aD5cIixcbiAgICAgIFwicGF0aCB0byB5b3VyIEN5cHJlc3MgcHJvamVjdCByb290IGxvY2F0aW9uIC0gZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcIlxuICAgIClcbiAgICAub3B0aW9uKFwiLXEsIC0tcXVpZXRcIiwgXCJzdXBwcmVzcyB2ZXJib3NlIG91dHB1dCBmcm9tIEN5cHJlc3NcIilcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcbiAgICAgICAgXCItLXJlY29yZCBbYm9vbF1cIixcbiAgICAgICAgXCJyZWNvcmRzIHRoZSBydW4gYW5kIHNlbmRzIHRlc3QgcmVzdWx0cywgc2NyZWVuc2hvdHMgYW5kIHZpZGVvcyB0byBDdXJyZW50c1wiXG4gICAgICApXG4gICAgICAgIC5kZWZhdWx0KHRydWUpXG4gICAgICAgIC5hcmdQYXJzZXIoKGkpID0+IChpID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHRydWUpKVxuICAgIClcbiAgICAub3B0aW9uKFxuICAgICAgXCItciwgLS1yZXBvcnRlciA8cmVwb3J0ZXI+XCIsXG4gICAgICAndXNlIGEgc3BlY2lmaWMgbW9jaGEgcmVwb3J0ZXIgZm9yIEN5cHJlc3MsIHBhc3MgYSBwYXRoIHRvIHVzZSBhIGN1c3RvbSByZXBvcnRlciwgZGVmYXVsdHMgdG8gXCJzcGVjXCInXG4gICAgKVxuICAgIC5vcHRpb24oXG4gICAgICBcIi1vLCAtLXJlcG9ydGVyLW9wdGlvbnMgPHJlcG9ydGVyLW9wdGlvbnM+XCIsXG4gICAgICAnb3B0aW9ucyBmb3IgdGhlIG1vY2hhIHJlcG9ydGVyLiBkZWZhdWx0cyB0byBcIm51bGxcIidcbiAgICApXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXG4gICAgICAgIFwiLXMsIC0tc3BlYyA8c3BlYy1wYXR0ZXJuPlwiLFxuICAgICAgICAnZGVmaW5lIHNwZWNpZmljIGdsb2IgcGF0dGVybiBmb3IgcnVubmluZyB0aGUgc3BlYyBmaWxlKHMpLCBEZWZhdWx0cyB0byB0aGUgXCJzcGVjTWF0Y2hcIiBlbnRyeSBmcm9tIHRoZSBcImN5cHJlc3MuY29uZmlnLntqcyx0cyxtanMsY2pzfVwiIGZpbGUnXG4gICAgICApLmFyZ1BhcnNlcihwYXJzZUNvbW1hU2VwYXJhdGVkTGlzdClcbiAgICApXG4gICAgLm9wdGlvbihcbiAgICAgIFwiLXQsIC0tdGFnIDx0YWc+XCIsXG4gICAgICBcImNvbW1hLXNlcGFyYXRlZCB0YWcocykgZm9yIHJlY29yZGVkIHJ1bnMgaW4gQ3VycmVudHNcIixcbiAgICAgIHBhcnNlQ29tbWFTZXBhcmF0ZWRMaXN0XG4gICAgKVxuICAgIC5hZGRPcHRpb24oXG4gICAgICBuZXcgT3B0aW9uKFxuICAgICAgICBcIi0tYXV0by1jYW5jZWwtYWZ0ZXItZmFpbHVyZXMgPG51bWJlciB8IGZhbHNlPlwiLFxuICAgICAgICBcIkF1dG9tYXRpY2FsbHkgYWJvcnQgdGhlIHJ1biBhZnRlciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBmYWlsZWQgdGVzdHMuIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBwcm9qZWN0IHNldHRpbmdzLiBJZiBzZXQsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yICdmYWxzZScgdG8gZGlzYWJsZSAoQ3VycmVudHMtb25seSlcIlxuICAgICAgKS5hcmdQYXJzZXIocGFyc2VBdXRvQ2FuY2VsRmFpbHVyZXMpXG4gICAgKVxuICAgIC5hZGRPcHRpb24oXG4gICAgICBuZXcgT3B0aW9uKFwiLS1oZWFkZWQgW2Jvb2xdXCIsIFwiUnVuIGN5cHJlc3MgaW4gaGVhZGVkIG1vZGVcIilcbiAgICAgICAgLmRlZmF1bHQoZmFsc2UpXG4gICAgICAgIC5hcmdQYXJzZXIoKGkpID0+IChpID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHRydWUpKVxuICAgIClcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcbiAgICAgICAgXCItLWNsb3VkLWNvbmZpZy1maWxlIDxwYXRoPlwiLFxuICAgICAgICBcIlNwZWNpZnkgdGhlIGNvbmZpZyBmaWxlIGZvciBjeXByZXNzLWNsb3VkLCBkZWZhdWx0cyB0byAnY3VycmVudHMuY29uZmlnLmpzJyBhbmQgd2lsbCBiZSBzZWFyY2hlZCBpbiB0aGUgcHJvamVjdCByb290LCB1bmxlc3MgYW4gYWJzb2x1dGUgcGF0aCBpcyBwcm92aWRlZFwiXG4gICAgICApLmRlZmF1bHQodW5kZWZpbmVkKVxuICAgIClcbiAgICAuYWRkT3B0aW9uKFxuICAgICAgbmV3IE9wdGlvbihcbiAgICAgICAgYC0tY2xvdWQtZGVidWcgW3RydWUgfCBzdHJpbmddYCxcbiAgICAgICAgYEVuYWJsZSBkZWJ1ZyBtb2RlIGZvciBjeXByZXNzLWNsb3VkLCB0aGlzIHdpbGwgcHJpbnQgb3V0IGxvZ3MgZm9yIHRyb3VibGVzaG9vdGluZy4gVmFsdWVzOiBbdHJ1ZSB8ICR7T2JqZWN0LnZhbHVlcyhcbiAgICAgICAgICBEZWJ1Z01vZGVcbiAgICAgICAgKS5qb2luKFxuICAgICAgICAgIFwiIHwgXCJcbiAgICAgICAgKX1dLiBVc2UgY29tbWEgdG8gc2VwYXJhdGUgbXVsdGlwbGUgdmFsdWVzLCBlLmcuIC0tY2xvdWQtZGVidWcgY29tbWl0LWluZm8sY3VycmVudHNgXG4gICAgICApXG4gICAgICAgIC5hcmdQYXJzZXIocGFyc2VDb21tYVNlcGFyYXRlZExpc3QpXG4gICAgICAgIC5kZWZhdWx0KHVuZGVmaW5lZClcbiAgICApXG4gICAgLmFkZE9wdGlvbihcbiAgICAgIG5ldyBPcHRpb24oXG4gICAgICAgIGAtLWV4cGVyaW1lbnRhbC1jb3ZlcmFnZS1yZWNvcmRpbmcgW2Jvb2xdYCxcbiAgICAgICAgYEVuYWJsZSByZWNvcmRpbmcgY292ZXJhZ2UgcmVzdWx0cywgc3BlY2lmeSB0aGUgXCJjb3ZlcmFnZUZpbGVcIiBDeXByZXNzIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciBhIGN1c3RvbSBjb3ZlcmFnZSBmaWxlLCBkZWZhdWx0IGlzIFwiLi8ubnljX291dHB1dC9vdXQuanNvblwiYFxuICAgICAgKVxuICAgICAgICAuZGVmYXVsdCh1bmRlZmluZWQpXG4gICAgICAgIC5hcmdQYXJzZXIoKGkpID0+IChpID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHRydWUpKVxuICAgICk7XG5cbmV4cG9ydCBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG5mdW5jdGlvbiBwYXJzZUNvbW1hU2VwYXJhdGVkTGlzdCh2YWx1ZTogc3RyaW5nLCBwcmV2aW91czogc3RyaW5nW10gPSBbXSkge1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm4gcHJldmlvdXMuY29uY2F0KHZhbHVlLnNwbGl0KFwiLFwiKS5tYXAoKHQpID0+IHQudHJpbSgpKSk7XG4gIH1cbiAgcmV0dXJuIHByZXZpb3VzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUF1dG9DYW5jZWxGYWlsdXJlcyh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHwgZmFsc2Uge1xuICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICBpZiAoaXNOYU4ocGFyc2VkVmFsdWUpIHx8IHBhcnNlZFZhbHVlIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBhcmd1bWVudCBwcm92aWRlZC4gTXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgJ2ZhbHNlJy5cIlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkVmFsdWU7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLFNBQVMscUJBQXFCO0FBQzlCLE9BQU8sVUFBVTtBQUZqQjtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQU0sWUFBWSxVQUFRLFdBQVc7QUFJckMsY0FBVSxPQUFPLFVBQVUsQ0FBQztBQUk1QixZQUFRLFVBQVUsSUFBSSxVQUFVLFFBQVE7QUFNeEMsWUFBUSxXQUFXLFVBQVU7QUFDN0IsWUFBUSxVQUFV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QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUEsTUFFQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxVQUFVO0FBQUEsSUFDVixnQkFBZ0IsUUFBUTtBQUFBLE1BQ3RCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxJQUNELFFBQVEsUUFBUTtBQUFBLE1BQ2Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQUEsSUFDRCxTQUFTO0FBQUE7QUFBQSxJQUVULFNBQVMsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUEsSUFFRCxTQUFTLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUNGO0FBSUEsSUFBTSx3QkFBd0IsTUFBK0I7QUFDM0QsUUFBTSxFQUFFLElBQUksSUFBSTtBQUVoQixTQUFPO0FBQUEsSUFDTCxVQUFVO0FBQUEsTUFDUixLQUFLLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNVCxRQUNFLElBQUksMENBQTBDLElBQUk7QUFBQSxNQUNwRCxTQUFTO0FBQUEsUUFDUDtBQUFBLFFBQ0EsSUFBSTtBQUFB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QUFFQSxRQUFNLGdCQUFnQixPQUFPLGNBQWMsT0FBTztBQUNsRCxNQUFJLGdCQUFnQixHQUFHO0FBQ3JCLFlBQVEsS0FBSyxhQUFhO0FBQUEsRUFDNUI7QUFDQSxVQUFRLEtBQUssQ0FBQztBQUNoQixDQUFDLEVBQ0EsTUFBTSxDQUFDLFFBQVE7QUFDZCxNQUFJLGVBQWUsaUJBQWlCO0FBQ2xDLFlBQVEsTUFBTSxVQUFVLElBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxFQUN6QyxPQUFPO0FBQ0wsWUFBUSxNQUFNLEdBQUc7QUFBQSxFQUNuQjtBQUNBLFVBQVEsS0FBSyxDQUFDO0FBQ2hCLENBQUM7IiwKICAibmFtZXMiOiBbInJlcXVpcmUiLCAicHJvY2VzcyIsICJlcnJvciIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJkZWJ1ZyIsICJsb2ciLCAiRGVidWciLCAiXyIsICJEZWJ1ZyIsICJQIiwgIm1hdGNoIiwgIkRlYnVnIiwgInBhdGgiLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicmVxdWlyZSIsICJzdGRvdXQiLCAiXyIsICJwYXRoIiwgImRlYnVnIiwgIkRlYnVnIiwgIm1hdGNoIiwgIlAiLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgIl8iLCAiXyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImVycm9yIiwgInJlcXVpcmUiLCAiRGVidWciLCAiXyIsICJfIiwgInBsYXRmb3JtIiwgInN0ZG91dCIsICJfIiwgImRlYnVnIiwgIl8iLCAiXyIsICJkZWJ1ZyIsICJkZWJ1Z0ZuIiwgIl8iLCAiZGVidWciLCAiZGVidWdGbiIsICJfIiwgImZzIiwgImpvaW4iLCAicGF0aCIsICJlcnJvciIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiZXJyb3IiLCAiZGVidWciLCAibWF0Y2giLCAiUCIsICJEZWJ1Z01vZGUiLCAibWF0Y2giLCAiUCIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgImVycm9yIiwgInJ1biIsICJfIiwgIl8iLCAiciIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJEZWJ1ZyIsICJmcyIsICJmcyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJmaWxlIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInN0ZG91dCIsICJydW4iLCAiRGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAicGxhdGZvcm0iLCAiZXJyb3IiLCAiRGVidWciLCAicGF0aCIsICJfIiwgInBhdGgiLCAiZmlsZSIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJfIiwgInBhdGgiLCAicGxhdGZvcm0iLCAiZ2V0VGVzdEF0dGVtcHQiLCAicnVuIiwgIkRlYnVnIiwgImRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInBsYXRmb3JtIiwgInJ1biIsICJwcmludFdhcm5pbmdzIiwgInBhdGgiLCAiZXJyb3IiLCAiRGVidWciLCAiXyIsICJfIiwgIm1hdGNoIiwgImRlYnVnIiwgIkRlYnVnIl0KfQo=