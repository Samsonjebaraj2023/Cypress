// index.ts
import "source-map-support/register.js";

// lib/require.ts
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);

// lib/stdout.ts
import cp from "child_process";
var orginal = cp.spawn;
cp.spawn = function(command, args, options) {
  if (command.match(/Cypress/)) {
    const process2 = orginal(command, args, {
      ...options,
      // using pipe enables capturing stdout and stderr
      stdio: ["pipe", "pipe", "pipe"]
    });
    return process2;
  }
  return orginal(command, args, options);
};

// lib/ws/ws.ts
import Debug from "debug";
import http from "http";
import HttpTerminator from "lil-http-terminator";
import { match, P } from "ts-pattern";
import * as WebSocket from "ws";

// lib/pubsub.ts
import EventEmitter from "events";
var pubsub = new EventEmitter();

// lib/ws/ws.ts
var debug = Debug("currents:ws");
var server = null;
var wss = null;
var httpTerminator = null;
var getWSSPort = () => match(server?.address()).with({ port: P.number }, (address) => address.port).otherwise(() => 0);
var stopWSS = async () => {
  debug("terminating wss server: %d", getWSSPort());
  if (!httpTerminator) {
    debug("no wss server");
    return;
  }
  const { success, code, message, error: error2 } = await httpTerminator.terminate();
  if (!success) {
    if (code === "TIMED_OUT")
      error2(message);
    if (code === "SERVER_ERROR")
      error2(message, error2);
    if (code === "INTERNAL_ERROR")
      error2(message, error2);
  }
  debug("terminated wss server: %d", getWSSPort());
};
var startWSS = () => {
  if (wss) {
    return;
  }
  server = http.createServer().on("listening", () => {
    if (!server) {
      throw new Error("Server not initialized");
    }
    wss = new WebSocket.WebSocketServer({
      server
    });
    debug("starting wss on port %d", getWSSPort());
    wss.on("connection", function connection(ws) {
      ws.on("message", function incoming(event) {
        const message = JSON.parse(event.toString());
        pubsub.emit(message.type, message.payload);
      });
    });
  }).listen();
  httpTerminator = HttpTerminator({
    server
  });
};

// lib/capture.ts
import Debug2 from "debug";
var debug2 = Debug2("currents:capture");
var _write = process.stdout.write;
var _log = process.log;
var restore = function() {
  process.stdout.write = _write;
  process.log = _log;
};
var stdout = function() {
  debug2("capturing stdout");
  let logs = [];
  const { write } = process.stdout;
  const { log: log2 } = process;
  if (log2) {
    process.log = function(str) {
      logs.push(str);
      return log2.apply(this, arguments);
    };
  }
  process.stdout.write = function(str) {
    logs.push(str);
    return write.apply(this, arguments);
  };
  return {
    toString() {
      return logs.join("");
    },
    data: logs,
    restore,
    reset: () => {
      debug2("resetting captured stdout");
      logs = [];
    }
  };
};
var initialOutput = "";
var capturedOutput = null;
var initCapture = () => capturedOutput = stdout();
var cutInitialOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  initialOutput = capturedOutput.toString();
  capturedOutput.reset();
};
var resetCapture = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  capturedOutput.reset();
};
var getCapturedOutput = () => {
  if (!capturedOutput)
    throw new Error("capturedOutput is null");
  return capturedOutput.toString();
};
var getInitialOutput = () => initialOutput;

// lib/httpClient/config.ts
import { isAxiosError } from "axios";
var isRetriableError = (err) => {
  if (err.code === "ECONNABORTED") {
    return true;
  }
  if (err.code === "ECONNREFUSED") {
    return true;
  }
  if (err.code === "ETIMEDOUT") {
    return true;
  }
  if (!isAxiosError(err)) {
    return false;
  }
  return !!(err?.response?.status && 500 <= err.response.status && err.response.status < 600);
};
var getDelay = (i) => [5 * 1e3, 10 * 1e3, 30 * 1e3][i - 1];
var baseURL = "https://cy.currents.dev";
var getAPIBaseUrl = () => baseURL ?? "https://cy.currents.dev";
var setAPIBaseUrl = (url) => baseURL = url ?? "https://cy.currents.dev";

// lib/httpClient/httpClient.ts
import axios from "axios";
import axiosRetry from "axios-retry";
import Debug7 from "debug";
import _5 from "lodash";
import prettyMilliseconds from "pretty-ms";

// lib/config/config.ts
import Debug5 from "debug";
import { P as P2, match as match2 } from "ts-pattern";

// lib/bootstrap/bootstrap.ts
import { getBinPath } from "cy2";
import Debug4 from "debug";
import execa from "execa";
import fs from "fs";

// lib/errors.ts
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "";
  }
};

// lib/fs.ts
import { file } from "tmp-promise";
var createTempFile = async () => {
  const { path: path4 } = await file();
  return path4;
};

// lib/log.ts
import chalk from "chalk";
import util from "util";
var log = (...args) => console.log(util.format(...args));
var info = log;
var format = util.format;
var withError = (msg) => chalk.bgRed.white(" ERROR ") + " " + msg;
var withWarning = (msg) => chalk.bgYellow.black(" WARNING ") + " " + msg;
var warn = (...args) => log(withWarning(util.format(...args)));
var error = (...args) => log(withError(util.format(...args)) + "\n");
var title = (color, ...args) => info("\n  " + chalk[color].bold(util.format(...args)) + "  \n");
var divider = () => console.log("\n" + chalk.gray(Array(100).fill("=").join("")) + "\n");
var spacer = (n = 0) => console.log(Array(n).fill("").join("\n"));
var cyan = chalk.cyan;
var blue = chalk.blueBright;
var red = chalk.red;
var green = chalk.greenBright;
var gray = chalk.gray;
var white = chalk.white;
var magenta = chalk.magenta;
var bold = chalk.bold;
var yellow = chalk.yellow;
var dim = chalk.dim;

// lib/bootstrap/serializer.ts
import Debug3 from "debug";
import _ from "lodash";
import { customAlphabet } from "nanoid";
var debug3 = Debug3("currents:boot");
var getDummySpec = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function getBootstrapArgs({
  params,
  tempFilePath
}) {
  return _.chain(getCypressCLIParams(params)).thru((opts) => ({
    ...opts,
    // merge the env with the currents specific env variables
    env: {
      ...opts.env ?? {},
      currents_temp_file: tempFilePath,
      currents_debug_enabled: process.env.DEBUG?.includes("currents:") ? true : false
    }
  })).tap((opts) => {
    debug3("cypress bootstrap params: %o", opts);
  }).thru(serializeOptions).tap((opts) => {
    debug3("cypress bootstrap serialized params: %o", opts);
  }).thru((args) => {
    return [
      ...args,
      "--spec",
      getDummySpec(),
      params.testingType === "component" ? "--component" : "--e2e"
    ];
  }).value();
}
function getCypressCLIParams(params) {
  const result = getCypressRunAPIParams(params);
  const testingType = result.testingType === "component" ? {
    component: true
  } : {};
  return {
    ..._.omit(result, "testingType"),
    ...testingType
  };
}
function serializeOptions(options) {
  return Object.entries(options).flatMap(([key, value]) => {
    const _key = dashed(key);
    if (typeof value === "boolean") {
      return value === true ? [`--${_key}`] : [`--${_key}`, false];
    }
    if (_.isObject(value)) {
      return [`--${_key}`, serializeComplexParam(value)];
    }
    return [`--${_key}`, value.toString()];
  });
}
function serializeComplexParam(param) {
  return JSON.stringify(param);
}
var dashed = (v) => v.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());

// lib/bootstrap/bootstrap.ts
var debug4 = Debug4("currents:boot");
var bootCypress = async (params) => {
  debug4("booting cypress...");
  const tempFilePath = await createTempFile();
  const cypressBin = await getBinPath(require2.resolve("cypress"));
  debug4("cypress executable location: %s", cypressBin);
  const args = getBootstrapArgs({ tempFilePath, params });
  debug4("booting cypress with args: %o", args);
  const { stdout: stdout2, stderr } = await execCypress(cypressBin, args);
  if (!fs.existsSync(tempFilePath)) {
    throw new Error(
      `Cannot resolve cypress configuration from ${tempFilePath}. Please report the issue.`
    );
  }
  try {
    const f = fs.readFileSync(tempFilePath, "utf-8");
    if (!f) {
      throw new Error("Is cypress-cloud/plugin installed?");
    }
    debug4("cypress config '%s': '%s'", tempFilePath, f);
    return JSON.parse(f);
  } catch (err) {
    debug4("read config temp file failed: %o", err);
    info(bold("Cypress stdout:\n"), stdout2);
    info(bold("Cypress stderr:\n"), stderr);
    throw new ValidationError(`Unable to resolve cypress configuration
- make sure that 'cypress-cloud/plugin' is installed
- report the issue together with cypress stdout and stderr
`);
  }
};
async function execCypress(cypressBin, args) {
  let stdout2 = "";
  let stderr = "";
  try {
    await execa(cypressBin, ["run", ...args], {
      stdio: "pipe",
      env: {
        ...process.env,
        // prevent warnings about recording mode
        CYPRESS_RECORD_KEY: void 0,
        CYPRESS_PROJECT_ID: void 0
      }
    });
  } catch (err) {
    debug4("exec cypress failed (certain failures are expected): %o", err);
    stdout2 = err.stdout;
    stderr = err.stderr;
  }
  return { stdout: stdout2, stderr };
}

// lib/config/path.ts
import isAbsolute from "is-absolute";
import _2 from "lodash";
import path from "path";
var defaultFilenames = [
  "currents.config.js",
  "currents.config.cjs",
  "currents.config.mjs"
];
function getConfigFilePath(projectRoot = null, explicitConfigFilePath) {
  const prefix = projectRoot ?? process.cwd();
  if (_2.isString(explicitConfigFilePath) && isAbsolute(explicitConfigFilePath)) {
    return [explicitConfigFilePath];
  }
  if (_2.isString(explicitConfigFilePath)) {
    return [normalizePath(prefix, explicitConfigFilePath)];
  }
  return defaultFilenames.map((p) => normalizePath(prefix, p));
}
function normalizePath(prefix, filename) {
  return `file://${path.resolve(prefix, filename)}`;
}

// lib/config/config.ts
var debug5 = Debug5("currents:config");
var _config = null;
var defaultConfig = {
  e2e: {
    batchSize: 3
  },
  component: {
    batchSize: 5
  },
  cloudServiceUrl: "https://cy.currents.dev",
  networkHeaders: void 0
};
async function getCurrentsConfig(projectRoot, explicitConfigFilePath) {
  if (_config) {
    return _config;
  }
  const configFilePath = getConfigFilePath(projectRoot, explicitConfigFilePath);
  for (const filepath of configFilePath) {
    const config = match2(await loadConfigFile(filepath)).with({ default: P2.not(P2.nullish) }, (c) => c.default).with(P2.not(P2.nullish), (c) => c).otherwise(() => null);
    if (config) {
      debug5("loaded currents config from '%s'\n%O", filepath, config);
      info("Using config file: '%s'", filepath);
      _config = {
        ...defaultConfig,
        ...config
      };
      return _config;
    }
  }
  warn(
    "Failed to load config file, falling back to the default config. Attempted locations: %s",
    configFilePath
  );
  _config = defaultConfig;
  return _config;
}
async function loadConfigFile(filepath) {
  try {
    debug5("loading currents config file from '%s'", filepath);
    return await import(filepath);
  } catch (e) {
    debug5("failed loading config file from: %s", e);
    return null;
  }
}
async function getMergedConfig(params) {
  debug5("resolving cypress config");
  const cypressResolvedConfig = await bootCypress(params);
  debug5("cypress resolvedConfig: %O", cypressResolvedConfig);
  const rawE2EPattern = cypressResolvedConfig.rawJson?.e2e?.specPattern;
  let additionalIgnorePattern = [];
  if (params.testingType === "component" && rawE2EPattern) {
    additionalIgnorePattern = rawE2EPattern;
  }
  const result = {
    projectRoot: cypressResolvedConfig?.projectRoot || process.cwd(),
    projectId: params.projectId,
    specPattern: cypressResolvedConfig?.specPattern || "**/*.*",
    excludeSpecPattern: (
      // @ts-ignore
      cypressResolvedConfig?.resolved.excludeSpecPattern.value ?? []
    ),
    additionalIgnorePattern,
    resolved: cypressResolvedConfig,
    experimentalCoverageRecording: params.experimentalCoverageRecording
  };
  debug5("merged config: %O", result);
  return result;
}

// lib/config/params.ts
import Debug6 from "debug";
import _3 from "lodash";
var debug6 = Debug6("currents:validateParams");
async function resolveCurrentsParams(params) {
  const configFromFile = await getCurrentsConfig(
    params.project,
    params.cloudConfigFile
  );
  debug6("resolving currents params: %o", params);
  debug6("resolving currents config file: %o", configFromFile);
  const cloudServiceUrl = params.cloudServiceUrl ?? process.env.CURRENTS_API_URL ?? configFromFile.cloudServiceUrl;
  const recordKey = params.recordKey ?? process.env.CURRENTS_RECORD_KEY ?? configFromFile.recordKey;
  const projectId = params.projectId ?? process.env.CURRENTS_PROJECT_ID ?? configFromFile.projectId;
  const testingType = params.testingType ?? "e2e";
  const batchSize = testingType === "e2e" ? configFromFile.e2e.batchSize : configFromFile.component.batchSize;
  return {
    ...params,
    cloudServiceUrl,
    recordKey,
    projectId,
    batchSize,
    testingType
  };
}
var projectIdError = `Cannot resolve projectId. Please use one of the following:
- provide it as a "projectId" property for "run" API method
- set CURRENTS_PROJECT_ID environment variable
- set "projectId" in "currents.config.{c}js" file`;
var cloudServiceUrlError = `Cannot resolve cloud service URL. Please use one of the following:
- provide it as a "cloudServiceUrl" property for "run" API method
- set CURRENTS_API_URL environment variable
- set "cloudServiceUrl" in "currents.config.{c}js" file`;
var cloudServiceInvalidUrlError = `Invalid cloud service URL provided`;
var recordKeyError = `Cannot resolve record key. Please use one of the following:

- pass it as a CLI flag '-k, --key <record-key>'
- provide it as a "recordKey" property for "run" API method
- set CURRENTS_RECORD_KEY environment variable
- set "recordKey" in "currents.config.{c}js" file
`;
async function validateParams(_params) {
  const params = await resolveCurrentsParams(_params);
  debug6("validating currents params: %o", params);
  if (!params.cloudServiceUrl) {
    throw new ValidationError(cloudServiceUrlError);
  }
  if (!params.projectId) {
    throw new ValidationError(projectIdError);
  }
  if (!params.recordKey) {
    throw new ValidationError(recordKeyError);
  }
  validateURL(params.cloudServiceUrl);
  const requiredParameters = [
    "testingType",
    "batchSize",
    "projectId"
  ];
  requiredParameters.forEach((key) => {
    if (typeof params[key] === "undefined") {
      error('Missing required parameter "%s"', key);
      throw new Error("Missing required parameter");
    }
  });
  params.tag = parseTags(params.tag);
  params.autoCancelAfterFailures = getAutoCancelValue(
    params.autoCancelAfterFailures
  );
  debug6("validated currents params: %o", params);
  return params;
}
function getAutoCancelValue(value) {
  if (typeof value === "undefined") {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value ? 1 : false;
  }
  if (typeof value === "number" && value > 0) {
    return value;
  }
  throw new ValidationError(
    `autoCancelAfterFailures: should be a positive integer or "false". Got: "${value}"`
  );
}
function isOffline(params) {
  return params.record === false;
}
function parseTags(tagString) {
  if (!tagString) {
    return [];
  }
  if (Array.isArray(tagString)) {
    return tagString.filter(Boolean);
  }
  return tagString.split(",").map((tag) => tag.trim()).filter(Boolean);
}
function validateURL(url) {
  try {
    new URL(url);
  } catch (err) {
    throw new ValidationError(`${cloudServiceInvalidUrlError}: "${url}"`);
  }
}
function getCypressRunAPIParams(params) {
  return {
    ..._3.pickBy(
      _3.omit(params, [
        "cloudDebug",
        "cloudConfigFile",
        "autoCancelAfterFailures",
        "cloudServiceUrl",
        "batchSize",
        "projectId",
        "key",
        "recordKey",
        "record",
        "group",
        "parallel",
        "tag",
        "ciBuildId",
        "spec",
        "exit",
        "headless",
        "experimentalCoverageRecording"
      ]),
      Boolean
    ),
    record: false
  };
}
function preprocessParams(params) {
  return {
    ...params,
    spec: processSpecParam(params.spec)
  };
}
function processSpecParam(spec) {
  if (!spec) {
    return void 0;
  }
  if (Array.isArray(spec)) {
    return _3.flatten(spec.map((i) => i.split(",")));
  }
  return spec.split(",");
}

// lib/httpClient/printErrors.ts
import _4 from "lodash";
function maybePrintErrors(err) {
  if (!err.response?.data || !err.response?.status) {
    return;
  }
  const { message, errors } = err.response.data;
  switch (err.response.status) {
    case 401:
      warn("Received 401 Unauthorized");
      break;
    case 422:
      spacer(1);
      warn(...formatGenericError(message, errors));
      spacer(1);
      break;
    default:
      break;
  }
}
function formatGenericError(message, errors) {
  if (!_4.isString(message)) {
    return ["Unexpected error from the cloud service"];
  }
  if (errors?.length === 0) {
    return [message];
  }
  return [
    message,
    `
${(errors ?? []).map((e) => `  - ${e}`).join("\n")}
`
  ];
}

// lib/httpClient/httpClient.ts
var debug7 = Debug7("currents:api");
var MAX_RETRIES = 3;
var TIMEOUT_MS = 30 * 1e3;
var _client = null;
async function getClient() {
  if (_client) {
    return _client;
  }
  const currentsConfig = await getCurrentsConfig();
  _client = axios.create({
    baseURL: getAPIBaseUrl(),
    timeout: TIMEOUT_MS
  });
  _client.interceptors.request.use((config) => {
    const ccyVerson = _currentsVersion ?? "0.0.0";
    const headers = {
      ...config.headers,
      // @ts-ignore
      "x-cypress-request-attempt": config["axios-retry"]?.retryCount ?? 0,
      "x-cypress-version": _cypressVersion ?? "0.0.0",
      "x-ccy-version": ccyVerson,
      "User-Agent": `cypress-cloud/${ccyVerson}`
    };
    if (_runId) {
      headers["x-cypress-run-id"] = _runId;
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/json";
    }
    if (currentsConfig.networkHeaders) {
      const filteredHeaders = _5.omit(currentsConfig.networkHeaders, [
        "x-cypress-request-attempt",
        "x-cypress-version",
        "x-ccy-version",
        "x-cypress-run-id",
        "Content-Type"
      ]);
      debug7("using custom network headers: %o", filteredHeaders);
      Object.assign(headers, filteredHeaders);
    }
    const req = {
      ...config,
      headers
    };
    debug7("network request: %o", {
      ..._5.pick(req, "method", "url", "headers"),
      data: Buffer.isBuffer(req.data) ? "buffer" : req.data
    });
    return req;
  });
  axiosRetry(_client, {
    retries: MAX_RETRIES,
    retryCondition: isRetriableError,
    retryDelay: getDelay,
    // @ts-ignore
    onRetry,
    shouldResetTimeout: true
  });
  return _client;
}
var _runId = void 0;
var setRunId = (runId) => {
  _runId = runId;
};
var _cypressVersion = void 0;
var setCypressVersion = (cypressVersion) => {
  _cypressVersion = cypressVersion;
};
var _currentsVersion = void 0;
var setCurrentsVersion = (v) => {
  _currentsVersion = v;
};
function onRetry(retryCount, err, config) {
  warn(
    "Network request '%s' failed: '%s'. Next attempt is in %s (%d/%d).",
    `${config.method} ${config.url}`,
    err.message,
    prettyMilliseconds(getDelay(retryCount)),
    retryCount,
    MAX_RETRIES
  );
}
var makeRequest = async (config) => {
  return (await getClient())(config).then((res) => {
    debug7("network response: %o", _5.omit(res, "request", "config"));
    return res;
  }).catch((error2) => {
    maybePrintErrors(error2);
    throw new ValidationError(error2.message);
  });
};

// lib/init.ts
var cypressPkg = require2("cypress/package.json");
var pkg = require2("cypress-cloud/package.json");
initCapture();
setCypressVersion(cypressPkg.version);
setCurrentsVersion(pkg.version);

// lib/run.ts
import Debug19 from "debug";
import plur from "plur";

// legal.ts
function getLegalNotice() {
  return `
Copyright (C) ${(/* @__PURE__ */ new Date()).getFullYear()} Currents Software Inc https://currents.dev
This is free software, and you are welcome to redistribute it under certain
conditions. This program comes with no warranty. Parts of this program are MIT
licensed. Refer to the license for details
https://github.com/currents-dev/cypress-cloud/blob/main/LICENSE.md
`;
}

// lib/api/warnings.ts
import _6 from "lodash";
function printWarnings(warnings) {
  warn("Notice from cloud service:");
  warnings.map((w) => {
    spacer(1);
    info(magenta.bold(w.message));
    Object.entries(_6.omit(w, "message")).map(([key, value]) => {
      info("- %s: %s", key, value);
    });
    spacer(1);
  });
}

// lib/api/api.ts
var createRun = async (payload) => {
  const response = await makeRequest({
    method: "POST",
    url: "/runs",
    data: payload
  });
  if ((response.data.warnings?.length ?? 0) > 0) {
    printWarnings(response.data.warnings);
  }
  return response.data;
};
var createInstance = async ({
  runId,
  groupId,
  machineId,
  platform: platform2
}) => {
  const response = await makeRequest({
    method: "POST",
    url: `runs/${runId}/instances`,
    data: {
      runId,
      groupId,
      machineId,
      platform: platform2
    }
  });
  return response.data;
};
var createBatchedInstances = async (data) => {
  const respone = await makeRequest({
    method: "POST",
    url: `runs/${data.runId}/cy/instances`,
    data
  });
  return respone.data;
};
var setInstanceTests = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/tests`,
  data: payload
}).then((result) => result.data);
var updateInstanceResults = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/results`,
  data: payload
}).then((result) => result.data);
var reportInstanceResultsMerged = (instanceId, payload) => makeRequest({
  method: "POST",
  url: `instances/${instanceId}/cy/results`,
  data: payload
}).then((result) => result.data);
var updateInstanceStdout = (instanceId, stdout2) => makeRequest({
  method: "PUT",
  url: `instances/${instanceId}/stdout`,
  data: {
    stdout: stdout2
  }
});

// lib/ciProvider/ciProvider.ts
import debugFn from "debug";
import _7 from "lodash";
var debug8 = debugFn("currents:ci");
var join = (char, ...pieces) => {
  return _7.chain(pieces).compact().join(char).value();
};
var toCamelObject = (obj, key) => {
  return _7.set(obj, _7.camelCase(key), process.env[key]);
};
var extract = (envKeys) => {
  return _7.transform(envKeys, toCamelObject, {});
};
var isTeamFoundation = () => {
  return process.env.TF_BUILD && process.env.TF_BUILD_BUILDNUMBER;
};
var isAzureCi = () => {
  return process.env.TF_BUILD && process.env.AZURE_HTTP_USER_AGENT;
};
var isAWSCodeBuild = () => {
  return _7.some(process.env, (val, key) => {
    return /^CODEBUILD_/.test(key);
  });
};
var isBamboo = () => {
  return process.env.bamboo_buildNumber;
};
var isCodeshipBasic = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && process.env.CODESHIP;
};
var isCodeshipPro = () => {
  return process.env.CI_NAME && process.env.CI_NAME === "codeship" && !process.env.CODESHIP;
};
var isConcourse = () => {
  return _7.some(process.env, (val, key) => {
    return /^CONCOURSE_/.test(key);
  });
};
var isGitlab = () => {
  return process.env.GITLAB_CI || process.env.CI_SERVER_NAME && /^GitLab/.test(process.env.CI_SERVER_NAME);
};
var isGoogleCloud = () => {
  return process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT;
};
var isJenkins = () => {
  return process.env.JENKINS_URL || process.env.JENKINS_HOME || process.env.JENKINS_VERSION || process.env.HUDSON_URL || process.env.HUDSON_HOME;
};
var isWercker = () => {
  return process.env.WERCKER || process.env.WERCKER_MAIN_PIPELINE_STARTED;
};
var CI_PROVIDERS = {
  appveyor: "APPVEYOR",
  azure: isAzureCi,
  awsCodeBuild: isAWSCodeBuild,
  bamboo: isBamboo,
  bitbucket: "BITBUCKET_BUILD_NUMBER",
  buildkite: "BUILDKITE",
  circle: "CIRCLECI",
  codeshipBasic: isCodeshipBasic,
  codeshipPro: isCodeshipPro,
  concourse: isConcourse,
  codeFresh: "CF_BUILD_ID",
  drone: "DRONE",
  githubActions: "GITHUB_ACTIONS",
  gitlab: isGitlab,
  goCD: "GO_JOB_NAME",
  googleCloud: isGoogleCloud,
  jenkins: isJenkins,
  semaphore: "SEMAPHORE",
  shippable: "SHIPPABLE",
  teamcity: "TEAMCITY_VERSION",
  teamfoundation: isTeamFoundation,
  travis: "TRAVIS",
  wercker: isWercker,
  netlify: "NETLIFY",
  layerci: "LAYERCI"
};
function _detectProviderName() {
  const { env } = process;
  return _7.findKey(CI_PROVIDERS, (value) => {
    if (_7.isString(value)) {
      return env[value];
    }
    if (_7.isFunction(value)) {
      return value();
    }
  });
}
var _providerCiParams = () => {
  return {
    appveyor: extract([
      "APPVEYOR_JOB_ID",
      "APPVEYOR_ACCOUNT_NAME",
      "APPVEYOR_PROJECT_SLUG",
      "APPVEYOR_BUILD_NUMBER",
      "APPVEYOR_BUILD_VERSION",
      "APPVEYOR_PULL_REQUEST_NUMBER",
      "APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH"
    ]),
    azure: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID",
      "BUILD_REPOSITORY_URI"
    ]),
    awsCodeBuild: extract([
      "CODEBUILD_BUILD_ID",
      "CODEBUILD_BUILD_NUMBER",
      "CODEBUILD_RESOLVED_SOURCE_VERSION",
      "CODEBUILD_SOURCE_REPO_URL",
      "CODEBUILD_SOURCE_VERSION"
    ]),
    bamboo: extract([
      "bamboo_buildNumber",
      "bamboo_buildResultsUrl",
      "bamboo_planRepository_repositoryUrl",
      "bamboo_buildKey"
    ]),
    bitbucket: extract([
      "BITBUCKET_REPO_SLUG",
      "BITBUCKET_REPO_OWNER",
      "BITBUCKET_BUILD_NUMBER",
      "BITBUCKET_PARALLEL_STEP",
      "BITBUCKET_STEP_RUN_NUMBER",
      // the PR variables are only set on pull request builds
      "BITBUCKET_PR_ID",
      "BITBUCKET_PR_DESTINATION_BRANCH",
      "BITBUCKET_PR_DESTINATION_COMMIT"
    ]),
    buildkite: extract([
      "BUILDKITE_REPO",
      "BUILDKITE_SOURCE",
      "BUILDKITE_JOB_ID",
      "BUILDKITE_BUILD_ID",
      "BUILDKITE_BUILD_URL",
      "BUILDKITE_BUILD_NUMBER",
      "BUILDKITE_PULL_REQUEST",
      "BUILDKITE_PULL_REQUEST_REPO",
      "BUILDKITE_PULL_REQUEST_BASE_BRANCH"
    ]),
    circle: extract([
      "CIRCLE_JOB",
      "CIRCLE_BUILD_NUM",
      "CIRCLE_BUILD_URL",
      "CIRCLE_PR_NUMBER",
      "CIRCLE_PR_REPONAME",
      "CIRCLE_PR_USERNAME",
      "CIRCLE_COMPARE_URL",
      "CIRCLE_WORKFLOW_ID",
      "CIRCLE_PULL_REQUEST",
      "CIRCLE_REPOSITORY_URL",
      "CI_PULL_REQUEST"
    ]),
    codeshipBasic: extract([
      "CI_BUILD_ID",
      "CI_REPO_NAME",
      "CI_BUILD_URL",
      "CI_PROJECT_ID",
      "CI_BUILD_NUMBER",
      "CI_PULL_REQUEST"
    ]),
    // CodeshipPro provides very few CI variables
    // https://documentation.codeship.com/pro/builds-and-configuration/environment-variables/
    codeshipPro: extract(["CI_BUILD_ID", "CI_REPO_NAME", "CI_PROJECT_ID"]),
    // https://concourse-ci.org/implementing-resource-types.html#resource-metadata
    concourse: extract([
      "BUILD_ID",
      "BUILD_NAME",
      "BUILD_JOB_NAME",
      "BUILD_PIPELINE_NAME",
      "BUILD_TEAM_NAME",
      "ATC_EXTERNAL_URL"
    ]),
    // https://codefresh.io/docs/docs/codefresh-yaml/variables/
    codeFresh: extract([
      "CF_BUILD_ID",
      "CF_BUILD_URL",
      "CF_CURRENT_ATTEMPT",
      "CF_STEP_NAME",
      "CF_PIPELINE_NAME",
      "CF_PIPELINE_TRIGGER_ID",
      // variables added for pull requests
      "CF_PULL_REQUEST_ID",
      "CF_PULL_REQUEST_IS_FORK",
      "CF_PULL_REQUEST_NUMBER",
      "CF_PULL_REQUEST_TARGET"
    ]),
    drone: extract([
      "DRONE_JOB_NUMBER",
      "DRONE_BUILD_LINK",
      "DRONE_BUILD_NUMBER",
      "DRONE_PULL_REQUEST"
    ]),
    // https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
    githubActions: extract([
      "GITHUB_WORKFLOW",
      "GITHUB_ACTION",
      "GITHUB_EVENT_NAME",
      "GITHUB_RUN_ID",
      "GITHUB_RUN_ATTEMPT",
      "GITHUB_REPOSITORY"
    ]),
    // see https://docs.gitlab.com/ee/ci/variables/
    gitlab: extract([
      // pipeline is common among all jobs
      "CI_PIPELINE_ID",
      "CI_PIPELINE_URL",
      // individual jobs
      "CI_BUILD_ID",
      // build id and job id are aliases
      "CI_JOB_ID",
      "CI_JOB_URL",
      "CI_JOB_NAME",
      // other information
      "GITLAB_HOST",
      "CI_PROJECT_ID",
      "CI_PROJECT_URL",
      "CI_REPOSITORY_URL",
      "CI_ENVIRONMENT_URL",
      "CI_DEFAULT_BRANCH"
      // for PRs: https://gitlab.com/gitlab-org/gitlab-ce/issues/23902
    ]),
    // https://docs.gocd.org/current/faq/dev_use_current_revision_in_build.html#standard-gocd-environment-variables
    goCD: extract([
      "GO_SERVER_URL",
      "GO_ENVIRONMENT_NAME",
      "GO_PIPELINE_NAME",
      "GO_PIPELINE_COUNTER",
      "GO_PIPELINE_LABEL",
      "GO_STAGE_NAME",
      "GO_STAGE_COUNTER",
      "GO_JOB_NAME",
      "GO_TRIGGER_USER",
      "GO_REVISION",
      "GO_TO_REVISION",
      "GO_FROM_REVISION",
      "GO_MATERIAL_HAS_CHANGED"
    ]),
    googleCloud: extract([
      // individual jobs
      "BUILD_ID",
      "PROJECT_ID",
      // other information
      "REPO_NAME",
      "BRANCH_NAME",
      "TAG_NAME",
      "COMMIT_SHA",
      "SHORT_SHA"
      // https://cloud.google.com/cloud-build/docs/api/reference/rest/Shared.Types/Build
    ]),
    jenkins: extract(["BUILD_ID", "BUILD_URL", "BUILD_NUMBER", "ghprbPullId"]),
    // https://semaphoreci.com/docs/available-environment-variables.html
    // some come from v1, some from v2 of semaphore
    semaphore: extract([
      "SEMAPHORE_BRANCH_ID",
      "SEMAPHORE_BUILD_NUMBER",
      "SEMAPHORE_CURRENT_JOB",
      "SEMAPHORE_CURRENT_THREAD",
      "SEMAPHORE_EXECUTABLE_UUID",
      "SEMAPHORE_GIT_BRANCH",
      "SEMAPHORE_GIT_DIR",
      "SEMAPHORE_GIT_REF",
      "SEMAPHORE_GIT_REF_TYPE",
      "SEMAPHORE_GIT_REPO_SLUG",
      "SEMAPHORE_GIT_SHA",
      "SEMAPHORE_GIT_URL",
      "SEMAPHORE_JOB_COUNT",
      "SEMAPHORE_JOB_ID",
      // v2
      "SEMAPHORE_JOB_NAME",
      "SEMAPHORE_JOB_UUID",
      // v1
      "SEMAPHORE_PIPELINE_ID",
      "SEMAPHORE_PLATFORM",
      "SEMAPHORE_PROJECT_DIR",
      "SEMAPHORE_PROJECT_HASH_ID",
      "SEMAPHORE_PROJECT_ID",
      // v2
      "SEMAPHORE_PROJECT_NAME",
      "SEMAPHORE_PROJECT_UUID",
      // v1
      "SEMAPHORE_REPO_SLUG",
      "SEMAPHORE_TRIGGER_SOURCE",
      "SEMAPHORE_WORKFLOW_ID",
      "PULL_REQUEST_NUMBER"
      // pull requests from forks ONLY
    ]),
    // see http://docs.shippable.com/ci/env-vars/
    shippable: extract([
      // build variables
      "SHIPPABLE_BUILD_ID",
      // "5b93354cabfabb07007f01fd"
      "SHIPPABLE_BUILD_NUMBER",
      // "4"
      "SHIPPABLE_COMMIT_RANGE",
      // "sha1...sha2"
      "SHIPPABLE_CONTAINER_NAME",
      // "c.exec.cypress-example-kitchensink.4.1"
      "SHIPPABLE_JOB_ID",
      // "1"
      "SHIPPABLE_JOB_NUMBER",
      // "1"
      "SHIPPABLE_REPO_SLUG",
      // "<username>/<repo>"
      // additional information that Shippable provides
      "IS_FORK",
      // "true"
      "IS_GIT_TAG",
      // "false"
      "IS_PRERELEASE",
      // "false"
      "IS_RELEASE",
      // "false"
      "REPOSITORY_URL",
      // "https://github.com/....git"
      "REPO_FULL_NAME",
      // "<username>/<repo>"
      "REPO_NAME",
      // "cypress-example-kitchensink"
      "BUILD_URL",
      // "https://app.shippable.com/github/<username>/<repo>/runs/1"
      // Pull request information
      "BASE_BRANCH",
      // Name of the target branch into which the pull request changes will be merged.
      "HEAD_BRANCH",
      // This is only set for pull requests and is the name of the branch the pull request was opened from.
      "IS_PULL_REQUEST",
      // "false" or "true"
      "PULL_REQUEST",
      // Pull request number if the job is a pull request. If not, this will be set to false.
      "PULL_REQUEST_BASE_BRANCH",
      // Name of the branch that the pull request will be merged into. It should be the same as BASE_BRANCH.
      "PULL_REQUEST_REPO_FULL_NAME"
      // Full name of the repository from where the pull request originated.
    ]),
    teamcity: null,
    teamfoundation: extract([
      "BUILD_BUILDID",
      "BUILD_BUILDNUMBER",
      "BUILD_CONTAINERID"
    ]),
    travis: extract([
      "TRAVIS_JOB_ID",
      "TRAVIS_BUILD_ID",
      "TRAVIS_BUILD_WEB_URL",
      "TRAVIS_REPO_SLUG",
      "TRAVIS_JOB_NUMBER",
      "TRAVIS_EVENT_TYPE",
      "TRAVIS_COMMIT_RANGE",
      "TRAVIS_BUILD_NUMBER",
      "TRAVIS_PULL_REQUEST",
      "TRAVIS_PULL_REQUEST_BRANCH",
      "TRAVIS_PULL_REQUEST_SHA"
    ]),
    wercker: null,
    // https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata
    netlify: extract([
      "BUILD_ID",
      "CONTEXT",
      "URL",
      "DEPLOY_URL",
      "DEPLOY_PRIME_URL",
      "DEPLOY_ID"
    ]),
    // https://layerci.com/docs/layerfile-reference/build-env
    layerci: extract([
      "LAYERCI_JOB_ID",
      "LAYERCI_RUNNER_ID",
      "RETRY_INDEX",
      "LAYERCI_PULL_REQUEST",
      "LAYERCI_REPO_NAME",
      "LAYERCI_REPO_OWNER",
      "LAYERCI_BRANCH",
      "GIT_TAG"
      // short hex for commits
    ])
  };
};
var _providerCommitParams = () => {
  const { env } = process;
  return {
    appveyor: {
      sha: env.APPVEYOR_REPO_COMMIT,
      // since APPVEYOR_REPO_BRANCH will be the target branch on a PR
      // we need to use PULL_REQUEST_HEAD_REPO_BRANCH if it exists.
      // e.g. if you have a PR: develop <- my-feature-branch
      // my-feature-branch is APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH
      // develop           is APPVEYOR_REPO_BRANCH
      branch: env.APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || env.APPVEYOR_REPO_BRANCH,
      message: join(
        "\n",
        env.APPVEYOR_REPO_COMMIT_MESSAGE,
        env.APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
      ),
      authorName: env.APPVEYOR_REPO_COMMIT_AUTHOR,
      authorEmail: env.APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    awsCodeBuild: {
      sha: env.CODEBUILD_RESOLVED_SOURCE_VERSION,
      // branch: ???,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.CODEBUILD_SOURCE_REPO_URL
      // defaultBranch: ???
    },
    azure: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR,
      authorEmail: env.BUILD_REQUESTEDFOREMAIL
    },
    bamboo: {
      sha: env.bamboo_planRepository_revision,
      branch: env.bamboo_planRepository_branch,
      // message: ???
      authorName: env.bamboo_planRepository_username,
      // authorEmail: ???
      remoteOrigin: env.bamboo_planRepository_repositoryURL
      // defaultBranch: ???
    },
    bitbucket: {
      sha: env.BITBUCKET_COMMIT,
      branch: env.BITBUCKET_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    buildkite: {
      sha: env.BUILDKITE_COMMIT,
      branch: env.BUILDKITE_BRANCH,
      message: env.BUILDKITE_MESSAGE,
      authorName: env.BUILDKITE_BUILD_CREATOR,
      authorEmail: env.BUILDKITE_BUILD_CREATOR_EMAIL,
      remoteOrigin: env.BUILDKITE_REPO,
      defaultBranch: env.BUILDKITE_PIPELINE_DEFAULT_BRANCH
    },
    circle: {
      sha: env.CIRCLE_SHA1,
      branch: env.CIRCLE_BRANCH,
      // message: ???
      authorName: env.CIRCLE_USERNAME,
      // authorEmail: ???
      remoteOrigin: env.CIRCLE_REPOSITORY_URL
      // defaultBranch: ???
    },
    codeshipBasic: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeshipPro: {
      sha: env.CI_COMMIT_ID,
      branch: env.CI_BRANCH,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.CI_COMMITTER_NAME,
      authorEmail: env.CI_COMMITTER_EMAIL
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    codeFresh: {
      sha: env.CF_REVISION,
      branch: env.CF_BRANCH,
      message: env.CF_COMMIT_MESSAGE,
      authorName: env.CF_COMMIT_AUTHOR
    },
    drone: {
      sha: env.DRONE_COMMIT_SHA,
      // https://docs.drone.io/pipeline/environment/reference/drone-source-branch/
      branch: env.DRONE_SOURCE_BRANCH,
      message: env.DRONE_COMMIT_MESSAGE,
      authorName: env.DRONE_COMMIT_AUTHOR,
      authorEmail: env.DRONE_COMMIT_AUTHOR_EMAIL,
      remoteOrigin: env.DRONE_GIT_HTTP_URL,
      defaultBranch: env.DRONE_REPO_BRANCH
    },
    githubActions: {
      sha: env.GITHUB_SHA,
      branch: env.GH_BRANCH || env.GITHUB_REF,
      defaultBranch: env.GITHUB_BASE_REF,
      remoteBranch: env.GITHUB_HEAD_REF,
      runAttempt: env.GITHUB_RUN_ATTEMPT
    },
    gitlab: {
      sha: env.CI_COMMIT_SHA,
      branch: env.CI_COMMIT_REF_NAME,
      message: env.CI_COMMIT_MESSAGE,
      authorName: env.GITLAB_USER_NAME,
      authorEmail: env.GITLAB_USER_EMAIL,
      remoteOrigin: env.CI_REPOSITORY_URL,
      defaultBranch: env.CI_DEFAULT_BRANCH
    },
    googleCloud: {
      sha: env.COMMIT_SHA,
      branch: env.BRANCH_NAME
      // message: ??
      // authorName: ??
      // authorEmail: ??
      // remoteOrigin: ???
      // defaultBranch: ??
    },
    jenkins: {
      sha: env.GIT_COMMIT,
      branch: env.GIT_BRANCH
      // message: ???
      // authorName: ???
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    // Only from forks? https://semaphoreci.com/docs/available-environment-variables.html
    semaphore: {
      sha: env.SEMAPHORE_GIT_SHA,
      branch: env.SEMAPHORE_GIT_BRANCH,
      // message: ???
      // authorName: ???
      // authorEmail: ???
      remoteOrigin: env.SEMAPHORE_GIT_REPO_SLUG
      // defaultBranch: ???
    },
    shippable: {
      sha: env.COMMIT,
      branch: env.BRANCH,
      message: env.COMMIT_MESSAGE,
      authorName: env.COMMITTER
      // authorEmail: ???
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    snap: null,
    teamcity: null,
    teamfoundation: {
      sha: env.BUILD_SOURCEVERSION,
      branch: env.BUILD_SOURCEBRANCHNAME,
      message: env.BUILD_SOURCEVERSIONMESSAGE,
      authorName: env.BUILD_SOURCEVERSIONAUTHOR
    },
    travis: {
      sha: env.TRAVIS_PULL_REQUEST_SHA || env.TRAVIS_COMMIT,
      // for PRs, TRAVIS_BRANCH is the base branch being merged into
      branch: env.TRAVIS_PULL_REQUEST_BRANCH || env.TRAVIS_BRANCH,
      // authorName: ???
      // authorEmail: ???
      message: env.TRAVIS_COMMIT_MESSAGE
      // remoteOrigin: ???
      // defaultBranch: ???
    },
    wercker: null,
    netlify: {
      sha: env.COMMIT_REF,
      branch: env.BRANCH,
      remoteOrigin: env.REPOSITORY_URL
    },
    layerci: {
      sha: env.GIT_COMMIT,
      branch: env.LAYERCI_BRANCH,
      message: env.GIT_COMMIT_TITLE
    }
  };
};
var _get = (fn) => {
  const providerName = getCiProvider();
  if (!providerName)
    return {};
  return _7.chain(fn()).get(providerName).value();
};
function checkForCiBuildFromCi(ciProvider) {
  if (ciProvider && detectableCiBuildIdProviders().includes(ciProvider))
    return true;
  throw new ValidationError(
    `Could not determine CI build ID from the environment. Please provide a unique CI build ID using the --ci-build-id CLI flag or 'ciBuildId' parameter for 'run' method.`
  );
}
function detectableCiBuildIdProviders() {
  return _7.chain(_providerCiParams()).omitBy(_7.isNull).keys().value();
}
function getCiProvider() {
  return _detectProviderName() || null;
}
function getCiParams() {
  return _get(_providerCiParams);
}
function getCommitParams() {
  return _get(_providerCommitParams);
}
function getCI(ciBuildId) {
  const params = getCiParams();
  const provider = getCiProvider();
  if (!ciBuildId)
    checkForCiBuildFromCi(provider);
  debug8("detected CI provider: %s", provider);
  debug8("detected CI params: %O", params);
  return {
    params,
    provider
  };
}

// lib/ciProvider/merge.ts
import debugFn2 from "debug";
import _8 from "lodash";
var debug9 = debugFn2("currents:ci");
function getCommitDefaults(existingInfo) {
  debug9("git commit existing info");
  debug9(existingInfo);
  const commitParamsObj = getCommitParams();
  debug9("commit info from provider environment variables: %O", commitParamsObj);
  const combined = _8.transform(
    existingInfo,
    (memo, value, key) => {
      return memo[key] = _8.defaultTo(
        value || (commitParamsObj ? commitParamsObj[key] : null),
        null
      );
    }
  );
  debug9("combined git and environment variables from provider");
  debug9(combined);
  return combined;
}

// lib/coverage/index.ts
import fs2 from "fs/promises";
import { join as join2 } from "path";
var getCoverageFilePath = async (coverageFile = "./.nyc_output/out.json") => {
  const path4 = join2(process.cwd(), coverageFile);
  try {
    await fs2.access(path4);
    return {
      path: path4,
      error: false
    };
  } catch (error2) {
    return {
      path: path4,
      error: error2
    };
  }
};

// lib/cypress/cypress.ts
import cypress from "cypress";
import Debug8 from "debug";
import _9 from "lodash";

// lib/lang.ts
import bluebird from "bluebird";
bluebird.Promise.config({
  cancellation: true
});
var BPromise = bluebird.Promise;
var safe = (fn, ifFaled, ifSucceed) => async (...args) => {
  try {
    const r = await fn(...args);
    ifSucceed();
    return r;
  } catch (e) {
    return ifFaled(e);
  }
};

// lib/cypress/cypress.ts
var debug10 = Debug8("currents:cypress");
function runBareCypress(params = {}) {
  const p = {
    ...params,
    ciBuildId: void 0,
    tag: void 0,
    parallel: void 0,
    record: false,
    group: void 0,
    spec: _9.flatten(params.spec).join(",")
  };
  debug10("Running bare Cypress with params %o", p);
  return cypress.run(p);
}
async function runSpecFile({ spec }, cypressRunOptions) {
  const runAPIOptions = getCypressRunAPIParams(cypressRunOptions);
  const options = {
    ...runAPIOptions,
    config: {
      ...runAPIOptions.config,
      trashAssetsBeforeRuns: false
    },
    env: {
      ...runAPIOptions.env,
      currents_ws: getWSSPort()
    },
    spec
  };
  debug10("running cypress with options %o", options);
  let result = await cypress.run(options);
  let retries = 0;
  const currentsConfig = await getCurrentsConfig();
  while (currentsConfig.retry && retries < (currentsConfig.retry.hardFailureMaxRetries ?? 0) && result.status === "failed") {
    warn("Cypress runner failed with message: %s", result.message);
    warn(
      "[retry %d/%d] Retrying the following spec files because of retry config: %s",
      retries + 1,
      currentsConfig.retry.hardFailureMaxRetries,
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    result = await cypress.run(options);
    retries++;
  }
  if (currentsConfig.retry && retries > 0) {
    warn(
      "Exhausted max retries: %d/%d",
      retries,
      currentsConfig.retry.hardFailureMaxRetries
    );
  }
  if (result.status === "failed") {
    warn('Cypress runner failed with message: "%s"', result.message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.split(",").map((i) => `
 - ${i}`).join("")
    );
  }
  debug10("cypress run result %o", result);
  return result;
}
var runSpecFileSafe = (spec, cypressRunOptions) => safe(
  runSpecFile,
  (error2) => {
    const message = `Cypress runnner crashed with an error:
${error2.message}
${error2.stack}}`;
    debug10("cypress run exception %o", error2);
    warn('Cypress runner crashed: "%s"', message);
    warn(
      "The following spec files will be marked as failed: %s",
      spec.spec.split(",").map((i) => `
 - ${i}`).join("")
    );
    return {
      status: "failed",
      failures: 1,
      message
    };
  },
  () => {
  }
)(spec, cypressRunOptions);

// lib/debug/index.ts
import debug11 from "debug";
import { match as match3, P as P3 } from "ts-pattern";
function activateDebug(mode) {
  match3(mode).with(P3.instanceOf(Array), (i) => i.forEach(setDebugMode)).with(true, () => setDebugMode("all" /* All */)).with(
    P3.union(
      "all" /* All */,
      "currents" /* Currents */,
      "cypress" /* Cypress */,
      "commit-info" /* CommitInfo */
    ),
    (i) => setDebugMode(i)
  ).otherwise(() => setDebugMode("none" /* None */));
}
function setDebugMode(mode) {
  if (mode === "none" /* None */) {
    return;
  }
  const tokens = new Set(process.env.DEBUG ? process.env.DEBUG.split(",") : []);
  match3(mode).with("all" /* All */, () => {
    tokens.add("commit-info" /* CommitInfo */);
    tokens.add("currents:*" /* Currents */);
    tokens.add("cypress:*" /* Cypress */);
  }).with("currents" /* Currents */, () => tokens.add("currents:*" /* Currents */)).with("cypress" /* Cypress */, () => tokens.add("cypress:*" /* Cypress */)).with("commit-info" /* CommitInfo */, () => tokens.add("commit-info" /* CommitInfo */)).otherwise(() => {
  });
  debug11.enable(Array.from(tokens).join(","));
}

// lib/env.ts
var isCurrents = () => !!process.env.CURRENTS_ENFORCE_IS_CURRENTS || getAPIBaseUrl() === "https://cy.currents.dev";

// lib/git.ts
import { commitInfo } from "@currents/commit-info";
var getGitInfo = async (projectRoot) => {
  const commit = await commitInfo(projectRoot);
  return getCommitDefaults({
    branch: commit.branch,
    remoteOrigin: commit.remote,
    authorEmail: commit.email,
    authorName: commit.author,
    message: commit.message,
    sha: commit.sha,
    ghaEventData: commit.ghaEventData
  });
};

// lib/platform/browser.ts
import Debug9 from "debug";
var debug12 = Debug9("currents:browser");
function guessBrowser(browser, availableBrowsers = []) {
  debug12(
    "guessing browser from '%s', available browsers: %o",
    browser,
    availableBrowsers
  );
  let result = availableBrowsers.find((b) => b.name === browser);
  if (result) {
    debug12("identified browser by name: %o", result);
    return {
      browserName: result.displayName,
      browserVersion: result.version
    };
  }
  result = availableBrowsers.find((b) => b.path === browser);
  if (result) {
    debug12("identified browser by path: %o", result);
    return {
      browserName: result.displayName ?? result.name,
      browserVersion: result.version
    };
  }
  warn("Unable to identify browser name and version");
  return {
    browserName: "unknown",
    browserVersion: "unknown"
  };
}

// lib/platform/platform.ts
import Debug10 from "debug";
import getos from "getos";
import { cpus, freemem, platform, release, totalmem } from "os";
import { promisify } from "util";
var debug13 = Debug10("currents:platform");
var getOsVersion = async () => {
  if (platform() === "linux") {
    try {
      const linuxOs = await promisify(getos)();
      if ("dist" in linuxOs && "release" in linuxOs) {
        return [linuxOs.dist, linuxOs.release].join(" - ");
      } else {
        return release();
      }
    } catch {
      return release();
    }
  }
  return release();
};
var getPlatformInfo = async () => {
  const osVersion = await getOsVersion();
  const result = {
    osName: platform(),
    osVersion,
    osCpus: cpus(),
    osMemory: {
      free: freemem(),
      total: totalmem()
    }
  };
  debug13("platform info: %o", result);
  return result;
};

// lib/platform/index.ts
async function getPlatform({
  browser,
  config
}) {
  return {
    ...await getPlatformInfo(),
    ...guessBrowser(browser ?? "electron", config.resolved?.browsers)
  };
}

// lib/results/results.ts
import Debug11 from "debug";
import _10 from "lodash";
import { nanoid } from "nanoid";
var debug14 = Debug11("currents:results");
var isSuccessResult = (result) => {
  return result.status === "finished";
};
var getScreenshotsSummary = (tests = []) => {
  return tests.flatMap(
    (test, i) => test.attempts.flatMap(
      (a, ai) => a.screenshots.flatMap((s) => ({
        ...s,
        testId: `r${i}`,
        testAttemptIndex: ai,
        screenshotId: nanoid()
      }))
    )
  );
};
var getStats = (stats) => {
  return {
    ...stats,
    wallClockDuration: stats.duration,
    wallClockStartedAt: stats.startedAt,
    wallClockEndedAt: stats.endedAt
  };
};
var getTestAttempt = (attempt) => {
  return {
    ...attempt,
    state: attempt.state,
    wallClockDuration: attempt.duration,
    wallClockStartedAt: attempt.startedAt
  };
};
var getInstanceResultPayload = (runResult, coverageFilePath) => {
  return {
    stats: getStats(runResult.stats),
    reporterStats: runResult.reporterStats,
    exception: runResult.error ?? null,
    video: !!runResult.video,
    // Did the instance generate a video?
    screenshots: getScreenshotsSummary(runResult.tests ?? []),
    hasCoverage: !!coverageFilePath,
    tests: runResult.tests?.map((test, i) => ({
      displayError: test.displayError,
      state: test.state,
      hooks: runResult.hooks,
      attempts: test.attempts?.map(getTestAttempt) ?? [],
      clientId: `r${i}`
    })) ?? []
  };
};
function getFakeTestFromException(error2, stats) {
  return {
    title: ["Unknown"],
    body: "",
    displayError: error2.split("\n")[0],
    state: "failed",
    hooks: [],
    attempts: [
      getTestAttempt({
        state: "failed",
        duration: 0,
        error: {
          name: "Error",
          message: error2.split("\n")[0],
          stack: error2
        },
        screenshots: [],
        startedAt: stats.startedAt,
        videoTimestamp: 0
      })
    ],
    clientId: "r0"
  };
}
var getInstanceTestsPayload = (runResult, config) => {
  return {
    config,
    tests: runResult.tests?.map((test, i) => ({
      title: test.title,
      config: null,
      body: test.body,
      clientId: `r${i}`,
      hookIds: []
    })) ?? [],
    hooks: runResult.hooks
  };
};
var summarizeTestResults = (input, config) => {
  if (!input.length) {
    return getEmptyCypressResults(config);
  }
  const overall = input.reduce(
    (acc, {
      totalDuration,
      totalFailed,
      totalPassed,
      totalPending,
      totalSkipped,
      totalTests,
      totalSuites
    }) => ({
      totalDuration: acc.totalDuration + totalDuration,
      totalSuites: acc.totalSuites + totalSuites,
      totalPending: acc.totalPending + totalPending,
      totalFailed: acc.totalFailed + totalFailed,
      totalSkipped: acc.totalSkipped + totalSkipped,
      totalPassed: acc.totalPassed + totalPassed,
      totalTests: acc.totalTests + totalTests
    }),
    emptyStats
  );
  const firstResult = input[0];
  const startItems = input.map((i) => i.startedTestsAt).sort();
  const endItems = input.map((i) => i.endedTestsAt).sort();
  const runs = input.map((i) => i.runs).flat();
  return {
    ...overall,
    runs,
    startedTestsAt: _10.first(startItems),
    endedTestsAt: _10.last(endItems),
    ..._10.pick(
      firstResult,
      "browserName",
      "browserVersion",
      "browserPath",
      "osName",
      "osVersion",
      "cypressVersion",
      "config"
    ),
    status: "finished"
  };
};
function getEmptyCypressResults(config) {
  return {
    ...emptyStats,
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    runs: [],
    // @ts-ignore
    config
  };
}
var emptyStats = {
  totalDuration: 0,
  totalSuites: 0,
  totalPending: 0,
  totalFailed: 0,
  totalSkipped: 0,
  totalPassed: 0,
  totalTests: 0
};
var getDummyFailedTest = (start, error2) => ({
  title: ["Unknown"],
  state: "failed",
  body: "// This test is automatically generated due to execution failure",
  displayError: error2,
  attempts: [
    {
      state: "failed",
      startedAt: start,
      duration: 0,
      videoTimestamp: 0,
      screenshots: [],
      error: {
        name: "CypressExecutionError",
        message: error2,
        stack: ""
      }
    }
  ]
});
function getFailedDummyResult(configState, {
  specs,
  error: error2
}) {
  const start = (/* @__PURE__ */ new Date()).toISOString();
  const end = (/* @__PURE__ */ new Date()).toISOString();
  return {
    // @ts-ignore
    config: configState.getConfig() ?? {},
    status: "finished",
    startedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    endedTestsAt: (/* @__PURE__ */ new Date()).toISOString(),
    totalDuration: 0,
    totalSuites: 1,
    totalFailed: 1,
    totalPassed: 0,
    totalPending: 0,
    totalSkipped: 0,
    totalTests: 1,
    browserName: "unknown",
    browserVersion: "unknown",
    browserPath: "unknown",
    osName: "unknown",
    osVersion: "unknown",
    cypressVersion: "unknown",
    runs: specs.map((s) => ({
      stats: {
        suites: 1,
        tests: 1,
        passes: 0,
        pending: 0,
        skipped: 0,
        failures: 1,
        startedAt: start,
        endedAt: end,
        duration: 0
      },
      reporter: "spec",
      reporterStats: {},
      hooks: [],
      error: error2,
      video: null,
      spec: {
        name: s,
        relative: s,
        absolute: s,
        relativeToCommonRoot: s
      },
      tests: [getDummyFailedTest(start, error2)],
      shouldUploadVideo: false,
      skippedSpec: false
    }))
  };
}
function getCypressRunResultForSpec(spec, cypressResult) {
  if (!isSuccessResult(cypressResult)) {
    return;
  }
  const run3 = cypressResult.runs.find((r) => r.spec.relative === spec);
  if (!run3) {
    return;
  }
  const stats = getStats(run3.stats);
  return {
    ...cypressResult,
    runs: [run3],
    totalSuites: 1,
    totalDuration: stats.wallClockDuration,
    totalTests: stats.tests,
    totalFailed: stats.failures,
    totalPassed: stats.passes,
    totalPending: stats.pending,
    totalSkipped: stats.skipped,
    startedTestsAt: stats.wallClockStartedAt,
    endedTestsAt: stats.wallClockEndedAt
  };
}

// lib/results/table.ts
import _11 from "lodash";
import prettyMS from "pretty-ms";
import { table } from "table";
var failureIcon = red("\u2716");
var successIcon = green("\u2714");
var summaryTable = (r) => {
  const overallSpecCount = r.runs.length;
  const failedSpecsCount = _11.sum(
    r.runs.filter((v) => v.stats.failures + v.stats.skipped > 0).map(() => 1)
  );
  const hasFailed = failedSpecsCount > 0;
  const verdict = hasFailed ? red(`${failedSpecsCount} of ${overallSpecCount} failed`) : overallSpecCount > 0 ? "All specs passed!" : "No specs executed";
  const data = r.runs.map((r2) => [
    r2.stats.failures + r2.stats.skipped > 0 ? failureIcon : successIcon,
    r2.spec.relativeToCommonRoot,
    gray(prettyMS(r2.stats.duration)),
    white(r2.stats.tests ?? 0),
    r2.stats.passes ? green(r2.stats.passes) : gray("-"),
    r2.stats.failures ? red(r2.stats.failures) : gray("-"),
    r2.stats.pending ? cyan(r2.stats.pending) : gray("-"),
    r2.stats.skipped ? red(r2.stats.skipped) : gray("-")
  ]);
  return table(
    [
      [
        "",
        // marker
        gray("Spec"),
        "",
        gray("Tests"),
        gray("Passing"),
        gray("Failing"),
        gray("Pending"),
        gray("Skipped")
      ],
      ...data,
      [
        hasFailed ? failureIcon : successIcon,
        // marker
        verdict,
        gray(prettyMS(r.totalDuration ?? 0)),
        overallSpecCount > 0 ? white(r.totalTests ?? 0) : gray("-"),
        r.totalPassed ? green(r.totalPassed) : gray("-"),
        r.totalFailed ? red(r.totalFailed) : gray("-"),
        r.totalPending ? cyan(r.totalPending) : gray("-"),
        r.totalSkipped ? red(r.totalSkipped) : gray("-")
      ]
    ],
    {
      border,
      columnDefault: {
        width: 8
      },
      columns: [
        { alignment: "left", width: 2 },
        { alignment: "left", width: 30 },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" },
        { alignment: "right" }
      ],
      // singleLine: true,
      drawHorizontalLine: (lineIndex, rowCount) => {
        return lineIndex === 1 || lineIndex === 0 || lineIndex === rowCount - 1 || lineIndex === rowCount;
      },
      drawVerticalLine: (lineIndex, rowCount) => {
        return lineIndex === 0 || rowCount === lineIndex;
      }
    }
  );
};
var border = _11.mapValues(
  {
    topBody: `\u2500`,
    topJoin: `\u252C`,
    topLeft: `  \u250C`,
    topRight: `\u2510`,
    bottomBody: `\u2500`,
    bottomJoin: `\u2534`,
    bottomLeft: `  \u2514`,
    bottomRight: `\u2518`,
    bodyLeft: `  \u2502`,
    bodyRight: `\u2502`,
    bodyJoin: `\u2502`,
    joinBody: `\u2500`,
    joinLeft: `  \u251C`,
    joinRight: `\u2524`,
    joinJoin: `\u253C`
  },
  (v) => gray(v)
);

// lib/results/uploadResults.ts
import Debug14 from "debug";

// lib/artifacts.ts
import Debug13 from "debug";

// lib/upload.ts
import Debug12 from "debug";
import fs3 from "fs";
var readFile = fs3.promises.readFile;
var debug15 = Debug12("currents:upload");
function uploadVideo(file2, url) {
  return uploadFile(file2, url, "video/mp4");
}
function uploadImage(file2, url) {
  return uploadFile(file2, url, "image/png");
}
function uploadJson(file2, url) {
  return uploadFile(file2, url, "application/json");
}
async function uploadFile(file2, url, type) {
  debug15('uploading file "%s" to "%s"', file2, url);
  const f = await readFile(file2);
  await makeRequest({
    url,
    method: "PUT",
    data: f,
    headers: {
      "Content-Type": type,
      "Content-Disposition": `inline`
    }
  });
}

// lib/artifacts.ts
var debug16 = Debug13("currents:artifacts");
async function uploadArtifacts({
  executionState,
  videoPath,
  videoUploadUrl,
  screenshots,
  screenshotUploadUrls,
  coverageFilePath,
  coverageUploadUrl
}) {
  debug16("uploading artifacts: %o", {
    videoPath,
    videoUploadUrl,
    screenshots,
    screenshotUploadUrls,
    coverageFilePath,
    coverageUploadUrl
  });
  const totalUploads = (videoPath ? 1 : 0) + screenshots.length + (coverageUploadUrl ? 1 : 0);
  if (totalUploads === 0) {
    return;
  }
  if (videoUploadUrl && videoPath) {
    await safe(
      uploadVideo,
      (e) => {
        debug16("failed uploading video %s. Error: %o", videoPath, e);
        executionState.addWarning(
          `Failed uploading video ${videoPath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", videoPath)
    )(videoPath, videoUploadUrl);
  }
  if (screenshotUploadUrls && screenshotUploadUrls.length) {
    await Promise.all(
      screenshots.map((screenshot) => {
        const url = screenshotUploadUrls.find(
          (urls) => urls.screenshotId === screenshot.screenshotId
        )?.uploadUrl;
        if (!url) {
          debug16(
            "No upload url for screenshot %o, screenshotUploadUrls: %o",
            screenshot,
            screenshotUploadUrls
          );
          executionState.addWarning(
            `No upload URL for screenshot ${screenshot.path}`
          );
          return Promise.resolve();
        }
        return safe(
          uploadImage,
          (e) => {
            debug16(
              "failed uploading screenshot %s. Error: %o",
              screenshot.path,
              e
            );
            executionState.addWarning(
              `Failed uploading screenshot ${screenshot.path}.
${dim(e)}`
            );
          },
          () => debug16("success uploading", screenshot.path)
        )(screenshot.path, url);
      })
    );
  }
  if (coverageUploadUrl && coverageFilePath) {
    await safe(
      uploadJson,
      (e) => {
        debug16(
          "failed uploading coverage file %s. Error: %o",
          coverageFilePath,
          e
        );
        executionState.addWarning(
          `Failed uploading coverage file ${coverageFilePath}.
${dim(e)}`
        );
      },
      () => debug16("success uploading", coverageFilePath)
    )(coverageFilePath, coverageUploadUrl);
  }
}
var uploadStdoutSafe = safe(
  updateInstanceStdout,
  () => {
  },
  () => {
  }
);

// lib/cancellation/cancellation.ts
var state = {
  cancellationReason: null
};
var setCancellationReason = (reason) => {
  if (state.cancellationReason) {
    return;
  }
  state.cancellationReason = reason;
  pubsub.emit("runCancelled" /* RUN_CANCELLED */, reason);
};

// lib/results/uploadResults.ts
var debug17 = Debug14("currents:results");
async function getReportResultsTask(instanceId, configState, executionState, stdout2, coverageFilePath) {
  const results = executionState.getInstanceResults(configState, instanceId);
  const run3 = results.runs[0];
  if (!run3) {
    throw new Error("No run found in Cypress results");
  }
  const instanceResults = getInstanceResultPayload(run3, coverageFilePath);
  const instanceTests = getInstanceTestsPayload(run3, results.config);
  const { videoUploadUrl, screenshotUploadUrls, coverageUploadUrl, cloud } = await reportResults(instanceId, instanceTests, instanceResults);
  if (cloud?.shouldCancel) {
    debug17("instance %s should cancel", instanceId);
    setCancellationReason(cloud.shouldCancel);
  }
  debug17("instance %s artifact upload instructions %o", instanceId, {
    videoUploadUrl,
    screenshotUploadUrls,
    coverageUploadUrl
  });
  return Promise.all([
    uploadArtifacts({
      executionState,
      videoUploadUrl,
      videoPath: run3.video,
      screenshotUploadUrls,
      screenshots: instanceResults.screenshots,
      coverageUploadUrl,
      coverageFilePath
    }),
    uploadStdoutSafe(instanceId, getInitialOutput() + stdout2)
  ]);
}
async function reportResults(instanceId, instanceTests, instanceResults) {
  debug17("reporting instance %s results...", instanceId);
  if (isCurrents()) {
    return reportInstanceResultsMerged(instanceId, {
      tests: instanceTests,
      results: instanceResults
    });
  }
  await setInstanceTests(instanceId, instanceTests);
  return updateInstanceResults(instanceId, instanceResults);
}

// lib/runner/runner.ts
import Debug16 from "debug";

// lib/runner/reportTask.ts
import Debug15 from "debug";
var debug18 = Debug15("currents:reportTask");
var reportTasks = [];
var createReportTask = (configState, executionState, instanceId) => {
  const instance = executionState.getInstance(instanceId);
  if (!instance) {
    error("Cannot find execution state for instance %s", instanceId);
    return;
  }
  if (instance.reportStartedAt) {
    debug18("Report task already created for instance %s", instanceId);
    return;
  }
  instance.reportStartedAt = /* @__PURE__ */ new Date();
  debug18("Creating report task for instanceId %s", instanceId);
  reportTasks.push(
    getReportResultsTask(
      instanceId,
      configState,
      executionState,
      instance.output ?? "no output captured",
      instance.coverageFilePath
    ).catch(error)
  );
};
var createReportTaskSpec = (configState, executionState, spec) => {
  const i = executionState.getSpec(spec);
  if (!i) {
    error("Cannot find execution state for spec %s", spec);
    return;
  }
  debug18("Creating report task for spec %s", spec);
  return createReportTask(configState, executionState, i.instanceId);
};

// lib/runner/runner.ts
var debug19 = Debug16("currents:runner");
async function runTillDone(executionState, configState, {
  runId,
  groupId,
  machineId,
  platform: platform2,
  specs: allSpecs
}, params) {
  let hasMore = true;
  while (hasMore) {
    const newTasks = await runBatch(executionState, configState, {
      runMeta: {
        runId,
        groupId,
        machineId,
        platform: platform2
      },
      allSpecs,
      params
    });
    if (!newTasks.length) {
      debug19("No more tasks to run. Uploads queue: %d", reportTasks.length);
      hasMore = false;
      break;
    }
    newTasks.forEach(
      (t) => createReportTask(configState, executionState, t.instanceId)
    );
  }
}
async function runBatch(executionState, configState, {
  runMeta,
  params,
  allSpecs
}) {
  let batch = {
    specs: [],
    claimedInstances: 0,
    totalInstances: 0
  };
  if (isCurrents()) {
    debug19("Getting batched tasks: %d", params.batchSize);
    batch = await createBatchedInstances({
      ...runMeta,
      batchSize: params.batchSize
    });
    debug19("Got batched tasks: %o", batch);
  } else {
    const response = await createInstance(runMeta);
    if (response.spec !== null && response.instanceId !== null) {
      batch.specs.push({
        spec: response.spec,
        instanceId: response.instanceId
      });
    }
    batch.claimedInstances = response.claimedInstances;
    batch.totalInstances = response.totalInstances;
  }
  if (batch.specs.length === 0) {
    return [];
  }
  batch.specs.forEach((i) => executionState.initInstance(i));
  divider();
  info(
    "Running: %s (%d/%d)",
    batch.specs.map((s) => s.spec).join(", "),
    batch.claimedInstances,
    batch.totalInstances
  );
  const rawResult = await runSpecFileSafe(
    {
      // use absolute paths - user can run the program from a different directory, e.g. nx or a monorepo workspace
      // cypress still report the path relative to the project root
      spec: batch.specs.map((bs) => getSpecAbsolutePath(allSpecs, bs.spec)).join(",")
    },
    params
  );
  title("blue", "Reporting results and artifacts in background...");
  const output = getCapturedOutput();
  batch.specs.forEach((spec) => {
    executionState.setInstanceOutput(spec.instanceId, output);
    const specRunResult = getCypressRunResultForSpec(spec.spec, rawResult);
    if (!specRunResult) {
      return;
    }
    executionState.setInstanceResult(
      configState,
      spec.instanceId,
      specRunResult
    );
  });
  resetCapture();
  return batch.specs;
}
function getSpecAbsolutePath(allSpecs, relative) {
  const absolutePath = allSpecs.find((i) => i.relative === relative)?.absolute;
  if (!absolutePath) {
    warn(
      'Cannot find absolute path for spec. Spec: "%s", candidates: %o',
      relative,
      allSpecs
    );
    throw new Error(`Cannot find absolute path for spec`);
  }
  return absolutePath;
}

// lib/runner/cancellable.ts
var cancellable = null;
function onRunCancelled(reason) {
  warn(
    `Run cancelled: %s. Waiting for uploads to complete and stopping execution...`,
    reason
  );
  cancellable?.cancel();
}
async function runTillDoneOrCancelled(...args) {
  return new Promise((_resolve, _reject) => {
    cancellable = new BPromise((resolve, reject, onCancel) => {
      if (!onCancel) {
        _reject(new Error("BlueBird is misconfigured: onCancel is undefined"));
        return;
      }
      onCancel(() => _resolve(void 0));
      runTillDone(...args).then(
        () => {
          resolve();
          _resolve(void 0);
        },
        (error2) => {
          reject();
          _reject(error2);
        }
      );
    });
    pubsub.addListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  }).finally(() => {
    pubsub.removeListener("runCancelled" /* RUN_CANCELLED */, onRunCancelled);
  });
}

// lib/shutdown.ts
async function shutdown() {
  await stopWSS();
}

// lib/specMatcher/specMatcher.ts
import Debug17 from "debug";
import path3 from "path";
import commonPathPrefix from "common-path-prefix";
import globby from "globby";
import _12 from "lodash";
import os from "os";

// lib/utils.ts
import path2 from "path";
function toArray(val) {
  return val ? typeof val === "string" ? [val] : val : [];
}
function toPosix(file2, sep = path2.sep) {
  return file2.split(sep).join(path2.posix.sep);
}

// lib/specMatcher/specMatcher.ts
var debug20 = Debug17("currents:specs");
async function findSpecs({
  projectRoot,
  testingType,
  specPattern,
  configSpecPattern,
  excludeSpecPattern,
  additionalIgnorePattern
}) {
  configSpecPattern = toArray(configSpecPattern);
  specPattern = toArray(specPattern);
  excludeSpecPattern = toArray(excludeSpecPattern) || [];
  additionalIgnorePattern = toArray(additionalIgnorePattern) || [];
  debug20("exploring spec files for execution %O", {
    testingType,
    projectRoot,
    specPattern,
    configSpecPattern,
    excludeSpecPattern,
    additionalIgnorePattern
  });
  if (!specPattern || !configSpecPattern) {
    throw Error("Could not find glob patterns for exploring specs");
  }
  let specAbsolutePaths = await getFilesByGlob(projectRoot, specPattern, {
    absolute: true,
    ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
  });
  if (!_12.isEqual(specPattern, configSpecPattern)) {
    const defaultSpecAbsolutePaths = await getFilesByGlob(
      projectRoot,
      configSpecPattern,
      {
        absolute: true,
        ignore: [...excludeSpecPattern, ...additionalIgnorePattern]
      }
    );
    specAbsolutePaths = _12.intersection(
      specAbsolutePaths,
      defaultSpecAbsolutePaths
    );
  }
  return matchedSpecs({
    projectRoot,
    testingType,
    specAbsolutePaths,
    specPattern
  });
}
async function getFilesByGlob(projectRoot, glob, globOptions) {
  const workingDirectoryPrefix = path3.join(projectRoot, path3.sep);
  const globs = [].concat(glob).map(
    (globPattern) => globPattern.startsWith("./") ? globPattern.replace("./", "") : globPattern
  ).map((globPattern) => {
    if (globPattern.startsWith(workingDirectoryPrefix)) {
      return globPattern.replace(workingDirectoryPrefix, "");
    }
    return globPattern;
  });
  if (os.platform() === "win32") {
    debug20("updating glob patterns to POSIX");
    for (const i in globs) {
      const cur = globs[i];
      if (!cur)
        throw new Error("undefined glob received");
      globs[i] = toPosix(cur);
    }
  }
  try {
    debug20("globbing pattern(s): %o", globs);
    debug20("within directory: %s", projectRoot);
    return matchGlobs(globs, {
      onlyFiles: true,
      absolute: true,
      cwd: projectRoot,
      ...globOptions,
      ignore: (globOptions?.ignore ?? []).concat("**/node_modules/**")
    });
  } catch (e) {
    debug20("error in getFilesByGlob %o", e);
    return [];
  }
}
var matchGlobs = async (globs, globbyOptions) => {
  return await globby(globs, globbyOptions);
};
function matchedSpecs({
  projectRoot,
  testingType,
  specAbsolutePaths
}) {
  debug20("found specs %o", specAbsolutePaths);
  let commonRoot = "";
  if (specAbsolutePaths.length === 1) {
    commonRoot = path3.dirname(specAbsolutePaths[0]);
  } else {
    commonRoot = commonPathPrefix(specAbsolutePaths);
  }
  return specAbsolutePaths.map(
    (absolute) => transformSpec({
      projectRoot,
      absolute,
      testingType,
      commonRoot,
      platform: os.platform(),
      sep: path3.sep
    })
  );
}
function transformSpec({
  projectRoot,
  absolute,
  testingType,
  commonRoot,
  platform: platform2,
  sep
}) {
  if (platform2 === "win32") {
    absolute = toPosix(absolute, sep);
    projectRoot = toPosix(projectRoot, sep);
  }
  const relative = path3.relative(projectRoot, absolute);
  const parsedFile = path3.parse(absolute);
  const fileExtension = path3.extname(absolute);
  const specFileExtension = [".spec", ".test", "-spec", "-test", ".cy"].map((ext) => ext + fileExtension).find((ext) => absolute.endsWith(ext)) || fileExtension;
  const parts = absolute.split(projectRoot);
  let name = parts[parts.length - 1] || "";
  if (name.startsWith("/")) {
    name = name.slice(1);
  }
  const LEADING_SLASH = /^\/|/g;
  const relativeToCommonRoot = absolute.replace(commonRoot, "").replace(LEADING_SLASH, "");
  return {
    fileExtension,
    baseName: parsedFile.base,
    fileName: parsedFile.base.replace(specFileExtension, ""),
    specFileExtension,
    relativeToCommonRoot,
    specType: testingType === "component" ? "component" : "integration",
    name,
    relative,
    absolute
  };
}

// lib/specMatcher/getSpecFiles.ts
var getSpecFiles = async ({
  config,
  params
}) => {
  const specPattern = getSpecPattern(config.specPattern, params.spec);
  const specs = await findSpecs({
    // https://docs.cypress.io/guides/guides/command-line#cypress-run-spec-lt-spec-gt
    projectRoot: params.project ?? config.projectRoot,
    testingType: params.testingType,
    specPattern,
    configSpecPattern: config.specPattern,
    excludeSpecPattern: config.excludeSpecPattern,
    additionalIgnorePattern: config.additionalIgnorePattern
  });
  if (specs.length === 0) {
    warn(
      "Found no spec files. Was looking for spec files that match both configSpecPattern and specPattern relative to projectRoot. Configuration: %O",
      {
        projectRoot: config.projectRoot,
        specPattern,
        configSpecPattern: config.specPattern,
        excludeSpecPattern: [
          config.excludeSpecPattern,
          config.additionalIgnorePattern
        ].flat(2),
        testingType: params.testingType
      }
    );
  }
  return { specs, specPattern };
};
function getSpecPattern(configPattern, explicit) {
  return explicit || configPattern;
}

// lib/state/config.ts
var ConfigState = class {
  constructor() {
    this._config = void 0;
  }
  setConfig(c) {
    this._config = c;
  }
  getConfig() {
    return this._config;
  }
};

// lib/results/mapResult.ts
function getScreenshot(s) {
  return {
    ...s,
    name: s.name ?? "screenshot"
  };
}
function getTestAttempt2(attempt, screenshots) {
  return {
    ...attempt,
    startedAt: attempt.wallClockStartedAt,
    duration: attempt.wallClockDuration,
    screenshots: screenshots.map(getScreenshot)
  };
}
function getTest(t, screenshots) {
  const _screenshots = screenshots.filter((s) => s.testId === t.testId);
  return {
    ...t,
    attempts: t.attempts.map(
      (a, i) => getTestAttempt2(
        a,
        _screenshots.filter((s) => s.testAttemptIndex === i)
      )
    )
  };
}
function specResultsToCypressResults(configState, specAfterResult) {
  return {
    status: "finished",
    // @ts-ignore
    config: configState.getConfig(),
    totalDuration: specAfterResult.stats.wallClockDuration,
    totalSuites: specAfterResult.stats.suites,
    totalTests: specAfterResult.stats.tests,
    totalFailed: specAfterResult.stats.failures,
    totalPassed: specAfterResult.stats.passes,
    totalPending: specAfterResult.stats.pending,
    totalSkipped: specAfterResult.stats.skipped,
    startedTestsAt: specAfterResult.stats.wallClockStartedAt,
    endedTestsAt: specAfterResult.stats.wallClockEndedAt,
    runs: [
      {
        stats: {
          ...specAfterResult.stats,
          startedAt: specAfterResult.stats.wallClockStartedAt,
          endedAt: specAfterResult.stats.wallClockEndedAt,
          duration: specAfterResult.stats.wallClockDuration
        },
        reporter: specAfterResult.reporter,
        reporterStats: specAfterResult.reporterStats ?? {},
        spec: specAfterResult.spec,
        error: specAfterResult.error,
        video: specAfterResult.video,
        shouldUploadVideo: true,
        // not really used
        // @ts-ignore
        // wrong typedef for CypressCommandLine.CypressRunResult
        // actual HookName is "before all" | "before each" | "after all" | "after each"
        hooks: specAfterResult.hooks,
        tests: (specAfterResult.tests ?? []).map(
          (t) => getTest(t, specAfterResult.screenshots)
        )
      }
    ]
  };
}
var backfillException = (result) => {
  return {
    ...result,
    runs: result.runs.map(backfillExceptionRun)
  };
};
var backfillExceptionRun = (run3) => {
  if (!run3.error) {
    return run3;
  }
  return {
    ...run3,
    tests: [getFakeTestFromException(run3.error, run3.stats)]
  };
};

// lib/state/execution.ts
import Debug18 from "debug";
var debug21 = Debug18("currents:state");
var ExecutionState = class {
  constructor() {
    this.warnings = /* @__PURE__ */ new Set();
    this.state = {};
  }
  getWarnings() {
    return this.warnings;
  }
  addWarning(warning) {
    this.warnings.add(warning);
  }
  getResults(configState) {
    return Object.values(this.state).map(
      (i) => this.getInstanceResults(configState, i.instanceId)
    );
  }
  getInstance(instanceId) {
    return this.state[instanceId];
  }
  getSpec(spec) {
    return Object.values(this.state).find((i) => i.spec === spec);
  }
  initInstance({
    instanceId,
    spec
  }) {
    debug21('Init execution state for "%s"', spec);
    this.state[instanceId] = {
      instanceId,
      spec,
      createdAt: /* @__PURE__ */ new Date()
    };
  }
  setSpecBefore(spec) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specBefore = /* @__PURE__ */ new Date();
  }
  setSpecCoverage(spec, coverageFilePath) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    debug21("Experimental: coverageFilePath was set");
    i.coverageFilePath = coverageFilePath;
  }
  setSpecAfter(spec, results) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    i.specAfter = /* @__PURE__ */ new Date();
    i.specAfterResults = results;
  }
  setSpecOutput(spec, output) {
    const i = this.getSpec(spec);
    if (!i) {
      warn('Cannot find execution state for spec "%s"', spec);
      return;
    }
    this.setInstanceOutput(i.instanceId, output);
  }
  setInstanceOutput(instanceId, output) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    if (i.output) {
      debug21('Instance "%s" already has output', instanceId);
      return;
    }
    i.output = output;
  }
  setInstanceResult(configState, instanceId, results) {
    const i = this.state[instanceId];
    if (!i) {
      warn('Cannot find execution state for instance "%s"', instanceId);
      return;
    }
    i.runResults = results;
    i.runResultsReportedAt = /* @__PURE__ */ new Date();
  }
  getInstanceResults(configState, instanceId) {
    const i = this.getInstance(instanceId);
    if (!i) {
      error('Cannot find execution state for instance "%s"', instanceId);
      return getFailedDummyResult(configState, {
        specs: ["unknown"],
        error: "Cannot find execution state for instance"
      });
    }
    if (i.specAfterResults) {
      return backfillException(
        specResultsToCypressResults(configState, i.specAfterResults)
      );
    }
    if (i.runResults) {
      return backfillException(i.runResults);
    }
    debug21('No results detected for "%s"', i.spec);
    return getFailedDummyResult(configState, {
      specs: [i.spec],
      error: `No results detected for the spec file. That usually happens because of cypress crash. See the console output for details.`
    });
  }
};

// lib/run.ts
var debug22 = Debug19("currents:run");
async function run(params = {}) {
  const executionState = new ExecutionState();
  const configState = new ConfigState();
  activateDebug(params.cloudDebug);
  debug22("run params %o", params);
  params = preprocessParams(params);
  debug22("params after preprocess %o", params);
  if (isOffline(params)) {
    info(`Skipping cloud orchestration because --record is set to false`);
    return runBareCypress(params);
  }
  const validatedParams = await validateParams(params);
  setAPIBaseUrl(validatedParams.cloudServiceUrl);
  if (!isCurrents()) {
    console.log(getLegalNotice());
  }
  const {
    recordKey,
    projectId,
    group,
    parallel,
    ciBuildId,
    tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    experimentalCoverageRecording
  } = validatedParams;
  const config = await getMergedConfig(validatedParams);
  configState.setConfig(config?.resolved);
  const { specs, specPattern } = await getSpecFiles({
    config,
    params: validatedParams
  });
  if (specs.length === 0) {
    return;
  }
  const platform2 = await getPlatform({
    config,
    browser: validatedParams.browser
  });
  info("Discovered %d spec files", specs.length);
  info(
    `Tags: ${tag.length > 0 ? tag.join(",") : false}; Group: ${group ?? false}; Parallel: ${parallel ?? false}; Batch Size: ${batchSize}`
  );
  info("Connecting to cloud orchestration service...");
  const run3 = await createRun({
    ci: getCI(ciBuildId),
    specs: specs.map((spec) => spec.relative),
    commit: await getGitInfo(config.projectRoot),
    group,
    platform: platform2,
    parallel: parallel ?? false,
    ciBuildId,
    projectId,
    recordKey,
    specPattern: [specPattern].flat(2),
    tags: tag,
    testingType,
    batchSize,
    autoCancelAfterFailures,
    coverageEnabled: experimentalCoverageRecording,
    previousCiBuildId: process.env.CURRENTS_PREVIOUS_CI_BUILD_ID,
    providedMachineId: process.env.CURRENTS_MACHINE_ID
  });
  setRunId(run3.runId);
  info("\u{1F3A5} Run URL:", bold(run3.runUrl));
  process.env.CURRENTS_MACHINE_ID ? info("\u{1F916} Machine ID:", bold(run3.machineId)) : null;
  cutInitialOutput();
  await startWSS();
  listenToSpecEvents(
    configState,
    executionState,
    config.experimentalCoverageRecording
  );
  await runTillDoneOrCancelled(
    executionState,
    configState,
    {
      runId: run3.runId,
      groupId: run3.groupId,
      machineId: run3.machineId,
      platform: platform2,
      specs
    },
    validatedParams
  );
  divider();
  await Promise.allSettled(reportTasks);
  const _summary = summarizeTestResults(
    executionState.getResults(configState),
    config
  );
  title("white", "Cloud Run Finished");
  console.log(summaryTable(_summary));
  printWarnings2(executionState);
  info("\n\u{1F3C1} Recorded Run:", bold(run3.runUrl));
  await shutdown();
  spacer();
  if (_summary.status === "finished") {
    return {
      ..._summary,
      runUrl: run3.runUrl
    };
  }
  return _summary;
}
function listenToSpecEvents(configState, executionState, experimentalCoverageRecording) {
  const config = configState.getConfig();
  pubsub.on("before:spec", async ({ spec }) => {
    debug22("before:spec %o", spec);
    executionState.setSpecBefore(spec.relative);
  });
  pubsub.on(
    "after:spec",
    async ({ spec, results }) => {
      debug22("after:spec %o %o", spec, results);
      executionState.setSpecAfter(spec.relative, results);
      executionState.setSpecOutput(spec.relative, getCapturedOutput());
      if (experimentalCoverageRecording) {
        const { path: path4, error: error2 } = await getCoverageFilePath(
          config?.env?.coverageFile
        );
        if (!error2) {
          executionState.setSpecCoverage(spec.relative, path4);
        } else {
          executionState.addWarning(
            `Could not process coverage file "${path4}"
${dim(error2)}`
          );
        }
      }
      createReportTaskSpec(configState, executionState, spec.relative);
    }
  );
}
function printWarnings2(executionState) {
  const warnings = Array.from(executionState.getWarnings());
  if (warnings.length > 0) {
    warn(
      `${warnings.length} ${plur(
        "Warning",
        warnings.length
      )} encountered during the execution:
${warnings.map((w, i) => `
${yellow(`[${i + 1}/${warnings.length}]`)} ${w}`).join("\n")}`
    );
  }
}

// index.ts
function run2(params) {
  return run(params);
}
export {
  run2 as run
};
/*! @preserve

### MIT

Parts of this code was copied from https://github.com/cypress-io/cypress and is subject to MIT license.

MIT License

Copyright (c) 2022 Cypress.io

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5kZXgudHMiLCAiLi4vbGliL3JlcXVpcmUudHMiLCAiLi4vbGliL3N0ZG91dC50cyIsICIuLi9saWIvd3Mvd3MudHMiLCAiLi4vbGliL3B1YnN1Yi50cyIsICIuLi9saWIvY2FwdHVyZS50cyIsICIuLi9saWIvaHR0cENsaWVudC9jb25maWcudHMiLCAiLi4vbGliL2h0dHBDbGllbnQvaHR0cENsaWVudC50cyIsICIuLi9saWIvY29uZmlnL2NvbmZpZy50cyIsICIuLi9saWIvYm9vdHN0cmFwL2Jvb3RzdHJhcC50cyIsICIuLi9saWIvZXJyb3JzLnRzIiwgIi4uL2xpYi9mcy50cyIsICIuLi9saWIvbG9nLnRzIiwgIi4uL2xpYi9ib290c3RyYXAvc2VyaWFsaXplci50cyIsICIuLi9saWIvY29uZmlnL3BhdGgudHMiLCAiLi4vbGliL2NvbmZpZy9wYXJhbXMudHMiLCAiLi4vbGliL2h0dHBDbGllbnQvcHJpbnRFcnJvcnMudHMiLCAiLi4vbGliL2luaXQudHMiLCAiLi4vbGliL3J1bi50cyIsICIuLi9sZWdhbC50cyIsICIuLi9saWIvYXBpL3dhcm5pbmdzLnRzIiwgIi4uL2xpYi9hcGkvYXBpLnRzIiwgIi4uL2xpYi9jaVByb3ZpZGVyL2NpUHJvdmlkZXIudHMiLCAiLi4vbGliL2NpUHJvdmlkZXIvbWVyZ2UudHMiLCAiLi4vbGliL2NvdmVyYWdlL2luZGV4LnRzIiwgIi4uL2xpYi9jeXByZXNzL2N5cHJlc3MudHMiLCAiLi4vbGliL2xhbmcudHMiLCAiLi4vbGliL2RlYnVnL2luZGV4LnRzIiwgIi4uL2xpYi9lbnYudHMiLCAiLi4vbGliL2dpdC50cyIsICIuLi9saWIvcGxhdGZvcm0vYnJvd3Nlci50cyIsICIuLi9saWIvcGxhdGZvcm0vcGxhdGZvcm0udHMiLCAiLi4vbGliL3BsYXRmb3JtL2luZGV4LnRzIiwgIi4uL2xpYi9yZXN1bHRzL3Jlc3VsdHMudHMiLCAiLi4vbGliL3Jlc3VsdHMvdGFibGUudHMiLCAiLi4vbGliL3Jlc3VsdHMvdXBsb2FkUmVzdWx0cy50cyIsICIuLi9saWIvYXJ0aWZhY3RzLnRzIiwgIi4uL2xpYi91cGxvYWQudHMiLCAiLi4vbGliL2NhbmNlbGxhdGlvbi9jYW5jZWxsYXRpb24udHMiLCAiLi4vbGliL3J1bm5lci9ydW5uZXIudHMiLCAiLi4vbGliL3J1bm5lci9yZXBvcnRUYXNrLnRzIiwgIi4uL2xpYi9ydW5uZXIvY2FuY2VsbGFibGUudHMiLCAiLi4vbGliL3NodXRkb3duLnRzIiwgIi4uL2xpYi9zcGVjTWF0Y2hlci9zcGVjTWF0Y2hlci50cyIsICIuLi9saWIvdXRpbHMudHMiLCAiLi4vbGliL3NwZWNNYXRjaGVyL2dldFNwZWNGaWxlcy50cyIsICIuLi9saWIvc3RhdGUvY29uZmlnLnRzIiwgIi4uL2xpYi9yZXN1bHRzL21hcFJlc3VsdC50cyIsICIuLi9saWIvc3RhdGUvZXhlY3V0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImN5cHJlc3NcIiAvPlxuaW1wb3J0IFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzXCI7XG5cbmltcG9ydCB7IHJ1biBhcyBpbnRlcm5hbFJ1biB9IGZyb20gXCIuL2xpYi9ydW5cIjtcbmV4cG9ydCB0eXBlIHsgQ3VycmVudHNDb25maWcgfSBmcm9tIFwiLi9saWIvY29uZmlnL2NvbmZpZ1wiO1xuaW1wb3J0IHsgQ3VycmVudHNSdW5BUEkgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUgeyBDdXJyZW50c1J1bkFQSSB9IGZyb20gXCIuL3R5cGVzXCI7XG4vKipcbiAqIFJ1biBDeXByZXNzIHRlc3RzIHdpdGggYSBjbG91ZCBzZXJ2aWNlIG9mIHlvdXIgY2hvaWNlIGFuZCByZXR1cm4gdGhlIHJlc3VsdHNcbiAqXG4gKiBAYXVnbWVudHMgQ3VycmVudHNSdW5BUElcbiAqIEByZXR1cm5zIHtDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB8IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzRmFpbGVkUnVuUmVzdWx0IHwgdW5kZWZpbmVkfSBUaGUgdGVzdCByZXN1bHRzLCBvciB1bmRlZmluZWQgaWYgbm8gdGVzdHMgd2VyZSBydW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihwYXJhbXM/OiBDdXJyZW50c1J1bkFQSSkge1xuICByZXR1cm4gaW50ZXJuYWxSdW4ocGFyYW1zKTtcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm1vZHVsZVwiO1xuLy8gcmVxdWlyZXMgc2hpbT10cnVlIGluIHBhY2thZ2UuanNvblxuZXhwb3J0IGNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4iLCAiaW1wb3J0IGNwIGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5jb25zdCBvcmdpbmFsID0gY3Auc3Bhd247XG5cbi8vIEB0cy1pZ25vcmVcbmNwLnNwYXduID0gZnVuY3Rpb24gKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoY29tbWFuZC5tYXRjaCgvQ3lwcmVzcy8pKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHByb2Nlc3MgPSBvcmdpbmFsKGNvbW1hbmQsIGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyB1c2luZyBwaXBlIGVuYWJsZXMgY2FwdHVyaW5nIHN0ZG91dCBhbmQgc3RkZXJyXG4gICAgICBzdGRpbzogW1wicGlwZVwiLCBcInBpcGVcIiwgXCJwaXBlXCJdLFxuICAgIH0pO1xuICAgIHJldHVybiBwcm9jZXNzO1xuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gb3JnaW5hbChjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcbn07XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBIdHRwVGVybWluYXRvciBmcm9tIFwibGlsLWh0dHAtdGVybWluYXRvclwiO1xuaW1wb3J0IHsgbWF0Y2gsIFAgfSBmcm9tIFwidHMtcGF0dGVyblwiO1xuaW1wb3J0ICogYXMgV2ViU29ja2V0IGZyb20gXCJ3c1wiO1xuaW1wb3J0IHsgcHVic3ViIH0gZnJvbSBcIi4uL3B1YnN1YlwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6d3NcIik7XG5cbmxldCBzZXJ2ZXI6IGh0dHAuU2VydmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgd3NzOiBXZWJTb2NrZXQuU2VydmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgaHR0cFRlcm1pbmF0b3I6IEh0dHBUZXJtaW5hdG9yIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBjb25zdCBnZXRXU1NQb3J0ID0gKCkgPT5cbiAgbWF0Y2goc2VydmVyPy5hZGRyZXNzKCkpXG4gICAgLndpdGgoeyBwb3J0OiBQLm51bWJlciB9LCAoYWRkcmVzcykgPT4gYWRkcmVzcy5wb3J0KVxuICAgIC5vdGhlcndpc2UoKCkgPT4gMCk7XG5cbmV4cG9ydCBjb25zdCBzdG9wV1NTID0gYXN5bmMgKCkgPT4ge1xuICBkZWJ1ZyhcInRlcm1pbmF0aW5nIHdzcyBzZXJ2ZXI6ICVkXCIsIGdldFdTU1BvcnQoKSk7XG4gIGlmICghaHR0cFRlcm1pbmF0b3IpIHtcbiAgICBkZWJ1ZyhcIm5vIHdzcyBzZXJ2ZXJcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgc3VjY2VzcywgY29kZSwgbWVzc2FnZSwgZXJyb3IgfSA9IGF3YWl0IGh0dHBUZXJtaW5hdG9yLnRlcm1pbmF0ZSgpO1xuICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICBpZiAoY29kZSA9PT0gXCJUSU1FRF9PVVRcIikgZXJyb3IobWVzc2FnZSk7XG4gICAgaWYgKGNvZGUgPT09IFwiU0VSVkVSX0VSUk9SXCIpIGVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICBpZiAoY29kZSA9PT0gXCJJTlRFUk5BTF9FUlJPUlwiKSBlcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gIH1cbiAgZGVidWcoXCJ0ZXJtaW5hdGVkIHdzcyBzZXJ2ZXI6ICVkXCIsIGdldFdTU1BvcnQoKSk7XG59O1xuZXhwb3J0IGNvbnN0IHN0YXJ0V1NTID0gKCkgPT4ge1xuICBpZiAod3NzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlcnZlciA9IGh0dHBcbiAgICAuY3JlYXRlU2VydmVyKClcbiAgICAub24oXCJsaXN0ZW5pbmdcIiwgKCkgPT4ge1xuICAgICAgaWYgKCFzZXJ2ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgIH1cbiAgICAgIHdzcyA9IG5ldyBXZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyKHtcbiAgICAgICAgc2VydmVyLFxuICAgICAgfSk7XG4gICAgICBkZWJ1ZyhcInN0YXJ0aW5nIHdzcyBvbiBwb3J0ICVkXCIsIGdldFdTU1BvcnQoKSk7XG4gICAgICB3c3Mub24oXCJjb25uZWN0aW9uXCIsIGZ1bmN0aW9uIGNvbm5lY3Rpb24od3MpIHtcbiAgICAgICAgd3Mub24oXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGluY29taW5nKGV2ZW50KSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgcHVic3ViLmVtaXQobWVzc2FnZS50eXBlLCBtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLmxpc3RlbigpO1xuXG4gIGh0dHBUZXJtaW5hdG9yID0gSHR0cFRlcm1pbmF0b3Ioe1xuICAgIHNlcnZlcixcbiAgfSk7XG59O1xuIiwgImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50c1wiO1xuZXhwb3J0IGVudW0gRXZlbnQge1xuICBSVU5fQ0FOQ0VMTEVEID0gXCJydW5DYW5jZWxsZWRcIixcbn1cbmV4cG9ydCBjb25zdCBwdWJzdWIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmNhcHR1cmVcIik7XG5cbmNvbnN0IF93cml0ZSA9IHByb2Nlc3Muc3Rkb3V0LndyaXRlO1xuY29uc3QgX2xvZyA9IHByb2Nlc3MubG9nO1xuXG5leHBvcnQgY29uc3QgcmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcmVzdG9yZSB0byB0aGUgb3JpZ2luYWxzXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlID0gX3dyaXRlO1xuICBwcm9jZXNzLmxvZyA9IF9sb2c7XG59O1xuXG5jb25zdCBsb2dzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcblxuY29uc3Qgc3Rkb3V0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZyhcImNhcHR1cmluZyBzdGRvdXRcIik7XG4gIGxldCBsb2dzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIGxhemlseSBiYWNrdXAgd3JpdGUgdG8gZW5hYmxlIGluamVjdGlvblxuICBjb25zdCB7IHdyaXRlIH0gPSBwcm9jZXNzLnN0ZG91dDtcbiAgY29uc3QgeyBsb2cgfSA9IHByb2Nlc3M7XG5cbiAgLy8gZWxlY3Ryb24gYWRkcyBhIG5ldyBwcm9jZXNzLmxvZ1xuICAvLyBtZXRob2QgZm9yIHdpbmRvd3MgaW5zdGVhZCBvZiBwcm9jZXNzLnN0ZG91dC53cml0ZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2lzc3Vlcy85NzdcbiAgaWYgKGxvZykge1xuICAgIHByb2Nlc3MubG9nID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKSB7XG4gICAgICBsb2dzLnB1c2goc3RyKTtcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgcmV0dXJuIGxvZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBwcm9jZXNzLnN0ZG91dC53cml0ZSA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZykge1xuICAgIGxvZ3MucHVzaChzdHIpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICByZXR1cm4gd3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGxvZ3Muam9pbihcIlwiKTtcbiAgICB9LFxuICAgIGRhdGE6IGxvZ3MsXG4gICAgcmVzdG9yZSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgZGVidWcoXCJyZXNldHRpbmcgY2FwdHVyZWQgc3Rkb3V0XCIpO1xuICAgICAgbG9ncyA9IFtdO1xuICAgIH0sXG4gIH07XG59O1xuXG5sZXQgaW5pdGlhbE91dHB1dDogc3RyaW5nID0gXCJcIjtcbmxldCBjYXB0dXJlZE91dHB1dDogbnVsbCB8IFJldHVyblR5cGU8dHlwZW9mIHN0ZG91dD4gPSBudWxsO1xuXG5leHBvcnQgY29uc3QgaW5pdENhcHR1cmUgPSAoKSA9PiAoY2FwdHVyZWRPdXRwdXQgPSBzdGRvdXQoKSk7XG5cbmV4cG9ydCBjb25zdCBjdXRJbml0aWFsT3V0cHV0ID0gKCkgPT4ge1xuICBpZiAoIWNhcHR1cmVkT3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoXCJjYXB0dXJlZE91dHB1dCBpcyBudWxsXCIpO1xuICBpbml0aWFsT3V0cHV0ID0gY2FwdHVyZWRPdXRwdXQudG9TdHJpbmcoKTtcbiAgY2FwdHVyZWRPdXRwdXQucmVzZXQoKTtcbn07XG5leHBvcnQgY29uc3QgcmVzZXRDYXB0dXJlID0gKCkgPT4ge1xuICBpZiAoIWNhcHR1cmVkT3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoXCJjYXB0dXJlZE91dHB1dCBpcyBudWxsXCIpO1xuICBjYXB0dXJlZE91dHB1dC5yZXNldCgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENhcHR1cmVkT3V0cHV0ID0gKCkgPT4ge1xuICBpZiAoIWNhcHR1cmVkT3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoXCJjYXB0dXJlZE91dHB1dCBpcyBudWxsXCIpO1xuICByZXR1cm4gY2FwdHVyZWRPdXRwdXQudG9TdHJpbmcoKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0SW5pdGlhbE91dHB1dCA9ICgpID0+IGluaXRpYWxPdXRwdXQ7XG4iLCAiaW1wb3J0IHsgQXhpb3NFcnJvciwgaXNBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5cbmV4cG9ydCBjb25zdCBpc1JldHJpYWJsZUVycm9yID0gKGVycjogQXhpb3NFcnJvcik6IGJvb2xlYW4gPT4ge1xuICBpZiAoZXJyLmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXJyLmNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXJyLmNvZGUgPT09IFwiRVRJTUVET1VUXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghaXNBeGlvc0Vycm9yKGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISEoXG4gICAgZXJyPy5yZXNwb25zZT8uc3RhdHVzICYmXG4gICAgNTAwIDw9IGVyci5yZXNwb25zZS5zdGF0dXMgJiZcbiAgICBlcnIucmVzcG9uc2Uuc3RhdHVzIDwgNjAwXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RGVsYXkgPSAoaTogbnVtYmVyKSA9PiBbNSAqIDEwMDAsIDEwICogMTAwMCwgMzAgKiAxMDAwXVtpIC0gMV07XG5cbmxldCBiYXNlVVJMID0gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiO1xuZXhwb3J0IGNvbnN0IGdldEFQSUJhc2VVcmwgPSAoKSA9PiBiYXNlVVJMID8/IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbmV4cG9ydCBjb25zdCBzZXRBUElCYXNlVXJsID0gKHVybD86IHN0cmluZykgPT5cbiAgKGJhc2VVUkwgPSB1cmwgPz8gXCJodHRwczovL2N5LmN1cnJlbnRzLmRldlwiKTtcbiIsICJpbXBvcnQgYXhpb3MsIHtcbiAgQXhpb3NFcnJvcixcbiAgQXhpb3NJbnN0YW5jZSxcbiAgQXhpb3NSZXF1ZXN0Q29uZmlnLFxuICBBeGlvc1Jlc3BvbnNlLFxuICBSYXdBeGlvc1JlcXVlc3RIZWFkZXJzLFxufSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBheGlvc1JldHJ5IGZyb20gXCJheGlvcy1yZXRyeVwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHByZXR0eU1pbGxpc2Vjb25kcyBmcm9tIFwicHJldHR5LW1zXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50c0NvbmZpZyB9IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRBUElCYXNlVXJsLCBnZXREZWxheSwgaXNSZXRyaWFibGVFcnJvciB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsgbWF5YmVQcmludEVycm9ycyB9IGZyb20gXCIuL3ByaW50RXJyb3JzXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czphcGlcIik7XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMztcbmNvbnN0IFRJTUVPVVRfTVMgPSAzMCAqIDEwMDA7XG5sZXQgX2NsaWVudDogQXhpb3NJbnN0YW5jZSB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICBpZiAoX2NsaWVudCkge1xuICAgIHJldHVybiBfY2xpZW50O1xuICB9XG4gIGNvbnN0IGN1cnJlbnRzQ29uZmlnID0gYXdhaXQgZ2V0Q3VycmVudHNDb25maWcoKTtcbiAgX2NsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgYmFzZVVSTDogZ2V0QVBJQmFzZVVybCgpLFxuICAgIHRpbWVvdXQ6IFRJTUVPVVRfTVMsXG4gIH0pO1xuXG4gIF9jbGllbnQuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKChjb25maWcpID0+IHtcbiAgICBjb25zdCBjY3lWZXJzb24gPSBfY3VycmVudHNWZXJzaW9uID8/IFwiMC4wLjBcIjtcbiAgICBjb25zdCBoZWFkZXJzOiBSYXdBeGlvc1JlcXVlc3RIZWFkZXJzID0ge1xuICAgICAgLi4uY29uZmlnLmhlYWRlcnMsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBcIngtY3lwcmVzcy1yZXF1ZXN0LWF0dGVtcHRcIjogY29uZmlnW1wiYXhpb3MtcmV0cnlcIl0/LnJldHJ5Q291bnQgPz8gMCxcbiAgICAgIFwieC1jeXByZXNzLXZlcnNpb25cIjogX2N5cHJlc3NWZXJzaW9uID8/IFwiMC4wLjBcIixcbiAgICAgIFwieC1jY3ktdmVyc2lvblwiOiBjY3lWZXJzb24sXG4gICAgICBcIlVzZXItQWdlbnRcIjogYGN5cHJlc3MtY2xvdWQvJHtjY3lWZXJzb259YCxcbiAgICB9O1xuICAgIGlmIChfcnVuSWQpIHtcbiAgICAgIGhlYWRlcnNbXCJ4LWN5cHJlc3MtcnVuLWlkXCJdID0gX3J1bklkO1xuICAgIH1cbiAgICBpZiAoIWhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudHNDb25maWcubmV0d29ya0hlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkSGVhZGVycyA9IF8ub21pdChjdXJyZW50c0NvbmZpZy5uZXR3b3JrSGVhZGVycywgW1xuICAgICAgICBcIngtY3lwcmVzcy1yZXF1ZXN0LWF0dGVtcHRcIixcbiAgICAgICAgXCJ4LWN5cHJlc3MtdmVyc2lvblwiLFxuICAgICAgICBcIngtY2N5LXZlcnNpb25cIixcbiAgICAgICAgXCJ4LWN5cHJlc3MtcnVuLWlkXCIsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCIsXG4gICAgICBdKTtcbiAgICAgIGRlYnVnKFwidXNpbmcgY3VzdG9tIG5ldHdvcmsgaGVhZGVyczogJW9cIiwgZmlsdGVyZWRIZWFkZXJzKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgZmlsdGVyZWRIZWFkZXJzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXEgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBoZWFkZXJzLFxuICAgIH07XG5cbiAgICBkZWJ1ZyhcIm5ldHdvcmsgcmVxdWVzdDogJW9cIiwge1xuICAgICAgLi4uXy5waWNrKHJlcSwgXCJtZXRob2RcIiwgXCJ1cmxcIiwgXCJoZWFkZXJzXCIpLFxuICAgICAgZGF0YTogQnVmZmVyLmlzQnVmZmVyKHJlcS5kYXRhKSA/IFwiYnVmZmVyXCIgOiByZXEuZGF0YSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXE7XG4gIH0pO1xuXG4gIGF4aW9zUmV0cnkoX2NsaWVudCwge1xuICAgIHJldHJpZXM6IE1BWF9SRVRSSUVTLFxuICAgIHJldHJ5Q29uZGl0aW9uOiBpc1JldHJpYWJsZUVycm9yLFxuICAgIHJldHJ5RGVsYXk6IGdldERlbGF5LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBvblJldHJ5LFxuICAgIHNob3VsZFJlc2V0VGltZW91dDogdHJ1ZSxcbiAgfSk7XG4gIHJldHVybiBfY2xpZW50O1xufVxuXG5sZXQgX3J1bklkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3Qgc2V0UnVuSWQgPSAocnVuSWQ6IHN0cmluZykgPT4ge1xuICBfcnVuSWQgPSBydW5JZDtcbn07XG5cbmxldCBfY3lwcmVzc1ZlcnNpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBzZXRDeXByZXNzVmVyc2lvbiA9IChjeXByZXNzVmVyc2lvbjogc3RyaW5nKSA9PiB7XG4gIF9jeXByZXNzVmVyc2lvbiA9IGN5cHJlc3NWZXJzaW9uO1xufTtcblxubGV0IF9jdXJyZW50c1ZlcnNpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBzZXRDdXJyZW50c1ZlcnNpb24gPSAodjogc3RyaW5nKSA9PiB7XG4gIF9jdXJyZW50c1ZlcnNpb24gPSB2O1xufTtcblxuZnVuY3Rpb24gb25SZXRyeShcbiAgcmV0cnlDb3VudDogbnVtYmVyLFxuICBlcnI6IEF4aW9zRXJyb3I8eyBtZXNzYWdlOiBzdHJpbmc7IGVycm9ycz86IHN0cmluZ1tdIH0+LFxuICBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZ1xuKSB7XG4gIHdhcm4oXG4gICAgXCJOZXR3b3JrIHJlcXVlc3QgJyVzJyBmYWlsZWQ6ICclcycuIE5leHQgYXR0ZW1wdCBpcyBpbiAlcyAoJWQvJWQpLlwiLFxuICAgIGAke2NvbmZpZy5tZXRob2R9ICR7Y29uZmlnLnVybH1gLFxuICAgIGVyci5tZXNzYWdlLFxuICAgIHByZXR0eU1pbGxpc2Vjb25kcyhnZXREZWxheShyZXRyeUNvdW50KSksXG4gICAgcmV0cnlDb3VudCxcbiAgICBNQVhfUkVUUklFU1xuICApO1xufVxuXG5leHBvcnQgY29uc3QgbWFrZVJlcXVlc3QgPSBhc3luYyA8VCA9IGFueSwgRCA9IGFueT4oXG4gIGNvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnPEQ+XG4pID0+IHtcbiAgcmV0dXJuIChhd2FpdCBnZXRDbGllbnQoKSk8RCwgQXhpb3NSZXNwb25zZTxUPj4oY29uZmlnKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGRlYnVnKFwibmV0d29yayByZXNwb25zZTogJW9cIiwgXy5vbWl0KHJlcywgXCJyZXF1ZXN0XCIsIFwiY29uZmlnXCIpKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBtYXliZVByaW50RXJyb3JzKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfSk7XG59O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcblxuaW1wb3J0IHsgUCwgbWF0Y2ggfSBmcm9tIFwidHMtcGF0dGVyblwiO1xuaW1wb3J0IHsgRGV0ZWN0ZWRCcm93c2VyLCBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IGJvb3RDeXByZXNzIH0gZnJvbSBcIi4uL2Jvb3RzdHJhcFwiO1xuaW1wb3J0IHsgaW5mbywgd2FybiB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IGdldENvbmZpZ0ZpbGVQYXRoIH0gZnJvbSBcIi4vcGF0aFwiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Y29uZmlnXCIpO1xuXG5leHBvcnQgdHlwZSBFMkVDb25maWcgPSB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIENvbXBvbmVudENvbmZpZyA9IHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG59O1xuXG50eXBlIFJldHJ5Q29uZmlnID0ge1xuICBoYXJkRmFpbHVyZU1heFJldHJpZXM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdHlwZSBmb3IgYGN1cnJlbnRzLmNvbmZpZy4qc2AuIElmIHlvdSBhcmUgbm90IG9mZmljaWFsbHkgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHlvdSBjYW4gc3RpbGwgdHlwZSB0aGUgZXhwb3J0ZWQgY29uZmlnIGluIHlvdXIgSURFIGJ5IGFkZGluZyB0aGUgZm9sbG93aW5nIGFzIGEgYmxvY2sgY29tbWVudFxuICogYWJvdmUgYG1vZHVsZS5leHBvcnRzYCAvIGBleHBvcnQgZGVmYXVsdGA6XG4gKlxuICogYEB0eXBlIHtpbXBvcnQoJ2N5cHJlc3MtY2xvdWQnKS5DdXJyZW50c0NvbmZpZ31gXG4gKi9cbmV4cG9ydCB0eXBlIEN1cnJlbnRzQ29uZmlnID0ge1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHJlY29yZEtleT86IHN0cmluZztcbiAgY2xvdWRTZXJ2aWNlVXJsOiBzdHJpbmc7XG4gIGUyZTogRTJFQ29uZmlnO1xuICBjb21wb25lbnQ6IENvbXBvbmVudENvbmZpZztcbiAgbmV0d29ya0hlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZXRyeT86IFJldHJ5Q29uZmlnO1xufTtcblxubGV0IF9jb25maWc6IEN1cnJlbnRzQ29uZmlnIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRDb25maWc6IEN1cnJlbnRzQ29uZmlnID0ge1xuICBlMmU6IHtcbiAgICBiYXRjaFNpemU6IDMsXG4gIH0sXG4gIGNvbXBvbmVudDoge1xuICAgIGJhdGNoU2l6ZTogNSxcbiAgfSxcbiAgY2xvdWRTZXJ2aWNlVXJsOiBcImh0dHBzOi8vY3kuY3VycmVudHMuZGV2XCIsXG4gIG5ldHdvcmtIZWFkZXJzOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudHNDb25maWcoXG4gIHByb2plY3RSb290Pzogc3RyaW5nLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nLFxuKTogUHJvbWlzZTxDdXJyZW50c0NvbmZpZz4ge1xuICBpZiAoX2NvbmZpZykge1xuICAgIHJldHVybiBfY29uZmlnO1xuICB9XG5cbiAgY29uc3QgY29uZmlnRmlsZVBhdGggPSBnZXRDb25maWdGaWxlUGF0aChwcm9qZWN0Um9vdCwgZXhwbGljaXRDb25maWdGaWxlUGF0aCk7XG4gIC8vIHRyeSBsb2FkaW5nIHBvc3NpYmxlIGNvbmZpZyBmaWxlc1xuICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnID0gbWF0Y2goYXdhaXQgbG9hZENvbmZpZ0ZpbGUoZmlsZXBhdGgpKVxuICAgICAgLndpdGgoeyBkZWZhdWx0OiBQLm5vdChQLm51bGxpc2gpIH0sIChjKSA9PiBjLmRlZmF1bHQpXG4gICAgICAud2l0aChQLm5vdChQLm51bGxpc2gpLCAoYykgPT4gYylcbiAgICAgIC5vdGhlcndpc2UoKCkgPT4gbnVsbCk7XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBkZWJ1ZyhcImxvYWRlZCBjdXJyZW50cyBjb25maWcgZnJvbSAnJXMnXFxuJU9cIiwgZmlsZXBhdGgsIGNvbmZpZyk7XG4gICAgICBpbmZvKFwiVXNpbmcgY29uZmlnIGZpbGU6ICclcydcIiwgZmlsZXBhdGgpO1xuICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBfY29uZmlnO1xuICAgIH1cbiAgfVxuXG4gIHdhcm4oXG4gICAgXCJGYWlsZWQgdG8gbG9hZCBjb25maWcgZmlsZSwgZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbmZpZy4gQXR0ZW1wdGVkIGxvY2F0aW9uczogJXNcIixcbiAgICBjb25maWdGaWxlUGF0aCxcbiAgKTtcbiAgX2NvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIHJldHVybiBfY29uZmlnO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkQ29uZmlnRmlsZShmaWxlcGF0aDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgZGVidWcoXCJsb2FkaW5nIGN1cnJlbnRzIGNvbmZpZyBmaWxlIGZyb20gJyVzJ1wiLCBmaWxlcGF0aCk7XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydChmaWxlcGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcImZhaWxlZCBsb2FkaW5nIGNvbmZpZyBmaWxlIGZyb206ICVzXCIsIGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE1lcmdlZENvbmZpZyA9IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgZ2V0TWVyZ2VkQ29uZmlnPj47XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWVyZ2VkQ29uZmlnKHBhcmFtczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzKSB7XG4gIGRlYnVnKFwicmVzb2x2aW5nIGN5cHJlc3MgY29uZmlnXCIpO1xuICBjb25zdCBjeXByZXNzUmVzb2x2ZWRDb25maWc6XG4gICAgfCAoQ3lwcmVzcy5SZXNvbHZlZENvbmZpZ09wdGlvbnMgJiB7XG4gICAgICAgIHByb2plY3RSb290OiBzdHJpbmc7XG4gICAgICAgIHJhd0pzb246IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICBicm93c2VyczogRGV0ZWN0ZWRCcm93c2VyW107XG4gICAgICB9KVxuICAgIHwgdW5kZWZpbmVkID0gYXdhaXQgYm9vdEN5cHJlc3MocGFyYW1zKTtcblxuICBkZWJ1ZyhcImN5cHJlc3MgcmVzb2x2ZWRDb25maWc6ICVPXCIsIGN5cHJlc3NSZXNvbHZlZENvbmZpZyk7XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCByYXdFMkVQYXR0ZXJuID0gY3lwcmVzc1Jlc29sdmVkQ29uZmlnLnJhd0pzb24/LmUyZT8uc3BlY1BhdHRlcm47XG4gIGxldCBhZGRpdGlvbmFsSWdub3JlUGF0dGVybjogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHBhcmFtcy50ZXN0aW5nVHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiByYXdFMkVQYXR0ZXJuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuID0gcmF3RTJFUGF0dGVybjtcbiAgfVxuXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvZWQwNjY4ZTI0YzJlZTY3NTNiYmQyNWFlNDY3Y2U5NGFlNTg1Nzc0MS9wYWNrYWdlcy9jb25maWcvc3JjL29wdGlvbnMudHMjTDQ1N1xuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcy9ibG9iL2RldmVsb3AvcGFja2FnZXMvY29uZmlnL3NyYy9wcm9qZWN0L3V0aWxzLnRzI0w0MTJcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb2plY3RSb290OiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnByb2plY3RSb290IHx8IHByb2Nlc3MuY3dkKCksXG4gICAgcHJvamVjdElkOiBwYXJhbXMucHJvamVjdElkLFxuICAgIHNwZWNQYXR0ZXJuOiBjeXByZXNzUmVzb2x2ZWRDb25maWc/LnNwZWNQYXR0ZXJuIHx8IFwiKiovKi4qXCIsXG4gICAgZXhjbHVkZVNwZWNQYXR0ZXJuOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY3lwcmVzc1Jlc29sdmVkQ29uZmlnPy5yZXNvbHZlZC5leGNsdWRlU3BlY1BhdHRlcm4udmFsdWUgPz8gW10sXG4gICAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG4gICAgcmVzb2x2ZWQ6IGN5cHJlc3NSZXNvbHZlZENvbmZpZyxcbiAgICBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZzogcGFyYW1zLmV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nLFxuICB9O1xuICBkZWJ1ZyhcIm1lcmdlZCBjb25maWc6ICVPXCIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCAiaW1wb3J0IHsgZ2V0QmluUGF0aCB9IGZyb20gXCJjeTJcIjtcbmltcG9ydCB7IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyB9IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZXhlY2EsIHsgRXhlY2FFcnJvciB9IGZyb20gXCJleGVjYVwiO1xuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgY3JlYXRlVGVtcEZpbGUgfSBmcm9tIFwiLi4vZnNcIjtcbmltcG9ydCB7IGJvbGQsIGluZm8gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyByZXF1aXJlIH0gZnJvbSBcIi4uL3JlcXVpcmVcIjtcbmltcG9ydCB7IGdldEJvb3RzdHJhcEFyZ3MgfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpib290XCIpO1xuXG5leHBvcnQgY29uc3QgYm9vdEN5cHJlc3MgPSBhc3luYyAocGFyYW1zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnMpID0+IHtcbiAgZGVidWcoXCJib290aW5nIGN5cHJlc3MuLi5cIik7XG4gIGNvbnN0IHRlbXBGaWxlUGF0aCA9IGF3YWl0IGNyZWF0ZVRlbXBGaWxlKCk7XG5cbiAgY29uc3QgY3lwcmVzc0JpbiA9IGF3YWl0IGdldEJpblBhdGgocmVxdWlyZS5yZXNvbHZlKFwiY3lwcmVzc1wiKSk7XG4gIGRlYnVnKFwiY3lwcmVzcyBleGVjdXRhYmxlIGxvY2F0aW9uOiAlc1wiLCBjeXByZXNzQmluKTtcblxuICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8gcGFzcyB0aGUgc2FtZSBhcmdzIGluIG9yZGVyIHRvIGdldCB0aGUgc2FtZSBjb25maWcgYXMgZm9yIHRoZSBhY3R1YWwgcnVuXG4gIGNvbnN0IGFyZ3MgPSBnZXRCb290c3RyYXBBcmdzKHsgdGVtcEZpbGVQYXRoLCBwYXJhbXMgfSk7XG4gIGRlYnVnKFwiYm9vdGluZyBjeXByZXNzIHdpdGggYXJnczogJW9cIiwgYXJncyk7XG4gIGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWNDeXByZXNzKGN5cHJlc3NCaW4sIGFyZ3MpO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyh0ZW1wRmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCByZXNvbHZlIGN5cHJlc3MgY29uZmlndXJhdGlvbiBmcm9tICR7dGVtcEZpbGVQYXRofS4gUGxlYXNlIHJlcG9ydCB0aGUgaXNzdWUuYFxuICAgICk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmID0gZnMucmVhZEZpbGVTeW5jKHRlbXBGaWxlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICBpZiAoIWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklzIGN5cHJlc3MtY2xvdWQvcGx1Z2luIGluc3RhbGxlZD9cIik7XG4gICAgfVxuICAgIGRlYnVnKFwiY3lwcmVzcyBjb25maWcgJyVzJzogJyVzJ1wiLCB0ZW1wRmlsZVBhdGgsIGYpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZyhcInJlYWQgY29uZmlnIHRlbXAgZmlsZSBmYWlsZWQ6ICVvXCIsIGVycik7XG4gICAgaW5mbyhib2xkKFwiQ3lwcmVzcyBzdGRvdXQ6XFxuXCIpLCBzdGRvdXQpO1xuICAgIGluZm8oYm9sZChcIkN5cHJlc3Mgc3RkZXJyOlxcblwiKSwgc3RkZXJyKTtcblxuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIGN5cHJlc3MgY29uZmlndXJhdGlvblxuLSBtYWtlIHN1cmUgdGhhdCAnY3lwcmVzcy1jbG91ZC9wbHVnaW4nIGlzIGluc3RhbGxlZFxuLSByZXBvcnQgdGhlIGlzc3VlIHRvZ2V0aGVyIHdpdGggY3lwcmVzcyBzdGRvdXQgYW5kIHN0ZGVyclxuYCk7XG4gIH1cbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGV4ZWNDeXByZXNzKGN5cHJlc3NCaW46IHN0cmluZywgYXJnczogcmVhZG9ubHkgc3RyaW5nW10pIHtcbiAgbGV0IHN0ZG91dCA9IFwiXCI7XG4gIGxldCBzdGRlcnIgPSBcIlwiO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWNhKGN5cHJlc3NCaW4sIFtcInJ1blwiLCAuLi5hcmdzXSwge1xuICAgICAgc3RkaW86IFwicGlwZVwiLFxuICAgICAgZW52OiB7XG4gICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAvLyBwcmV2ZW50IHdhcm5pbmdzIGFib3V0IHJlY29yZGluZyBtb2RlXG4gICAgICAgIENZUFJFU1NfUkVDT1JEX0tFWTogdW5kZWZpbmVkLFxuICAgICAgICBDWVBSRVNTX1BST0pFQ1RfSUQ6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlYnVnKFwiZXhlYyBjeXByZXNzIGZhaWxlZCAoY2VydGFpbiBmYWlsdXJlcyBhcmUgZXhwZWN0ZWQpOiAlb1wiLCBlcnIpO1xuICAgIHN0ZG91dCA9IChlcnIgYXMgRXhlY2FFcnJvcikuc3Rkb3V0O1xuICAgIHN0ZGVyciA9IChlcnIgYXMgRXhlY2FFcnJvcikuc3RkZXJyO1xuICB9XG4gIHJldHVybiB7IHN0ZG91dCwgc3RkZXJyIH07XG59XG4iLCAiZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZpbGUgfSBmcm9tIFwidG1wLXByb21pc2VcIjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbXBGaWxlID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IHBhdGggfSA9IGF3YWl0IGZpbGUoKTtcbiAgcmV0dXJuIHBhdGg7XG59O1xuIiwgImltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCB1dGlsIGZyb20gXCJ1dGlsXCI7XG5cbmNvbnN0IGxvZyA9ICguLi5hcmdzOiB1bmtub3duW10pID0+IGNvbnNvbGUubG9nKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKTtcblxuZXhwb3J0IGNvbnN0IGluZm8gPSBsb2c7XG5leHBvcnQgY29uc3QgZm9ybWF0ID0gdXRpbC5mb3JtYXQ7XG5cbmV4cG9ydCBjb25zdCB3aXRoRXJyb3IgPSAobXNnOiBzdHJpbmcpID0+XG4gIGNoYWxrLmJnUmVkLndoaXRlKFwiIEVSUk9SIFwiKSArIFwiIFwiICsgbXNnO1xuZXhwb3J0IGNvbnN0IHdpdGhXYXJuaW5nID0gKG1zZzogc3RyaW5nKSA9PlxuICBjaGFsay5iZ1llbGxvdy5ibGFjayhcIiBXQVJOSU5HIFwiKSArIFwiIFwiICsgbXNnO1xuXG5leHBvcnQgY29uc3Qgd2FybiA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyh3aXRoV2FybmluZyh1dGlsLmZvcm1hdCguLi5hcmdzKSkpO1xuXG5leHBvcnQgY29uc3Qgc3VjY2VzcyA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGxvZyhjaGFsay5ncmVlbih1dGlsLmZvcm1hdCguLi5hcmdzKSkpO1xuXG5leHBvcnQgY29uc3QgZXJyb3IgPSAoLi4uYXJnczogdW5rbm93bltdKSA9PlxuICBsb2cod2l0aEVycm9yKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSArIFwiXFxuXCIpO1xuXG50eXBlIENvbG9yID0gXCJyZWRcIiB8IFwiZ3JlZW5cIiB8IFwieWVsbG93XCIgfCBcImJsdWVcIiB8IFwibWFnZW50YVwiIHwgXCJjeWFuXCIgfCBcIndoaXRlXCI7XG5leHBvcnQgY29uc3QgdGl0bGUgPSAoY29sb3I6IENvbG9yLCAuLi5hcmdzOiB1bmtub3duW10pID0+XG4gIGluZm8oXCJcXG5cIiArIFwiICBcIiArIGNoYWxrW2NvbG9yXS5ib2xkKHV0aWwuZm9ybWF0KC4uLmFyZ3MpKSArIFwiICBcIiArIFwiXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgZGl2aWRlciA9ICgpID0+XG4gIGNvbnNvbGUubG9nKFwiXFxuXCIgKyBjaGFsay5ncmF5KEFycmF5KDEwMCkuZmlsbChcIj1cIikuam9pbihcIlwiKSkgKyBcIlxcblwiKTtcblxuZXhwb3J0IGNvbnN0IHNwYWNlciA9IChuOiBudW1iZXIgPSAwKSA9PlxuICBjb25zb2xlLmxvZyhBcnJheShuKS5maWxsKFwiXCIpLmpvaW4oXCJcXG5cIikpO1xuXG5leHBvcnQgY29uc3QgY3lhbiA9IGNoYWxrLmN5YW47XG5leHBvcnQgY29uc3QgYmx1ZSA9IGNoYWxrLmJsdWVCcmlnaHQ7XG5leHBvcnQgY29uc3QgcmVkID0gY2hhbGsucmVkO1xuZXhwb3J0IGNvbnN0IGdyZWVuID0gY2hhbGsuZ3JlZW5CcmlnaHQ7XG5leHBvcnQgY29uc3QgZ3JheSA9IGNoYWxrLmdyYXk7XG5leHBvcnQgY29uc3Qgd2hpdGUgPSBjaGFsay53aGl0ZTtcbmV4cG9ydCBjb25zdCBtYWdlbnRhID0gY2hhbGsubWFnZW50YTtcbmV4cG9ydCBjb25zdCBib2xkID0gY2hhbGsuYm9sZDtcbmV4cG9ydCBjb25zdCB5ZWxsb3cgPSBjaGFsay55ZWxsb3c7XG5leHBvcnQgY29uc3QgZGltID0gY2hhbGsuZGltO1xuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgQ3lwcmVzc1J1blBhcmFtZXRlcnMsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7IGdldEN5cHJlc3NSdW5BUElQYXJhbXMgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Ym9vdFwiKTtcblxuY29uc3QgZ2V0RHVtbXlTcGVjID0gY3VzdG9tQWxwaGFiZXQoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLCAxMCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb290c3RyYXBBcmdzKHtcbiAgcGFyYW1zLFxuICB0ZW1wRmlsZVBhdGgsXG59OiB7XG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzO1xuICB0ZW1wRmlsZVBhdGg6IHN0cmluZztcbn0pIHtcbiAgcmV0dXJuIF8uY2hhaW4oZ2V0Q3lwcmVzc0NMSVBhcmFtcyhwYXJhbXMpKVxuICAgIC50aHJ1KChvcHRzKSA9PiAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIC8vIG1lcmdlIHRoZSBlbnYgd2l0aCB0aGUgY3VycmVudHMgc3BlY2lmaWMgZW52IHZhcmlhYmxlc1xuICAgICAgZW52OiB7XG4gICAgICAgIC4uLihvcHRzLmVudiA/PyB7fSksXG4gICAgICAgIGN1cnJlbnRzX3RlbXBfZmlsZTogdGVtcEZpbGVQYXRoLFxuICAgICAgICBjdXJyZW50c19kZWJ1Z19lbmFibGVkOiBwcm9jZXNzLmVudi5ERUJVRz8uaW5jbHVkZXMoXCJjdXJyZW50czpcIilcbiAgICAgICAgICA/IHRydWVcbiAgICAgICAgICA6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KSlcbiAgICAudGFwKChvcHRzKSA9PiB7XG4gICAgICBkZWJ1ZyhcImN5cHJlc3MgYm9vdHN0cmFwIHBhcmFtczogJW9cIiwgb3B0cyk7XG4gICAgfSlcbiAgICAudGhydShzZXJpYWxpemVPcHRpb25zKVxuICAgIC50YXAoKG9wdHMpID0+IHtcbiAgICAgIGRlYnVnKFwiY3lwcmVzcyBib290c3RyYXAgc2VyaWFsaXplZCBwYXJhbXM6ICVvXCIsIG9wdHMpO1xuICAgIH0pXG4gICAgLnRocnUoKGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIFwiLS1zcGVjXCIsXG4gICAgICAgIGdldER1bW15U3BlYygpLFxuICAgICAgICBwYXJhbXMudGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCIgPyBcIi0tY29tcG9uZW50XCIgOiBcIi0tZTJlXCIsXG4gICAgICBdO1xuICAgIH0pXG4gICAgLnZhbHVlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgQ3VycmVudHMgb3B0aW9ucyB0byBDeXByZXNzIENMSSBwYXJhbXMuXG4gKiBDeXByZXNzIENMSSBvcHRpb25zIGFyZSBkaWZmZXJlbnQgZnJvbSBDeXByZXNzIG1vZHVsZSBBUEkgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcGFyYW1zIEN1cnJlbnRzIHBhcmFtXG4gKiBAcmV0dXJucyBDeXByZXNzIENMSSBwYXJhbXNcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2d1aWRlcy9jb21tYW5kLWxpbmUjY3lwcmVzcy1ydW5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vYXBpL21vZHVsZS1hcGlcbiAqL1xuZnVuY3Rpb24gZ2V0Q3lwcmVzc0NMSVBhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN5cHJlc3NSdW5QYXJhbWV0ZXJzIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhwYXJhbXMpO1xuICBjb25zdCB0ZXN0aW5nVHlwZSA9XG4gICAgcmVzdWx0LnRlc3RpbmdUeXBlID09PSBcImNvbXBvbmVudFwiXG4gICAgICA/IHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIDoge307XG4gIHJldHVybiB7XG4gICAgLi4uXy5vbWl0KHJlc3VsdCwgXCJ0ZXN0aW5nVHlwZVwiKSxcbiAgICAuLi50ZXN0aW5nVHlwZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZsYXRNYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IF9rZXkgPSBkYXNoZWQoa2V5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gW2AtLSR7X2tleX1gXSA6IFtgLS0ke19rZXl9YCwgZmFsc2VdO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtgLS0ke19rZXl9YCwgc2VyaWFsaXplQ29tcGxleFBhcmFtKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBbYC0tJHtfa2V5fWAsIHZhbHVlLnRvU3RyaW5nKCldO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQ29tcGxleFBhcmFtKHBhcmFtOiB7fSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW0pO1xufVxuXG5jb25zdCBkYXNoZWQgPSAodjogc3RyaW5nKSA9PiB2LnJlcGxhY2UoL1tBLVpdL2csIChtKSA9PiBcIi1cIiArIG0udG9Mb3dlckNhc2UoKSk7XG4iLCAiaW1wb3J0IGlzQWJzb2x1dGUgZnJvbSBcImlzLWFic29sdXRlXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEZpbGVuYW1lcyA9IFtcbiAgXCJjdXJyZW50cy5jb25maWcuanNcIixcbiAgXCJjdXJyZW50cy5jb25maWcuY2pzXCIsXG4gIFwiY3VycmVudHMuY29uZmlnLm1qc1wiLFxuXTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWdGaWxlUGF0aChcbiAgcHJvamVjdFJvb3Q6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICBleHBsaWNpdENvbmZpZ0ZpbGVQYXRoPzogc3RyaW5nXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHByZWZpeCA9IHByb2plY3RSb290ID8/IHByb2Nlc3MuY3dkKCk7XG4gIGlmIChcbiAgICBfLmlzU3RyaW5nKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpICYmXG4gICAgaXNBYnNvbHV0ZShleHBsaWNpdENvbmZpZ0ZpbGVQYXRoKVxuICApIHtcbiAgICByZXR1cm4gW2V4cGxpY2l0Q29uZmlnRmlsZVBhdGhdO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGV4cGxpY2l0Q29uZmlnRmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuIFtub3JtYWxpemVQYXRoKHByZWZpeCwgZXhwbGljaXRDb25maWdGaWxlUGF0aCldO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZXMubWFwKChwKSA9PiBub3JtYWxpemVQYXRoKHByZWZpeCwgcCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwcmVmaXg6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgZmlsZTovLyR7cGF0aC5yZXNvbHZlKHByZWZpeCwgZmlsZW5hbWUpfWA7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLFxuICBDeXByZXNzUnVuUGFyYW1ldGVycyxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50c0NvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnZhbGlkYXRlUGFyYW1zXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRzUGFyYW1zKFxuICBwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxDdXJyZW50c1J1blBhcmFtZXRlcnM+IHtcbiAgY29uc3QgY29uZmlnRnJvbUZpbGUgPSBhd2FpdCBnZXRDdXJyZW50c0NvbmZpZyhcbiAgICBwYXJhbXMucHJvamVjdCxcbiAgICBwYXJhbXMuY2xvdWRDb25maWdGaWxlXG4gICk7XG5cbiAgZGVidWcoXCJyZXNvbHZpbmcgY3VycmVudHMgcGFyYW1zOiAlb1wiLCBwYXJhbXMpO1xuICBkZWJ1ZyhcInJlc29sdmluZyBjdXJyZW50cyBjb25maWcgZmlsZTogJW9cIiwgY29uZmlnRnJvbUZpbGUpO1xuICBjb25zdCBjbG91ZFNlcnZpY2VVcmwgPVxuICAgIHBhcmFtcy5jbG91ZFNlcnZpY2VVcmwgPz9cbiAgICBwcm9jZXNzLmVudi5DVVJSRU5UU19BUElfVVJMID8/XG4gICAgY29uZmlnRnJvbUZpbGUuY2xvdWRTZXJ2aWNlVXJsO1xuXG4gIGNvbnN0IHJlY29yZEtleSA9XG4gICAgcGFyYW1zLnJlY29yZEtleSA/P1xuICAgIHByb2Nlc3MuZW52LkNVUlJFTlRTX1JFQ09SRF9LRVkgPz9cbiAgICBjb25maWdGcm9tRmlsZS5yZWNvcmRLZXk7XG5cbiAgY29uc3QgcHJvamVjdElkID1cbiAgICBwYXJhbXMucHJvamVjdElkID8/XG4gICAgcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUFJPSkVDVF9JRCA/P1xuICAgIGNvbmZpZ0Zyb21GaWxlLnByb2plY3RJZDtcblxuICBjb25zdCB0ZXN0aW5nVHlwZSA9IHBhcmFtcy50ZXN0aW5nVHlwZSA/PyBcImUyZVwiO1xuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9XG4gICAgdGVzdGluZ1R5cGUgPT09IFwiZTJlXCJcbiAgICAgID8gY29uZmlnRnJvbUZpbGUuZTJlLmJhdGNoU2l6ZVxuICAgICAgOiBjb25maWdGcm9tRmlsZS5jb21wb25lbnQuYmF0Y2hTaXplO1xuXG4gIC8vIGJhdGNoU2l6ZSBhbmQgY2xvdWRTZXJ2aWNlVXJsIGRlZmF1bHRzIGFyZSBpbiBnZXRDdXJyZW50c0NvbmZpZygpXG4gIHJldHVybiB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGNsb3VkU2VydmljZVVybCxcbiAgICByZWNvcmRLZXksXG4gICAgcHJvamVjdElkLFxuICAgIGJhdGNoU2l6ZSxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHByb2plY3RJZEVycm9yID0gYENhbm5vdCByZXNvbHZlIHByb2plY3RJZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi0gcHJvdmlkZSBpdCBhcyBhIFwicHJvamVjdElkXCIgcHJvcGVydHkgZm9yIFwicnVuXCIgQVBJIG1ldGhvZFxuLSBzZXQgQ1VSUkVOVFNfUFJPSkVDVF9JRCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuLSBzZXQgXCJwcm9qZWN0SWRcIiBpbiBcImN1cnJlbnRzLmNvbmZpZy57Y31qc1wiIGZpbGVgO1xuXG5leHBvcnQgY29uc3QgY2xvdWRTZXJ2aWNlVXJsRXJyb3IgPSBgQ2Fubm90IHJlc29sdmUgY2xvdWQgc2VydmljZSBVUkwuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4tIHByb3ZpZGUgaXQgYXMgYSBcImNsb3VkU2VydmljZVVybFwiIHByb3BlcnR5IGZvciBcInJ1blwiIEFQSSBtZXRob2Rcbi0gc2V0IENVUlJFTlRTX0FQSV9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGVcbi0gc2V0IFwiY2xvdWRTZXJ2aWNlVXJsXCIgaW4gXCJjdXJyZW50cy5jb25maWcue2N9anNcIiBmaWxlYDtcblxuZXhwb3J0IGNvbnN0IGNsb3VkU2VydmljZUludmFsaWRVcmxFcnJvciA9IGBJbnZhbGlkIGNsb3VkIHNlcnZpY2UgVVJMIHByb3ZpZGVkYDtcblxuZXhwb3J0IGNvbnN0IHJlY29yZEtleUVycm9yID0gYENhbm5vdCByZXNvbHZlIHJlY29yZCBrZXkuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cbi0gcGFzcyBpdCBhcyBhIENMSSBmbGFnICctaywgLS1rZXkgPHJlY29yZC1rZXk+J1xuLSBwcm92aWRlIGl0IGFzIGEgXCJyZWNvcmRLZXlcIiBwcm9wZXJ0eSBmb3IgXCJydW5cIiBBUEkgbWV0aG9kXG4tIHNldCBDVVJSRU5UU19SRUNPUkRfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXG4tIHNldCBcInJlY29yZEtleVwiIGluIFwiY3VycmVudHMuY29uZmlnLntjfWpzXCIgZmlsZVxuYDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1zKFxuICBfcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IFByb21pc2U8VmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzPiB7XG4gIGNvbnN0IHBhcmFtcyA9IGF3YWl0IHJlc29sdmVDdXJyZW50c1BhcmFtcyhfcGFyYW1zKTtcblxuICBkZWJ1ZyhcInZhbGlkYXRpbmcgY3VycmVudHMgcGFyYW1zOiAlb1wiLCBwYXJhbXMpO1xuICBpZiAoIXBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGNsb3VkU2VydmljZVVybEVycm9yKTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wcm9qZWN0SWQpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHByb2plY3RJZEVycm9yKTtcbiAgfVxuICBpZiAoIXBhcmFtcy5yZWNvcmRLZXkpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHJlY29yZEtleUVycm9yKTtcbiAgfVxuXG4gIHZhbGlkYXRlVVJMKHBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpO1xuXG4gIGNvbnN0IHJlcXVpcmVkUGFyYW1ldGVyczogQXJyYXk8a2V5b2YgQ3VycmVudHNSdW5QYXJhbWV0ZXJzPiA9IFtcbiAgICBcInRlc3RpbmdUeXBlXCIsXG4gICAgXCJiYXRjaFNpemVcIixcbiAgICBcInByb2plY3RJZFwiLFxuICBdO1xuICByZXF1aXJlZFBhcmFtZXRlcnMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIFwiJXNcIicsIGtleSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlclwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIHBhcmFtcy50YWcgPSBwYXJzZVRhZ3MocGFyYW1zLnRhZyk7XG4gIHBhcmFtcy5hdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlcyA9IGdldEF1dG9DYW5jZWxWYWx1ZShcbiAgICBwYXJhbXMuYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXNcbiAgKTtcblxuICBkZWJ1ZyhcInZhbGlkYXRlZCBjdXJyZW50cyBwYXJhbXM6ICVvXCIsIHBhcmFtcyk7XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2FzdCBhZnRlciBmaW5kaW5nIGEgd2F5IHRvIHByb3Blcmx5IHJlc29sdmUgcGFyYW1zIHR5cGUgYWZ0ZXIgdmFsaWRhdGlvbnNcbiAgcmV0dXJuIHBhcmFtcyBhcyBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnM7XG59XG5cbmZ1bmN0aW9uIGdldEF1dG9DYW5jZWxWYWx1ZSh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IGZhbHNlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgYGF1dG9DYW5jZWxBZnRlckZhaWx1cmVzOiBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIFwiZmFsc2VcIi4gR290OiBcIiR7dmFsdWV9XCJgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09mZmxpbmUocGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIHBhcmFtcy5yZWNvcmQgPT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRhZ3ModGFnU3RyaW5nOiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJ0YWdcIl0pOiBzdHJpbmdbXSB7XG4gIGlmICghdGFnU3RyaW5nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhZ1N0cmluZykpIHtcbiAgICByZXR1cm4gdGFnU3RyaW5nLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICByZXR1cm4gdGFnU3RyaW5nXG4gICAgLnNwbGl0KFwiLFwiKVxuICAgIC5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVSTCh1cmw6IHN0cmluZyk6IHZvaWQge1xuICB0cnkge1xuICAgIG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgJHtjbG91ZFNlcnZpY2VJbnZhbGlkVXJsRXJyb3J9OiBcIiR7dXJsfVwiYCk7XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHJldHVybnMgQ3lwcmVzcyBvcHRpb25zIHdpdGhvdXQgaXRlbXMgdGhhdCBhZmZlY3QgcmVjb3JkaW5nIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN5cHJlc3NSdW5BUElQYXJhbXMoXG4gIHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzXG4pOiBDeXByZXNzUnVuUGFyYW1ldGVycyB7XG4gIHJldHVybiB7XG4gICAgLi4uXy5waWNrQnkoXG4gICAgICBfLm9taXQocGFyYW1zLCBbXG4gICAgICAgIFwiY2xvdWREZWJ1Z1wiLFxuICAgICAgICBcImNsb3VkQ29uZmlnRmlsZVwiLFxuICAgICAgICBcImF1dG9DYW5jZWxBZnRlckZhaWx1cmVzXCIsXG4gICAgICAgIFwiY2xvdWRTZXJ2aWNlVXJsXCIsXG4gICAgICAgIFwiYmF0Y2hTaXplXCIsXG4gICAgICAgIFwicHJvamVjdElkXCIsXG4gICAgICAgIFwia2V5XCIsXG4gICAgICAgIFwicmVjb3JkS2V5XCIsXG4gICAgICAgIFwicmVjb3JkXCIsXG4gICAgICAgIFwiZ3JvdXBcIixcbiAgICAgICAgXCJwYXJhbGxlbFwiLFxuICAgICAgICBcInRhZ1wiLFxuICAgICAgICBcImNpQnVpbGRJZFwiLFxuICAgICAgICBcInNwZWNcIixcbiAgICAgICAgXCJleGl0XCIsXG4gICAgICAgIFwiaGVhZGxlc3NcIixcbiAgICAgICAgXCJleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZ1wiLFxuICAgICAgXSksXG4gICAgICBCb29sZWFuXG4gICAgKSxcbiAgICByZWNvcmQ6IGZhbHNlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2Vzc1BhcmFtcyhcbiAgcGFyYW1zOiBDdXJyZW50c1J1blBhcmFtZXRlcnNcbik6IEN1cnJlbnRzUnVuUGFyYW1ldGVycyB7XG4gIHJldHVybiB7XG4gICAgLi4ucGFyYW1zLFxuICAgIHNwZWM6IHByb2Nlc3NTcGVjUGFyYW0ocGFyYW1zLnNwZWMpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzU3BlY1BhcmFtKFxuICBzcGVjOiBDdXJyZW50c1J1blBhcmFtZXRlcnNbXCJzcGVjXCJdXG4pOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gIGlmICghc3BlYykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgIHJldHVybiBfLmZsYXR0ZW4oc3BlYy5tYXAoKGkpID0+IGkuc3BsaXQoXCIsXCIpKSk7XG4gIH1cblxuICByZXR1cm4gc3BlYy5zcGxpdChcIixcIik7XG59XG4iLCAiaW1wb3J0IHsgQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgc3BhY2VyLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVQcmludEVycm9ycyhcbiAgZXJyOiBBeGlvc0Vycm9yPHsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcnM/OiBzdHJpbmdbXSB9PlxuKSB7XG4gIGlmICghZXJyLnJlc3BvbnNlPy5kYXRhIHx8ICFlcnIucmVzcG9uc2U/LnN0YXR1cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHsgbWVzc2FnZSwgZXJyb3JzIH0gPSBlcnIucmVzcG9uc2UuZGF0YTtcblxuICBzd2l0Y2ggKGVyci5yZXNwb25zZS5zdGF0dXMpIHtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHdhcm4oXCJSZWNlaXZlZCA0MDEgVW5hdXRob3JpemVkXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0MjI6XG4gICAgICBzcGFjZXIoMSk7XG4gICAgICB3YXJuKC4uLmZvcm1hdEdlbmVyaWNFcnJvcihtZXNzYWdlLCBlcnJvcnMpKTtcbiAgICAgIHNwYWNlcigxKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0R2VuZXJpY0Vycm9yKFxuICBtZXNzYWdlPzogc3RyaW5nLFxuICBlcnJvcnM/OiBzdHJpbmdbXVxuKTogc3RyaW5nW10ge1xuICBpZiAoIV8uaXNTdHJpbmcobWVzc2FnZSkpIHtcbiAgICByZXR1cm4gW1wiVW5leHBlY3RlZCBlcnJvciBmcm9tIHRoZSBjbG91ZCBzZXJ2aWNlXCJdO1xuICB9XG5cbiAgaWYgKGVycm9ycz8ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFttZXNzYWdlIGFzIHN0cmluZ107XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBtZXNzYWdlIGFzIHN0cmluZyxcbiAgICBgXG4keyhlcnJvcnMgPz8gW10pLm1hcCgoZSkgPT4gYCAgLSAke2V9YCkuam9pbihcIlxcblwiKX1cbmAsXG4gIF07XG59XG4iLCAiaW1wb3J0IHsgcmVxdWlyZSB9IGZyb20gXCIuLi9saWIvcmVxdWlyZVwiO1xuaW1wb3J0IFwiLi9zdGRvdXRcIjtcbmltcG9ydCBcIi4vd3NcIjtcblxuY29uc3QgY3lwcmVzc1BrZyA9IHJlcXVpcmUoXCJjeXByZXNzL3BhY2thZ2UuanNvblwiKTtcbmNvbnN0IHBrZyA9IHJlcXVpcmUoXCJjeXByZXNzLWNsb3VkL3BhY2thZ2UuanNvblwiKTtcblxuaW1wb3J0IHsgaW5pdENhcHR1cmUgfSBmcm9tIFwiLi9jYXB0dXJlXCI7XG5pbXBvcnQgeyBzZXRDdXJyZW50c1ZlcnNpb24sIHNldEN5cHJlc3NWZXJzaW9uIH0gZnJvbSBcIi4vaHR0cENsaWVudFwiO1xuXG5pbml0Q2FwdHVyZSgpO1xuc2V0Q3lwcmVzc1ZlcnNpb24oY3lwcmVzc1BrZy52ZXJzaW9uKTtcbnNldEN1cnJlbnRzVmVyc2lvbihwa2cudmVyc2lvbik7XG4iLCAiaW1wb3J0IFwiLi9pbml0XCI7XG5cbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBwbHVyIGZyb20gXCJwbHVyXCI7XG5pbXBvcnQgeyBnZXRMZWdhbE5vdGljZSB9IGZyb20gXCIuLi9sZWdhbFwiO1xuaW1wb3J0IHsgQ3VycmVudHNSdW5QYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVSdW4gfSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCB7IGN1dEluaXRpYWxPdXRwdXQsIGdldENhcHR1cmVkT3V0cHV0IH0gZnJvbSBcIi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgZ2V0Q0kgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBnZXRNZXJnZWRDb25maWcsXG4gIGlzT2ZmbGluZSxcbiAgcHJlcHJvY2Vzc1BhcmFtcyxcbiAgdmFsaWRhdGVQYXJhbXMsXG59IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsgZ2V0Q292ZXJhZ2VGaWxlUGF0aCB9IGZyb20gXCIuL2NvdmVyYWdlXCI7XG5pbXBvcnQgeyBydW5CYXJlQ3lwcmVzcyB9IGZyb20gXCIuL2N5cHJlc3NcIjtcbmltcG9ydCB7IGFjdGl2YXRlRGVidWcgfSBmcm9tIFwiLi9kZWJ1Z1wiO1xuaW1wb3J0IHsgaXNDdXJyZW50cyB9IGZyb20gXCIuL2VudlwiO1xuaW1wb3J0IHsgZ2V0R2l0SW5mbyB9IGZyb20gXCIuL2dpdFwiO1xuaW1wb3J0IHsgc2V0QVBJQmFzZVVybCwgc2V0UnVuSWQgfSBmcm9tIFwiLi9odHRwQ2xpZW50XCI7XG5pbXBvcnQgeyBib2xkLCBkaW0sIGRpdmlkZXIsIGluZm8sIHNwYWNlciwgdGl0bGUsIHdhcm4sIHllbGxvdyB9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm0gfSBmcm9tIFwiLi9wbGF0Zm9ybVwiO1xuaW1wb3J0IHsgcHVic3ViIH0gZnJvbSBcIi4vcHVic3ViXCI7XG5pbXBvcnQgeyBzdW1tYXJpemVUZXN0UmVzdWx0cywgc3VtbWFyeVRhYmxlIH0gZnJvbSBcIi4vcmVzdWx0c1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVwb3J0VGFza1NwZWMsXG4gIHJlcG9ydFRhc2tzLFxuICBydW5UaWxsRG9uZU9yQ2FuY2VsbGVkLFxufSBmcm9tIFwiLi9ydW5uZXJcIjtcbmltcG9ydCB7IHNodXRkb3duIH0gZnJvbSBcIi4vc2h1dGRvd25cIjtcbmltcG9ydCB7IGdldFNwZWNGaWxlcyB9IGZyb20gXCIuL3NwZWNNYXRjaGVyXCI7XG5pbXBvcnQgeyBDb25maWdTdGF0ZSwgRXhlY3V0aW9uU3RhdGUgfSBmcm9tIFwiLi9zdGF0ZVwiO1xuaW1wb3J0IHsgc3RhcnRXU1MgfSBmcm9tIFwiLi93c1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6cnVuXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuKHBhcmFtczogQ3VycmVudHNSdW5QYXJhbWV0ZXJzID0ge30pIHtcbiAgY29uc3QgZXhlY3V0aW9uU3RhdGUgPSBuZXcgRXhlY3V0aW9uU3RhdGUoKTtcbiAgY29uc3QgY29uZmlnU3RhdGUgPSBuZXcgQ29uZmlnU3RhdGUoKTtcbiAgYWN0aXZhdGVEZWJ1ZyhwYXJhbXMuY2xvdWREZWJ1Zyk7XG4gIGRlYnVnKFwicnVuIHBhcmFtcyAlb1wiLCBwYXJhbXMpO1xuICBwYXJhbXMgPSBwcmVwcm9jZXNzUGFyYW1zKHBhcmFtcyk7XG4gIGRlYnVnKFwicGFyYW1zIGFmdGVyIHByZXByb2Nlc3MgJW9cIiwgcGFyYW1zKTtcblxuICBpZiAoaXNPZmZsaW5lKHBhcmFtcykpIHtcbiAgICBpbmZvKGBTa2lwcGluZyBjbG91ZCBvcmNoZXN0cmF0aW9uIGJlY2F1c2UgLS1yZWNvcmQgaXMgc2V0IHRvIGZhbHNlYCk7XG4gICAgcmV0dXJuIHJ1bkJhcmVDeXByZXNzKHBhcmFtcyk7XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZWRQYXJhbXMgPSBhd2FpdCB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpO1xuICBzZXRBUElCYXNlVXJsKHZhbGlkYXRlZFBhcmFtcy5jbG91ZFNlcnZpY2VVcmwpO1xuXG4gIGlmICghaXNDdXJyZW50cygpKSB7XG4gICAgY29uc29sZS5sb2coZ2V0TGVnYWxOb3RpY2UoKSk7XG4gIH1cblxuICBjb25zdCB7XG4gICAgcmVjb3JkS2V5LFxuICAgIHByb2plY3RJZCxcbiAgICBncm91cCxcbiAgICBwYXJhbGxlbCxcbiAgICBjaUJ1aWxkSWQsXG4gICAgdGFnLFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIGJhdGNoU2l6ZSxcbiAgICBhdXRvQ2FuY2VsQWZ0ZXJGYWlsdXJlcyxcbiAgICBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZyxcbiAgfSA9IHZhbGlkYXRlZFBhcmFtcztcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCBnZXRNZXJnZWRDb25maWcodmFsaWRhdGVkUGFyYW1zKTtcbiAgY29uZmlnU3RhdGUuc2V0Q29uZmlnKGNvbmZpZz8ucmVzb2x2ZWQpO1xuXG4gIGNvbnN0IHsgc3BlY3MsIHNwZWNQYXR0ZXJuIH0gPSBhd2FpdCBnZXRTcGVjRmlsZXMoe1xuICAgIGNvbmZpZyxcbiAgICBwYXJhbXM6IHZhbGlkYXRlZFBhcmFtcyxcbiAgfSk7XG5cbiAgaWYgKHNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZ2V0UGxhdGZvcm0oe1xuICAgIGNvbmZpZyxcbiAgICBicm93c2VyOiB2YWxpZGF0ZWRQYXJhbXMuYnJvd3NlcixcbiAgfSk7XG5cbiAgaW5mbyhcIkRpc2NvdmVyZWQgJWQgc3BlYyBmaWxlc1wiLCBzcGVjcy5sZW5ndGgpO1xuICBpbmZvKFxuICAgIGBUYWdzOiAke3RhZy5sZW5ndGggPiAwID8gdGFnLmpvaW4oXCIsXCIpIDogZmFsc2V9OyBHcm91cDogJHtcbiAgICAgIGdyb3VwID8/IGZhbHNlXG4gICAgfTsgUGFyYWxsZWw6ICR7cGFyYWxsZWwgPz8gZmFsc2V9OyBCYXRjaCBTaXplOiAke2JhdGNoU2l6ZX1gXG4gICk7XG4gIGluZm8oXCJDb25uZWN0aW5nIHRvIGNsb3VkIG9yY2hlc3RyYXRpb24gc2VydmljZS4uLlwiKTtcblxuICBjb25zdCBydW4gPSBhd2FpdCBjcmVhdGVSdW4oe1xuICAgIGNpOiBnZXRDSShjaUJ1aWxkSWQpLFxuICAgIHNwZWNzOiBzcGVjcy5tYXAoKHNwZWMpID0+IHNwZWMucmVsYXRpdmUpLFxuICAgIGNvbW1pdDogYXdhaXQgZ2V0R2l0SW5mbyhjb25maWcucHJvamVjdFJvb3QpLFxuICAgIGdyb3VwLFxuICAgIHBsYXRmb3JtLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbCA/PyBmYWxzZSxcbiAgICBjaUJ1aWxkSWQsXG4gICAgcHJvamVjdElkLFxuICAgIHJlY29yZEtleSxcbiAgICBzcGVjUGF0dGVybjogW3NwZWNQYXR0ZXJuXS5mbGF0KDIpLFxuICAgIHRhZ3M6IHRhZyxcbiAgICB0ZXN0aW5nVHlwZSxcbiAgICBiYXRjaFNpemUsXG4gICAgYXV0b0NhbmNlbEFmdGVyRmFpbHVyZXMsXG4gICAgY292ZXJhZ2VFbmFibGVkOiBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZyxcbiAgICBwcmV2aW91c0NpQnVpbGRJZDogcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfUFJFVklPVVNfQ0lfQlVJTERfSUQsXG4gICAgcHJvdmlkZWRNYWNoaW5lSWQ6IHByb2Nlc3MuZW52LkNVUlJFTlRTX01BQ0hJTkVfSUQsXG4gIH0pO1xuXG4gIHNldFJ1bklkKHJ1bi5ydW5JZCk7XG4gIGluZm8oXCJcdUQ4M0NcdURGQTUgUnVuIFVSTDpcIiwgYm9sZChydW4ucnVuVXJsKSk7XG4gIHByb2Nlc3MuZW52LkNVUlJFTlRTX01BQ0hJTkVfSURcbiAgICA/IGluZm8oXCJcdUQ4M0VcdUREMTYgTWFjaGluZSBJRDpcIiwgYm9sZChydW4ubWFjaGluZUlkKSlcbiAgICA6IG51bGw7XG4gIGN1dEluaXRpYWxPdXRwdXQoKTtcblxuICBhd2FpdCBzdGFydFdTUygpO1xuICBsaXN0ZW5Ub1NwZWNFdmVudHMoXG4gICAgY29uZmlnU3RhdGUsXG4gICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgY29uZmlnLmV4cGVyaW1lbnRhbENvdmVyYWdlUmVjb3JkaW5nXG4gICk7XG5cbiAgYXdhaXQgcnVuVGlsbERvbmVPckNhbmNlbGxlZChcbiAgICBleGVjdXRpb25TdGF0ZSxcbiAgICBjb25maWdTdGF0ZSxcbiAgICB7XG4gICAgICBydW5JZDogcnVuLnJ1bklkLFxuICAgICAgZ3JvdXBJZDogcnVuLmdyb3VwSWQsXG4gICAgICBtYWNoaW5lSWQ6IHJ1bi5tYWNoaW5lSWQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNwZWNzLFxuICAgIH0sXG4gICAgdmFsaWRhdGVkUGFyYW1zXG4gICk7XG5cbiAgZGl2aWRlcigpO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChyZXBvcnRUYXNrcyk7XG4gIGNvbnN0IF9zdW1tYXJ5ID0gc3VtbWFyaXplVGVzdFJlc3VsdHMoXG4gICAgZXhlY3V0aW9uU3RhdGUuZ2V0UmVzdWx0cyhjb25maWdTdGF0ZSksXG4gICAgY29uZmlnXG4gICk7XG5cbiAgdGl0bGUoXCJ3aGl0ZVwiLCBcIkNsb3VkIFJ1biBGaW5pc2hlZFwiKTtcbiAgY29uc29sZS5sb2coc3VtbWFyeVRhYmxlKF9zdW1tYXJ5KSk7XG5cbiAgcHJpbnRXYXJuaW5ncyhleGVjdXRpb25TdGF0ZSk7XG5cbiAgaW5mbyhcIlxcblx1RDgzQ1x1REZDMSBSZWNvcmRlZCBSdW46XCIsIGJvbGQocnVuLnJ1blVybCkpO1xuXG4gIGF3YWl0IHNodXRkb3duKCk7XG5cbiAgc3BhY2VyKCk7XG4gIGlmIChfc3VtbWFyeS5zdGF0dXMgPT09IFwiZmluaXNoZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5fc3VtbWFyeSxcbiAgICAgIHJ1blVybDogcnVuLnJ1blVybCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9zdW1tYXJ5O1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5Ub1NwZWNFdmVudHMoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgZXhlY3V0aW9uU3RhdGU6IEV4ZWN1dGlvblN0YXRlLFxuICBleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZz86IGJvb2xlYW5cbikge1xuICBjb25zdCBjb25maWcgPSBjb25maWdTdGF0ZS5nZXRDb25maWcoKTtcbiAgcHVic3ViLm9uKFwiYmVmb3JlOnNwZWNcIiwgYXN5bmMgKHsgc3BlYyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYyB9KSA9PiB7XG4gICAgZGVidWcoXCJiZWZvcmU6c3BlYyAlb1wiLCBzcGVjKTtcbiAgICBleGVjdXRpb25TdGF0ZS5zZXRTcGVjQmVmb3JlKHNwZWMucmVsYXRpdmUpO1xuICB9KTtcblxuICBwdWJzdWIub24oXG4gICAgXCJhZnRlcjpzcGVjXCIsXG4gICAgYXN5bmMgKHsgc3BlYywgcmVzdWx0cyB9OiB7IHNwZWM6IEN5cHJlc3MuU3BlYzsgcmVzdWx0czogYW55IH0pID0+IHtcbiAgICAgIGRlYnVnKFwiYWZ0ZXI6c3BlYyAlbyAlb1wiLCBzcGVjLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNBZnRlcihzcGVjLnJlbGF0aXZlLCByZXN1bHRzKTtcbiAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNPdXRwdXQoc3BlYy5yZWxhdGl2ZSwgZ2V0Q2FwdHVyZWRPdXRwdXQoKSk7XG5cbiAgICAgIGlmIChleHBlcmltZW50YWxDb3ZlcmFnZVJlY29yZGluZykge1xuICAgICAgICBjb25zdCB7IHBhdGgsIGVycm9yIH0gPSBhd2FpdCBnZXRDb3ZlcmFnZUZpbGVQYXRoKFxuICAgICAgICAgIGNvbmZpZz8uZW52Py5jb3ZlcmFnZUZpbGVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIGV4ZWN1dGlvblN0YXRlLnNldFNwZWNDb3ZlcmFnZShzcGVjLnJlbGF0aXZlLCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgICAgYENvdWxkIG5vdCBwcm9jZXNzIGNvdmVyYWdlIGZpbGUgXCIke3BhdGh9XCJcXG4ke2RpbShlcnJvcil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNyZWF0ZVJlcG9ydFRhc2tTcGVjKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgc3BlYy5yZWxhdGl2ZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmdzKGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSkge1xuICBjb25zdCB3YXJuaW5ncyA9IEFycmF5LmZyb20oZXhlY3V0aW9uU3RhdGUuZ2V0V2FybmluZ3MoKSk7XG4gIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgd2FybihcbiAgICAgIGAke3dhcm5pbmdzLmxlbmd0aH0gJHtwbHVyKFxuICAgICAgICBcIldhcm5pbmdcIixcbiAgICAgICAgd2FybmluZ3MubGVuZ3RoXG4gICAgICApfSBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbjpcXG4ke3dhcm5pbmdzXG4gICAgICAgIC5tYXAoKHcsIGkpID0+IGBcXG4ke3llbGxvdyhgWyR7aSArIDF9LyR7d2FybmluZ3MubGVuZ3RofV1gKX0gJHt3fWApXG4gICAgICAgIC5qb2luKFwiXFxuXCIpfWBcbiAgICApO1xuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldExlZ2FsTm90aWNlKCkge1xuICByZXR1cm4gYFxuQ29weXJpZ2h0IChDKSAke25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0gQ3VycmVudHMgU29mdHdhcmUgSW5jIGh0dHBzOi8vY3VycmVudHMuZGV2XG5UaGlzIGlzIGZyZWUgc29mdHdhcmUsIGFuZCB5b3UgYXJlIHdlbGNvbWUgdG8gcmVkaXN0cmlidXRlIGl0IHVuZGVyIGNlcnRhaW5cbmNvbmRpdGlvbnMuIFRoaXMgcHJvZ3JhbSBjb21lcyB3aXRoIG5vIHdhcnJhbnR5LiBQYXJ0cyBvZiB0aGlzIHByb2dyYW0gYXJlIE1JVFxubGljZW5zZWQuIFJlZmVyIHRvIHRoZSBsaWNlbnNlIGZvciBkZXRhaWxzXG5odHRwczovL2dpdGh1Yi5jb20vY3VycmVudHMtZGV2L2N5cHJlc3MtY2xvdWQvYmxvYi9tYWluL0xJQ0VOU0UubWRcbmA7XG59XG4iLCAiaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgbWFnZW50YSB9IGZyb20gXCIuLi9sb2dcIjtcblxuaW1wb3J0IHsgaW5mbywgc3BhY2VyLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgQ2xvdWRXYXJuaW5nIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50V2FybmluZ3Mod2FybmluZ3M6IENsb3VkV2FybmluZ1tdKSB7XG4gIHdhcm4oXCJOb3RpY2UgZnJvbSBjbG91ZCBzZXJ2aWNlOlwiKTtcbiAgd2FybmluZ3MubWFwKCh3KSA9PiB7XG4gICAgc3BhY2VyKDEpO1xuICAgIGluZm8obWFnZW50YS5ib2xkKHcubWVzc2FnZSkpO1xuICAgIE9iamVjdC5lbnRyaWVzKF8ub21pdCh3LCBcIm1lc3NhZ2VcIikpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpbmZvKFwiLSAlczogJXNcIiwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgc3BhY2VyKDEpO1xuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBtYWtlUmVxdWVzdCB9IGZyb20gXCIuLi9odHRwQ2xpZW50XCI7XG5pbXBvcnQge1xuICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZCxcbiAgQ3JlYXRlSW5zdGFuY2VQYXlsb2FkLFxuICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgQ3JlYXRlUnVuUGF5bG9hZCxcbiAgQ3JlYXRlUnVuUmVzcG9uc2UsXG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkLFxuICBVcGRhdGVJbnN0YW5jZVJlc3VsdHNSZXNwb25zZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IHByaW50V2FybmluZ3MgfSBmcm9tIFwiLi93YXJuaW5nc1wiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUnVuID0gYXN5bmMgKHBheWxvYWQ6IENyZWF0ZVJ1blBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxDcmVhdGVSdW5SZXNwb25zZSwgQ3JlYXRlUnVuUGF5bG9hZD4oe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ydW5zXCIsXG4gICAgZGF0YTogcGF5bG9hZCxcbiAgfSk7XG5cbiAgaWYgKChyZXNwb25zZS5kYXRhLndhcm5pbmdzPy5sZW5ndGggPz8gMCkgPiAwKSB7XG4gICAgcHJpbnRXYXJuaW5ncyhyZXNwb25zZS5kYXRhLndhcm5pbmdzKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluc3RhbmNlID0gYXN5bmMgKHtcbiAgcnVuSWQsXG4gIGdyb3VwSWQsXG4gIG1hY2hpbmVJZCxcbiAgcGxhdGZvcm0sXG59OiBDcmVhdGVJbnN0YW5jZVBheWxvYWQpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZVJlc3BvbnNlLFxuICAgIENyZWF0ZUluc3RhbmNlUGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtydW5JZH0vaW5zdGFuY2VzYCxcbiAgICBkYXRhOiB7XG4gICAgICBydW5JZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBtYWNoaW5lSWQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVCYXRjaGVkSW5zdGFuY2VzID0gYXN5bmMgKGRhdGE6IENyZWF0ZUluc3RhbmNlQ3lQYXlsb2FkKSA9PiB7XG4gIGNvbnN0IHJlc3BvbmUgPSBhd2FpdCBtYWtlUmVxdWVzdDxcbiAgICBDcmVhdGVJbnN0YW5jZXNSZXNwb25zZSxcbiAgICBDcmVhdGVJbnN0YW5jZUN5UGF5bG9hZFxuICA+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYHJ1bnMvJHtkYXRhLnJ1bklkfS9jeS9pbnN0YW5jZXNgLFxuICAgIGRhdGEsXG4gIH0pO1xuXG4gIHJldHVybiByZXNwb25lLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW5zdGFuY2VUZXN0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZFxuKSA9PlxuICBtYWtlUmVxdWVzdDx7fSwgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQ+KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3Rlc3RzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlUmVzdWx0cyA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLCBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHJlcG9ydEluc3RhbmNlUmVzdWx0c01lcmdlZCA9IChcbiAgaW5zdGFuY2VJZDogc3RyaW5nLFxuICBwYXlsb2FkOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNNZXJnZWRQYXlsb2FkXG4pID0+XG4gIG1ha2VSZXF1ZXN0PFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1Jlc3BvbnNlLFxuICAgIFVwZGF0ZUluc3RhbmNlUmVzdWx0c01lcmdlZFBheWxvYWRcbiAgPih7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IGBpbnN0YW5jZXMvJHtpbnN0YW5jZUlkfS9jeS9yZXN1bHRzYCxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICB9KS50aGVuKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhKTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUluc3RhbmNlU3Rkb3V0ID0gKGluc3RhbmNlSWQ6IHN0cmluZywgc3Rkb3V0OiBzdHJpbmcpID0+XG4gIG1ha2VSZXF1ZXN0PGFueSwgeyBzdGRvdXQ6IHN0cmluZyB9Pih7XG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIHVybDogYGluc3RhbmNlcy8ke2luc3RhbmNlSWR9L3N0ZG91dGAsXG4gICAgZGF0YToge1xuICAgICAgc3Rkb3V0LFxuICAgIH0sXG4gIH0pO1xuIiwgIi8qISBAcHJlc2VydmVcblxuIyMjIE1JVFxuXG5QYXJ0cyBvZiB0aGlzIGNvZGUgd2FzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MgYW5kIGlzIHN1YmplY3QgdG8gTUlUIGxpY2Vuc2UuXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAyMiBDeXByZXNzLmlvXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmltcG9ydCBkZWJ1Z0ZuIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBHaGFFdmVudERhdGEgfSBmcm9tIFwiLi4vZ2l0XCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5jb25zdCBqb2luID0gKGNoYXI6IHN0cmluZywgLi4ucGllY2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdKSA9PiB7XG4gIHJldHVybiBfLmNoYWluKHBpZWNlcykuY29tcGFjdCgpLmpvaW4oY2hhcikudmFsdWUoKTtcbn07XG5cbmNvbnN0IHRvQ2FtZWxPYmplY3QgPSAob2JqOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBfLnNldChvYmosIF8uY2FtZWxDYXNlKGtleSksIHByb2Nlc3MuZW52W2tleV0pO1xufTtcblxuY29uc3QgZXh0cmFjdCA9IChlbnZLZXlzOiBzdHJpbmdbXSkgPT4ge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZW52S2V5cywgdG9DYW1lbE9iamVjdCwge30pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBUZWFtRm91bmRhdGlvbiBzZXJ2ZXIuXG4gKiBAc2VlIGh0dHBzOi8vdGVjaG5ldC5taWNyb3NvZnQuY29tL2VuLXVzL2hoODUwNDQ4KHY9dnMuOTIpXG4gKi9cbmNvbnN0IGlzVGVhbUZvdW5kYXRpb24gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5URl9CVUlMRCAmJiBwcm9jZXNzLmVudi5URl9CVUlMRF9CVUlMRE5VTUJFUjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gQXp1cmUgQ0kgcGlwZWxpbmUuXG4gKiBTZWUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIHRoZSBpc3N1ZSAjMzY1N1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2lzc3Vlcy8zNjU3XG4gKi9cbmNvbnN0IGlzQXp1cmVDaSA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LlRGX0JVSUxEICYmIHByb2Nlc3MuZW52LkFaVVJFX0hUVFBfVVNFUl9BR0VOVDtcbn07XG5cbmNvbnN0IGlzQVdTQ29kZUJ1aWxkID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT0RFQlVJTERfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNCYW1ib28gPSAoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5iYW1ib29fYnVpbGROdW1iZXI7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwQmFzaWMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuQ0lfTkFNRSAmJlxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgPT09IFwiY29kZXNoaXBcIiAmJlxuICAgIHByb2Nlc3MuZW52LkNPREVTSElQXG4gICk7XG59O1xuXG5jb25zdCBpc0NvZGVzaGlwUHJvID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkNJX05BTUUgJiZcbiAgICBwcm9jZXNzLmVudi5DSV9OQU1FID09PSBcImNvZGVzaGlwXCIgJiZcbiAgICAhcHJvY2Vzcy5lbnYuQ09ERVNISVBcbiAgKTtcbn07XG5cbmNvbnN0IGlzQ29uY291cnNlID0gKCkgPT4ge1xuICByZXR1cm4gXy5zb21lKHByb2Nlc3MuZW52LCAodmFsLCBrZXkpID0+IHtcbiAgICByZXR1cm4gL15DT05DT1VSU0VfLy50ZXN0KGtleSk7XG4gIH0pO1xufTtcblxuY29uc3QgaXNHaXRsYWIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0lUTEFCX0NJIHx8XG4gICAgKHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FICYmIC9eR2l0TGFiLy50ZXN0KHByb2Nlc3MuZW52LkNJX1NFUlZFUl9OQU1FKSlcbiAgKTtcbn07XG5cbmNvbnN0IGlzR29vZ2xlQ2xvdWQgPSAoKSA9PiB7XG4gIC8vIHNldCBhdXRvbWF0aWNhbGx5IGZvciB0aGUgTm9kZS5qcyA2LCBOb2RlLmpzIDggcnVudGltZXMgKG5vdCBpbiBOb2RlIDEwKVxuICAvLyBUT0RPOiBtYXkgYWxzbyBwb3RlbnRpYWxseSBoYXZlIFhfR09PR0xFXyogZW52IHZhciBzZXRcbiAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIjZW52aXJvbm1lbnRfdmFyaWFibGVzX3NldF9hdXRvbWF0aWNhbGx5XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuR0NQX1BST0pFQ1QgfHxcbiAgICBwcm9jZXNzLmVudi5HQ0xPVURfUFJPSkVDVCB8fFxuICAgIHByb2Nlc3MuZW52LkdPT0dMRV9DTE9VRF9QUk9KRUNUXG4gICk7XG59O1xuXG5jb25zdCBpc0plbmtpbnMgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcHJvY2Vzcy5lbnYuSkVOS0lOU19VUkwgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX0hPTUUgfHxcbiAgICBwcm9jZXNzLmVudi5KRU5LSU5TX1ZFUlNJT04gfHxcbiAgICBwcm9jZXNzLmVudi5IVURTT05fVVJMIHx8XG4gICAgcHJvY2Vzcy5lbnYuSFVEU09OX0hPTUVcbiAgKTtcbn07XG5cbmNvbnN0IGlzV2VyY2tlciA9ICgpID0+IHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LldFUkNLRVIgfHwgcHJvY2Vzcy5lbnYuV0VSQ0tFUl9NQUlOX1BJUEVMSU5FX1NUQVJURUQ7XG59O1xuXG4vKipcbiAqIFdlIGRldGVjdCBDSSBwcm92aWRlcnMgYnkgZGV0ZWN0aW5nIGFuIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiB1bmlxdWUgdG8gdGhlIHByb3ZpZGVyLCBvciBieSBjYWxsaW5nIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWVcbiAqIGZvciB0aGF0IHByb3ZpZGVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBBcHBWZXlvciBDSSBoYXMgZW52aXJvbm1lbnQgdGhlXG4gKiB2YXJpYWJsZSBcIkFQUFZFWU9SXCIgc2V0IGR1cmluZyBydW5cbiAqL1xuY29uc3QgQ0lfUFJPVklERVJTID0ge1xuICBhcHB2ZXlvcjogXCJBUFBWRVlPUlwiLFxuICBhenVyZTogaXNBenVyZUNpLFxuICBhd3NDb2RlQnVpbGQ6IGlzQVdTQ29kZUJ1aWxkLFxuICBiYW1ib286IGlzQmFtYm9vLFxuICBiaXRidWNrZXQ6IFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICBidWlsZGtpdGU6IFwiQlVJTERLSVRFXCIsXG4gIGNpcmNsZTogXCJDSVJDTEVDSVwiLFxuICBjb2Rlc2hpcEJhc2ljOiBpc0NvZGVzaGlwQmFzaWMsXG4gIGNvZGVzaGlwUHJvOiBpc0NvZGVzaGlwUHJvLFxuICBjb25jb3Vyc2U6IGlzQ29uY291cnNlLFxuICBjb2RlRnJlc2g6IFwiQ0ZfQlVJTERfSURcIixcbiAgZHJvbmU6IFwiRFJPTkVcIixcbiAgZ2l0aHViQWN0aW9uczogXCJHSVRIVUJfQUNUSU9OU1wiLFxuICBnaXRsYWI6IGlzR2l0bGFiLFxuICBnb0NEOiBcIkdPX0pPQl9OQU1FXCIsXG4gIGdvb2dsZUNsb3VkOiBpc0dvb2dsZUNsb3VkLFxuICBqZW5raW5zOiBpc0plbmtpbnMsXG4gIHNlbWFwaG9yZTogXCJTRU1BUEhPUkVcIixcbiAgc2hpcHBhYmxlOiBcIlNISVBQQUJMRVwiLFxuICB0ZWFtY2l0eTogXCJURUFNQ0lUWV9WRVJTSU9OXCIsXG4gIHRlYW1mb3VuZGF0aW9uOiBpc1RlYW1Gb3VuZGF0aW9uLFxuICB0cmF2aXM6IFwiVFJBVklTXCIsXG4gIHdlcmNrZXI6IGlzV2VyY2tlcixcbiAgbmV0bGlmeTogXCJORVRMSUZZXCIsXG4gIGxheWVyY2k6IFwiTEFZRVJDSVwiLFxufTtcblxuZnVuY3Rpb24gX2RldGVjdFByb3ZpZGVyTmFtZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IGVudiB9ID0gcHJvY2VzcztcbiAgLy8gcmV0dXJuIHRoZSBrZXkgb2YgdGhlIGZpcnN0IHByb3ZpZGVyXG4gIC8vIHdoaWNoIGlzIHRydXRoeVxuXG4gIHJldHVybiBfLmZpbmRLZXkoQ0lfUFJPVklERVJTLCAodmFsdWUpID0+IHtcbiAgICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBlbnZbdmFsdWVdO1xuICAgIH1cblxuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBkb24ndCBmb3IgYWJvdXQgYnVpbGROdW1iZXIhXG4vLyBsb29rIGF0IHRoZSBvbGQgY29tbWl0IHRoYXQgd2FzIHJlbW92ZWQgdG8gc2VlIGhvdyB3ZSBkaWQgaXRcbmNvbnN0IF9wcm92aWRlckNpUGFyYW1zID0gKCk6IFByb3ZpZGVyQ2lQYXJhbXNSZXMgPT4ge1xuICByZXR1cm4ge1xuICAgIGFwcHZleW9yOiBleHRyYWN0KFtcbiAgICAgIFwiQVBQVkVZT1JfSk9CX0lEXCIsXG4gICAgICBcIkFQUFZFWU9SX0FDQ09VTlRfTkFNRVwiLFxuICAgICAgXCJBUFBWRVlPUl9QUk9KRUNUX1NMVUdcIixcbiAgICAgIFwiQVBQVkVZT1JfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkFQUFZFWU9SX0JVSUxEX1ZFUlNJT05cIixcbiAgICAgIFwiQVBQVkVZT1JfUFVMTF9SRVFVRVNUX05VTUJFUlwiLFxuICAgICAgXCJBUFBWRVlPUl9QVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSFwiLFxuICAgIF0pLFxuICAgIGF6dXJlOiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfQlVJTERJRFwiLFxuICAgICAgXCJCVUlMRF9CVUlMRE5VTUJFUlwiLFxuICAgICAgXCJCVUlMRF9DT05UQUlORVJJRFwiLFxuICAgICAgXCJCVUlMRF9SRVBPU0lUT1JZX1VSSVwiLFxuICAgIF0pLFxuICAgIGF3c0NvZGVCdWlsZDogZXh0cmFjdChbXG4gICAgICBcIkNPREVCVUlMRF9CVUlMRF9JRFwiLFxuICAgICAgXCJDT0RFQlVJTERfQlVJTERfTlVNQkVSXCIsXG4gICAgICBcIkNPREVCVUlMRF9SRVNPTFZFRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgXCJDT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMXCIsXG4gICAgICBcIkNPREVCVUlMRF9TT1VSQ0VfVkVSU0lPTlwiLFxuICAgIF0pLFxuICAgIGJhbWJvbzogZXh0cmFjdChbXG4gICAgICBcImJhbWJvb19idWlsZE51bWJlclwiLFxuICAgICAgXCJiYW1ib29fYnVpbGRSZXN1bHRzVXJsXCIsXG4gICAgICBcImJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXBvc2l0b3J5VXJsXCIsXG4gICAgICBcImJhbWJvb19idWlsZEtleVwiLFxuICAgIF0pLFxuICAgIGJpdGJ1Y2tldDogZXh0cmFjdChbXG4gICAgICBcIkJJVEJVQ0tFVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiQklUQlVDS0VUX1JFUE9fT1dORVJcIixcbiAgICAgIFwiQklUQlVDS0VUX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCSVRCVUNLRVRfUEFSQUxMRUxfU1RFUFwiLFxuICAgICAgXCJCSVRCVUNLRVRfU1RFUF9SVU5fTlVNQkVSXCIsXG4gICAgICAvLyB0aGUgUFIgdmFyaWFibGVzIGFyZSBvbmx5IHNldCBvbiBwdWxsIHJlcXVlc3QgYnVpbGRzXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9JRFwiLFxuICAgICAgXCJCSVRCVUNLRVRfUFJfREVTVElOQVRJT05fQlJBTkNIXCIsXG4gICAgICBcIkJJVEJVQ0tFVF9QUl9ERVNUSU5BVElPTl9DT01NSVRcIixcbiAgICBdKSxcbiAgICBidWlsZGtpdGU6IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMREtJVEVfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfU09VUkNFXCIsXG4gICAgICBcIkJVSUxES0lURV9KT0JfSURcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxES0lURV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQlVJTERLSVRFX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUXCIsXG4gICAgICBcIkJVSUxES0lURV9QVUxMX1JFUVVFU1RfUkVQT1wiLFxuICAgICAgXCJCVUlMREtJVEVfUFVMTF9SRVFVRVNUX0JBU0VfQlJBTkNIXCIsXG4gICAgXSksXG4gICAgY2lyY2xlOiBleHRyYWN0KFtcbiAgICAgIFwiQ0lSQ0xFX0pPQlwiLFxuICAgICAgXCJDSVJDTEVfQlVJTERfTlVNXCIsXG4gICAgICBcIkNJUkNMRV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX05VTUJFUlwiLFxuICAgICAgXCJDSVJDTEVfUFJfUkVQT05BTUVcIixcbiAgICAgIFwiQ0lSQ0xFX1BSX1VTRVJOQU1FXCIsXG4gICAgICBcIkNJUkNMRV9DT01QQVJFX1VSTFwiLFxuICAgICAgXCJDSVJDTEVfV09SS0ZMT1dfSURcIixcbiAgICAgIFwiQ0lSQ0xFX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJDSVJDTEVfUkVQT1NJVE9SWV9VUkxcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgY29kZXNoaXBCYXNpYzogZXh0cmFjdChbXG4gICAgICBcIkNJX0JVSUxEX0lEXCIsXG4gICAgICBcIkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJDSV9CVUlMRF9VUkxcIixcbiAgICAgIFwiQ0lfUFJPSkVDVF9JRFwiLFxuICAgICAgXCJDSV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiQ0lfUFVMTF9SRVFVRVNUXCIsXG4gICAgXSksXG4gICAgLy8gQ29kZXNoaXBQcm8gcHJvdmlkZXMgdmVyeSBmZXcgQ0kgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9kb2N1bWVudGF0aW9uLmNvZGVzaGlwLmNvbS9wcm8vYnVpbGRzLWFuZC1jb25maWd1cmF0aW9uL2Vudmlyb25tZW50LXZhcmlhYmxlcy9cbiAgICBjb2Rlc2hpcFBybzogZXh0cmFjdChbXCJDSV9CVUlMRF9JRFwiLCBcIkNJX1JFUE9fTkFNRVwiLCBcIkNJX1BST0pFQ1RfSURcIl0pLFxuICAgIC8vIGh0dHBzOi8vY29uY291cnNlLWNpLm9yZy9pbXBsZW1lbnRpbmctcmVzb3VyY2UtdHlwZXMuaHRtbCNyZXNvdXJjZS1tZXRhZGF0YVxuICAgIGNvbmNvdXJzZTogZXh0cmFjdChbXG4gICAgICBcIkJVSUxEX0lEXCIsXG4gICAgICBcIkJVSUxEX05BTUVcIixcbiAgICAgIFwiQlVJTERfSk9CX05BTUVcIixcbiAgICAgIFwiQlVJTERfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJCVUlMRF9URUFNX05BTUVcIixcbiAgICAgIFwiQVRDX0VYVEVSTkFMX1VSTFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vY29kZWZyZXNoLmlvL2RvY3MvZG9jcy9jb2RlZnJlc2gteWFtbC92YXJpYWJsZXMvXG4gICAgY29kZUZyZXNoOiBleHRyYWN0KFtcbiAgICAgIFwiQ0ZfQlVJTERfSURcIixcbiAgICAgIFwiQ0ZfQlVJTERfVVJMXCIsXG4gICAgICBcIkNGX0NVUlJFTlRfQVRURU1QVFwiLFxuICAgICAgXCJDRl9TVEVQX05BTUVcIixcbiAgICAgIFwiQ0ZfUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJDRl9QSVBFTElORV9UUklHR0VSX0lEXCIsXG4gICAgICAvLyB2YXJpYWJsZXMgYWRkZWQgZm9yIHB1bGwgcmVxdWVzdHNcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX0lEXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9JU19GT1JLXCIsXG4gICAgICBcIkNGX1BVTExfUkVRVUVTVF9OVU1CRVJcIixcbiAgICAgIFwiQ0ZfUFVMTF9SRVFVRVNUX1RBUkdFVFwiLFxuICAgIF0pLFxuICAgIGRyb25lOiBleHRyYWN0KFtcbiAgICAgIFwiRFJPTkVfSk9CX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9CVUlMRF9MSU5LXCIsXG4gICAgICBcIkRST05FX0JVSUxEX05VTUJFUlwiLFxuICAgICAgXCJEUk9ORV9QVUxMX1JFUVVFU1RcIixcbiAgICBdKSxcbiAgICAvLyBodHRwczovL2hlbHAuZ2l0aHViLmNvbS9lbi9hY3Rpb25zL2F1dG9tYXRpbmcteW91ci13b3JrZmxvdy13aXRoLWdpdGh1Yi1hY3Rpb25zL3VzaW5nLWVudmlyb25tZW50LXZhcmlhYmxlcyNkZWZhdWx0LWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdpdGh1YkFjdGlvbnM6IGV4dHJhY3QoW1xuICAgICAgXCJHSVRIVUJfV09SS0ZMT1dcIixcbiAgICAgIFwiR0lUSFVCX0FDVElPTlwiLFxuICAgICAgXCJHSVRIVUJfRVZFTlRfTkFNRVwiLFxuICAgICAgXCJHSVRIVUJfUlVOX0lEXCIsXG4gICAgICBcIkdJVEhVQl9SVU5fQVRURU1QVFwiLFxuICAgICAgXCJHSVRIVUJfUkVQT1NJVE9SWVwiLFxuICAgIF0pLFxuICAgIC8vIHNlZSBodHRwczovL2RvY3MuZ2l0bGFiLmNvbS9lZS9jaS92YXJpYWJsZXMvXG4gICAgZ2l0bGFiOiBleHRyYWN0KFtcbiAgICAgIC8vIHBpcGVsaW5lIGlzIGNvbW1vbiBhbW9uZyBhbGwgam9ic1xuICAgICAgXCJDSV9QSVBFTElORV9JRFwiLFxuICAgICAgXCJDSV9QSVBFTElORV9VUkxcIixcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJDSV9CVUlMRF9JRFwiLCAvLyBidWlsZCBpZCBhbmQgam9iIGlkIGFyZSBhbGlhc2VzXG4gICAgICBcIkNJX0pPQl9JRFwiLFxuICAgICAgXCJDSV9KT0JfVVJMXCIsXG4gICAgICBcIkNJX0pPQl9OQU1FXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJHSVRMQUJfSE9TVFwiLFxuICAgICAgXCJDSV9QUk9KRUNUX0lEXCIsXG4gICAgICBcIkNJX1BST0pFQ1RfVVJMXCIsXG4gICAgICBcIkNJX1JFUE9TSVRPUllfVVJMXCIsXG4gICAgICBcIkNJX0VOVklST05NRU5UX1VSTFwiLFxuICAgICAgXCJDSV9ERUZBVUxUX0JSQU5DSFwiLFxuICAgICAgLy8gZm9yIFBSczogaHR0cHM6Ly9naXRsYWIuY29tL2dpdGxhYi1vcmcvZ2l0bGFiLWNlL2lzc3Vlcy8yMzkwMlxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5nb2NkLm9yZy9jdXJyZW50L2ZhcS9kZXZfdXNlX2N1cnJlbnRfcmV2aXNpb25faW5fYnVpbGQuaHRtbCNzdGFuZGFyZC1nb2NkLWVudmlyb25tZW50LXZhcmlhYmxlc1xuICAgIGdvQ0Q6IGV4dHJhY3QoW1xuICAgICAgXCJHT19TRVJWRVJfVVJMXCIsXG4gICAgICBcIkdPX0VOVklST05NRU5UX05BTUVcIixcbiAgICAgIFwiR09fUElQRUxJTkVfTkFNRVwiLFxuICAgICAgXCJHT19QSVBFTElORV9DT1VOVEVSXCIsXG4gICAgICBcIkdPX1BJUEVMSU5FX0xBQkVMXCIsXG4gICAgICBcIkdPX1NUQUdFX05BTUVcIixcbiAgICAgIFwiR09fU1RBR0VfQ09VTlRFUlwiLFxuICAgICAgXCJHT19KT0JfTkFNRVwiLFxuICAgICAgXCJHT19UUklHR0VSX1VTRVJcIixcbiAgICAgIFwiR09fUkVWSVNJT05cIixcbiAgICAgIFwiR09fVE9fUkVWSVNJT05cIixcbiAgICAgIFwiR09fRlJPTV9SRVZJU0lPTlwiLFxuICAgICAgXCJHT19NQVRFUklBTF9IQVNfQ0hBTkdFRFwiLFxuICAgIF0pLFxuICAgIGdvb2dsZUNsb3VkOiBleHRyYWN0KFtcbiAgICAgIC8vIGluZGl2aWR1YWwgam9ic1xuICAgICAgXCJCVUlMRF9JRFwiLFxuICAgICAgXCJQUk9KRUNUX0lEXCIsXG4gICAgICAvLyBvdGhlciBpbmZvcm1hdGlvblxuICAgICAgXCJSRVBPX05BTUVcIixcbiAgICAgIFwiQlJBTkNIX05BTUVcIixcbiAgICAgIFwiVEFHX05BTUVcIixcbiAgICAgIFwiQ09NTUlUX1NIQVwiLFxuICAgICAgXCJTSE9SVF9TSEFcIixcbiAgICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jbG91ZC1idWlsZC9kb2NzL2FwaS9yZWZlcmVuY2UvcmVzdC9TaGFyZWQuVHlwZXMvQnVpbGRcbiAgICBdKSxcbiAgICBqZW5raW5zOiBleHRyYWN0KFtcIkJVSUxEX0lEXCIsIFwiQlVJTERfVVJMXCIsIFwiQlVJTERfTlVNQkVSXCIsIFwiZ2hwcmJQdWxsSWRcIl0pLFxuICAgIC8vIGh0dHBzOi8vc2VtYXBob3JlY2kuY29tL2RvY3MvYXZhaWxhYmxlLWVudmlyb25tZW50LXZhcmlhYmxlcy5odG1sXG4gICAgLy8gc29tZSBjb21lIGZyb20gdjEsIHNvbWUgZnJvbSB2MiBvZiBzZW1hcGhvcmVcbiAgICBzZW1hcGhvcmU6IGV4dHJhY3QoW1xuICAgICAgXCJTRU1BUEhPUkVfQlJBTkNIX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX0NVUlJFTlRfSk9CXCIsXG4gICAgICBcIlNFTUFQSE9SRV9DVVJSRU5UX1RIUkVBRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfRVhFQ1VUQUJMRV9VVUlEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfQlJBTkNIXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfRElSXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGXCIsXG4gICAgICBcIlNFTUFQSE9SRV9HSVRfUkVGX1RZUEVcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9SRVBPX1NMVUdcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgIFwiU0VNQVBIT1JFX0dJVF9VUkxcIixcbiAgICAgIFwiU0VNQVBIT1JFX0pPQl9DT1VOVFwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX0lEXCIsIC8vIHYyXG4gICAgICBcIlNFTUFQSE9SRV9KT0JfTkFNRVwiLFxuICAgICAgXCJTRU1BUEhPUkVfSk9CX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1BJUEVMSU5FX0lEXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QTEFURk9STVwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9ESVJcIixcbiAgICAgIFwiU0VNQVBIT1JFX1BST0pFQ1RfSEFTSF9JRFwiLFxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9JRFwiLCAvLyB2MlxuICAgICAgXCJTRU1BUEhPUkVfUFJPSkVDVF9OQU1FXCIsXG4gICAgICBcIlNFTUFQSE9SRV9QUk9KRUNUX1VVSURcIiwgLy8gdjFcbiAgICAgIFwiU0VNQVBIT1JFX1JFUE9fU0xVR1wiLFxuICAgICAgXCJTRU1BUEhPUkVfVFJJR0dFUl9TT1VSQ0VcIixcbiAgICAgIFwiU0VNQVBIT1JFX1dPUktGTE9XX0lEXCIsXG4gICAgICBcIlBVTExfUkVRVUVTVF9OVU1CRVJcIiwgLy8gcHVsbCByZXF1ZXN0cyBmcm9tIGZvcmtzIE9OTFlcbiAgICBdKSxcbiAgICAvLyBzZWUgaHR0cDovL2RvY3Muc2hpcHBhYmxlLmNvbS9jaS9lbnYtdmFycy9cbiAgICBzaGlwcGFibGU6IGV4dHJhY3QoW1xuICAgICAgLy8gYnVpbGQgdmFyaWFibGVzXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9JRFwiLCAvLyBcIjViOTMzNTRjYWJmYWJiMDcwMDdmMDFmZFwiXG4gICAgICBcIlNISVBQQUJMRV9CVUlMRF9OVU1CRVJcIiwgLy8gXCI0XCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTU1JVF9SQU5HRVwiLCAvLyBcInNoYTEuLi5zaGEyXCJcbiAgICAgIFwiU0hJUFBBQkxFX0NPTlRBSU5FUl9OQU1FXCIsIC8vIFwiYy5leGVjLmN5cHJlc3MtZXhhbXBsZS1raXRjaGVuc2luay40LjFcIlxuICAgICAgXCJTSElQUEFCTEVfSk9CX0lEXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9KT0JfTlVNQkVSXCIsIC8vIFwiMVwiXG4gICAgICBcIlNISVBQQUJMRV9SRVBPX1NMVUdcIiwgLy8gXCI8dXNlcm5hbWU+LzxyZXBvPlwiXG4gICAgICAvLyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgU2hpcHBhYmxlIHByb3ZpZGVzXG4gICAgICBcIklTX0ZPUktcIiwgLy8gXCJ0cnVlXCJcbiAgICAgIFwiSVNfR0lUX1RBR1wiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUFJFUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiSVNfUkVMRUFTRVwiLCAvLyBcImZhbHNlXCJcbiAgICAgIFwiUkVQT1NJVE9SWV9VUkxcIiwgLy8gXCJodHRwczovL2dpdGh1Yi5jb20vLi4uLmdpdFwiXG4gICAgICBcIlJFUE9fRlVMTF9OQU1FXCIsIC8vIFwiPHVzZXJuYW1lPi88cmVwbz5cIlxuICAgICAgXCJSRVBPX05BTUVcIiwgLy8gXCJjeXByZXNzLWV4YW1wbGUta2l0Y2hlbnNpbmtcIlxuICAgICAgXCJCVUlMRF9VUkxcIiwgLy8gXCJodHRwczovL2FwcC5zaGlwcGFibGUuY29tL2dpdGh1Yi88dXNlcm5hbWU+LzxyZXBvPi9ydW5zLzFcIlxuICAgICAgLy8gUHVsbCByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICBcIkJBU0VfQlJBTkNIXCIsIC8vIE5hbWUgb2YgdGhlIHRhcmdldCBicmFuY2ggaW50byB3aGljaCB0aGUgcHVsbCByZXF1ZXN0IGNoYW5nZXMgd2lsbCBiZSBtZXJnZWQuXG4gICAgICBcIkhFQURfQlJBTkNIXCIsIC8vIFRoaXMgaXMgb25seSBzZXQgZm9yIHB1bGwgcmVxdWVzdHMgYW5kIGlzIHRoZSBuYW1lIG9mIHRoZSBicmFuY2ggdGhlIHB1bGwgcmVxdWVzdCB3YXMgb3BlbmVkIGZyb20uXG4gICAgICBcIklTX1BVTExfUkVRVUVTVFwiLCAvLyBcImZhbHNlXCIgb3IgXCJ0cnVlXCJcbiAgICAgIFwiUFVMTF9SRVFVRVNUXCIsIC8vIFB1bGwgcmVxdWVzdCBudW1iZXIgaWYgdGhlIGpvYiBpcyBhIHB1bGwgcmVxdWVzdC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgICAgXCJQVUxMX1JFUVVFU1RfQkFTRV9CUkFOQ0hcIiwgLy8gTmFtZSBvZiB0aGUgYnJhbmNoIHRoYXQgdGhlIHB1bGwgcmVxdWVzdCB3aWxsIGJlIG1lcmdlZCBpbnRvLiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgQkFTRV9CUkFOQ0guXG4gICAgICBcIlBVTExfUkVRVUVTVF9SRVBPX0ZVTExfTkFNRVwiLCAvLyBGdWxsIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgZnJvbSB3aGVyZSB0aGUgcHVsbCByZXF1ZXN0IG9yaWdpbmF0ZWQuXG4gICAgXSksXG4gICAgdGVhbWNpdHk6IG51bGwsXG4gICAgdGVhbWZvdW5kYXRpb246IGV4dHJhY3QoW1xuICAgICAgXCJCVUlMRF9CVUlMRElEXCIsXG4gICAgICBcIkJVSUxEX0JVSUxETlVNQkVSXCIsXG4gICAgICBcIkJVSUxEX0NPTlRBSU5FUklEXCIsXG4gICAgXSksXG4gICAgdHJhdmlzOiBleHRyYWN0KFtcbiAgICAgIFwiVFJBVklTX0pPQl9JRFwiLFxuICAgICAgXCJUUkFWSVNfQlVJTERfSURcIixcbiAgICAgIFwiVFJBVklTX0JVSUxEX1dFQl9VUkxcIixcbiAgICAgIFwiVFJBVklTX1JFUE9fU0xVR1wiLFxuICAgICAgXCJUUkFWSVNfSk9CX05VTUJFUlwiLFxuICAgICAgXCJUUkFWSVNfRVZFTlRfVFlQRVwiLFxuICAgICAgXCJUUkFWSVNfQ09NTUlUX1JBTkdFXCIsXG4gICAgICBcIlRSQVZJU19CVUlMRF9OVU1CRVJcIixcbiAgICAgIFwiVFJBVklTX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX0JSQU5DSFwiLFxuICAgICAgXCJUUkFWSVNfUFVMTF9SRVFVRVNUX1NIQVwiLFxuICAgIF0pLFxuICAgIHdlcmNrZXI6IG51bGwsXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm5ldGxpZnkuY29tL2NvbmZpZ3VyZS1idWlsZHMvZW52aXJvbm1lbnQtdmFyaWFibGVzLyNkZXBsb3ktdXJscy1hbmQtbWV0YWRhdGFcbiAgICBuZXRsaWZ5OiBleHRyYWN0KFtcbiAgICAgIFwiQlVJTERfSURcIixcbiAgICAgIFwiQ09OVEVYVFwiLFxuICAgICAgXCJVUkxcIixcbiAgICAgIFwiREVQTE9ZX1VSTFwiLFxuICAgICAgXCJERVBMT1lfUFJJTUVfVVJMXCIsXG4gICAgICBcIkRFUExPWV9JRFwiLFxuICAgIF0pLFxuICAgIC8vIGh0dHBzOi8vbGF5ZXJjaS5jb20vZG9jcy9sYXllcmZpbGUtcmVmZXJlbmNlL2J1aWxkLWVudlxuICAgIGxheWVyY2k6IGV4dHJhY3QoW1xuICAgICAgXCJMQVlFUkNJX0pPQl9JRFwiLFxuICAgICAgXCJMQVlFUkNJX1JVTk5FUl9JRFwiLFxuICAgICAgXCJSRVRSWV9JTkRFWFwiLFxuICAgICAgXCJMQVlFUkNJX1BVTExfUkVRVUVTVFwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fTkFNRVwiLFxuICAgICAgXCJMQVlFUkNJX1JFUE9fT1dORVJcIixcbiAgICAgIFwiTEFZRVJDSV9CUkFOQ0hcIixcbiAgICAgIFwiR0lUX1RBR1wiLCAvLyBzaG9ydCBoZXggZm9yIGNvbW1pdHNcbiAgICBdKSxcbiAgfTtcbn07XG5cbi8vIHRyaWVzIHRvIGdyYWIgY29tbWl0IGluZm9ybWF0aW9uIGZyb20gQ0kgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyB2ZXJ5IHVzZWZ1bCB0byBmaWxsIG1pc3NpbmcgaW5mb3JtYXRpb24gd2hlbiBHaXQgY2Fubm90IGdyYWIgY29ycmVjdCB2YWx1ZXNcbmNvbnN0IF9wcm92aWRlckNvbW1pdFBhcmFtcyA9ICgpOiBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyA9PiB7XG4gIGNvbnN0IHsgZW52IH0gPSBwcm9jZXNzO1xuXG4gIHJldHVybiB7XG4gICAgYXBwdmV5b3I6IHtcbiAgICAgIHNoYTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlULFxuICAgICAgLy8gc2luY2UgQVBQVkVZT1JfUkVQT19CUkFOQ0ggd2lsbCBiZSB0aGUgdGFyZ2V0IGJyYW5jaCBvbiBhIFBSXG4gICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBQVUxMX1JFUVVFU1RfSEVBRF9SRVBPX0JSQU5DSCBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBlLmcuIGlmIHlvdSBoYXZlIGEgUFI6IGRldmVsb3AgPC0gbXktZmVhdHVyZS1icmFuY2hcbiAgICAgIC8vIG15LWZlYXR1cmUtYnJhbmNoIGlzIEFQUFZFWU9SX1BVTExfUkVRVUVTVF9IRUFEX1JFUE9fQlJBTkNIXG4gICAgICAvLyBkZXZlbG9wICAgICAgICAgICBpcyBBUFBWRVlPUl9SRVBPX0JSQU5DSFxuICAgICAgYnJhbmNoOlxuICAgICAgICBlbnYuQVBQVkVZT1JfUFVMTF9SRVFVRVNUX0hFQURfUkVQT19CUkFOQ0ggfHwgZW52LkFQUFZFWU9SX1JFUE9fQlJBTkNILFxuICAgICAgbWVzc2FnZTogam9pbihcbiAgICAgICAgXCJcXG5cIixcbiAgICAgICAgZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX01FU1NBR0UsXG4gICAgICAgIGVudi5BUFBWRVlPUl9SRVBPX0NPTU1JVF9NRVNTQUdFX0VYVEVOREVEXG4gICAgICApLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkFQUFZFWU9SX1JFUE9fQ09NTUlUX0FVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQVBQVkVZT1JfUkVQT19DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYXdzQ29kZUJ1aWxkOiB7XG4gICAgICBzaGE6IGVudi5DT0RFQlVJTERfUkVTT0xWRURfU09VUkNFX1ZFUlNJT04sXG4gICAgICAvLyBicmFuY2g6ID8/PyxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5DT0RFQlVJTERfU09VUkNFX1JFUE9fVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBhenVyZToge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICAgIGF1dGhvckVtYWlsOiBlbnYuQlVJTERfUkVRVUVTVEVERk9SRU1BSUwsXG4gICAgfSxcbiAgICBiYW1ib286IHtcbiAgICAgIHNoYTogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXZpc2lvbixcbiAgICAgIGJyYW5jaDogZW52LmJhbWJvb19wbGFuUmVwb3NpdG9yeV9icmFuY2gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIGF1dGhvck5hbWU6IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfdXNlcm5hbWUsXG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5iYW1ib29fcGxhblJlcG9zaXRvcnlfcmVwb3NpdG9yeVVSTCxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgYml0YnVja2V0OiB7XG4gICAgICBzaGE6IGVudi5CSVRCVUNLRVRfQ09NTUlULFxuICAgICAgYnJhbmNoOiBlbnYuQklUQlVDS0VUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBidWlsZGtpdGU6IHtcbiAgICAgIHNoYTogZW52LkJVSUxES0lURV9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CVUlMREtJVEVfQlJBTkNILFxuICAgICAgbWVzc2FnZTogZW52LkJVSUxES0lURV9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkJVSUxES0lURV9CVUlMRF9DUkVBVE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5CVUlMREtJVEVfQlVJTERfQ1JFQVRPUl9FTUFJTCxcbiAgICAgIHJlbW90ZU9yaWdpbjogZW52LkJVSUxES0lURV9SRVBPLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkJVSUxES0lURV9QSVBFTElORV9ERUZBVUxUX0JSQU5DSCxcbiAgICB9LFxuICAgIGNpcmNsZToge1xuICAgICAgc2hhOiBlbnYuQ0lSQ0xFX1NIQTEsXG4gICAgICBicmFuY2g6IGVudi5DSVJDTEVfQlJBTkNILFxuICAgICAgLy8gbWVzc2FnZTogPz8/XG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lSQ0xFX1VTRVJOQU1FLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lSQ0xFX1JFUE9TSVRPUllfVVJMLFxuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICBjb2Rlc2hpcEJhc2ljOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVzaGlwUHJvOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfSUQsXG4gICAgICBicmFuY2g6IGVudi5DSV9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0lfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0lfQ09NTUlUVEVSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkNJX0NPTU1JVFRFUl9FTUFJTCxcbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/Pz9cbiAgICB9LFxuICAgIGNvZGVGcmVzaDoge1xuICAgICAgc2hhOiBlbnYuQ0ZfUkVWSVNJT04sXG4gICAgICBicmFuY2g6IGVudi5DRl9CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ0ZfQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ0ZfQ09NTUlUX0FVVEhPUixcbiAgICB9LFxuICAgIGRyb25lOiB7XG4gICAgICBzaGE6IGVudi5EUk9ORV9DT01NSVRfU0hBLFxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmRyb25lLmlvL3BpcGVsaW5lL2Vudmlyb25tZW50L3JlZmVyZW5jZS9kcm9uZS1zb3VyY2UtYnJhbmNoL1xuICAgICAgYnJhbmNoOiBlbnYuRFJPTkVfU09VUkNFX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5EUk9ORV9DT01NSVRfTUVTU0FHRSxcbiAgICAgIGF1dGhvck5hbWU6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SLFxuICAgICAgYXV0aG9yRW1haWw6IGVudi5EUk9ORV9DT01NSVRfQVVUSE9SX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuRFJPTkVfR0lUX0hUVFBfVVJMLFxuICAgICAgZGVmYXVsdEJyYW5jaDogZW52LkRST05FX1JFUE9fQlJBTkNILFxuICAgIH0sXG4gICAgZ2l0aHViQWN0aW9uczoge1xuICAgICAgc2hhOiBlbnYuR0lUSFVCX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkdIX0JSQU5DSCB8fCBlbnYuR0lUSFVCX1JFRixcbiAgICAgIGRlZmF1bHRCcmFuY2g6IGVudi5HSVRIVUJfQkFTRV9SRUYsXG4gICAgICByZW1vdGVCcmFuY2g6IGVudi5HSVRIVUJfSEVBRF9SRUYsXG4gICAgICBydW5BdHRlbXB0OiBlbnYuR0lUSFVCX1JVTl9BVFRFTVBULFxuICAgIH0sXG4gICAgZ2l0bGFiOiB7XG4gICAgICBzaGE6IGVudi5DSV9DT01NSVRfU0hBLFxuICAgICAgYnJhbmNoOiBlbnYuQ0lfQ09NTUlUX1JFRl9OQU1FLFxuICAgICAgbWVzc2FnZTogZW52LkNJX0NPTU1JVF9NRVNTQUdFLFxuICAgICAgYXV0aG9yTmFtZTogZW52LkdJVExBQl9VU0VSX05BTUUsXG4gICAgICBhdXRob3JFbWFpbDogZW52LkdJVExBQl9VU0VSX0VNQUlMLFxuICAgICAgcmVtb3RlT3JpZ2luOiBlbnYuQ0lfUkVQT1NJVE9SWV9VUkwsXG4gICAgICBkZWZhdWx0QnJhbmNoOiBlbnYuQ0lfREVGQVVMVF9CUkFOQ0gsXG4gICAgfSxcbiAgICBnb29nbGVDbG91ZDoge1xuICAgICAgc2hhOiBlbnYuQ09NTUlUX1NIQSxcbiAgICAgIGJyYW5jaDogZW52LkJSQU5DSF9OQU1FLFxuICAgICAgLy8gbWVzc2FnZTogPz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz9cbiAgICAgIC8vIHJlbW90ZU9yaWdpbjogPz8/XG4gICAgICAvLyBkZWZhdWx0QnJhbmNoOiA/P1xuICAgIH0sXG4gICAgamVua2luczoge1xuICAgICAgc2hhOiBlbnYuR0lUX0NPTU1JVCxcbiAgICAgIGJyYW5jaDogZW52LkdJVF9CUkFOQ0gsXG4gICAgICAvLyBtZXNzYWdlOiA/Pz9cbiAgICAgIC8vIGF1dGhvck5hbWU6ID8/P1xuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgLy8gT25seSBmcm9tIGZvcmtzPyBodHRwczovL3NlbWFwaG9yZWNpLmNvbS9kb2NzL2F2YWlsYWJsZS1lbnZpcm9ubWVudC12YXJpYWJsZXMuaHRtbFxuICAgIHNlbWFwaG9yZToge1xuICAgICAgc2hhOiBlbnYuU0VNQVBIT1JFX0dJVF9TSEEsXG4gICAgICBicmFuY2g6IGVudi5TRU1BUEhPUkVfR0lUX0JSQU5DSCxcbiAgICAgIC8vIG1lc3NhZ2U6ID8/P1xuICAgICAgLy8gYXV0aG9yTmFtZTogPz8/XG4gICAgICAvLyBhdXRob3JFbWFpbDogPz8/XG4gICAgICByZW1vdGVPcmlnaW46IGVudi5TRU1BUEhPUkVfR0lUX1JFUE9fU0xVRyxcbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc2hpcHBhYmxlOiB7XG4gICAgICBzaGE6IGVudi5DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICBtZXNzYWdlOiBlbnYuQ09NTUlUX01FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQ09NTUlUVEVSLFxuICAgICAgLy8gYXV0aG9yRW1haWw6ID8/P1xuICAgICAgLy8gcmVtb3RlT3JpZ2luOiA/Pz9cbiAgICAgIC8vIGRlZmF1bHRCcmFuY2g6ID8/P1xuICAgIH0sXG4gICAgc25hcDogbnVsbCxcbiAgICB0ZWFtY2l0eTogbnVsbCxcbiAgICB0ZWFtZm91bmRhdGlvbjoge1xuICAgICAgc2hhOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTixcbiAgICAgIGJyYW5jaDogZW52LkJVSUxEX1NPVVJDRUJSQU5DSE5BTUUsXG4gICAgICBtZXNzYWdlOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTk1FU1NBR0UsXG4gICAgICBhdXRob3JOYW1lOiBlbnYuQlVJTERfU09VUkNFVkVSU0lPTkFVVEhPUixcbiAgICB9LFxuICAgIHRyYXZpczoge1xuICAgICAgc2hhOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9TSEEgfHwgZW52LlRSQVZJU19DT01NSVQsXG4gICAgICAvLyBmb3IgUFJzLCBUUkFWSVNfQlJBTkNIIGlzIHRoZSBiYXNlIGJyYW5jaCBiZWluZyBtZXJnZWQgaW50b1xuICAgICAgYnJhbmNoOiBlbnYuVFJBVklTX1BVTExfUkVRVUVTVF9CUkFOQ0ggfHwgZW52LlRSQVZJU19CUkFOQ0gsXG4gICAgICAvLyBhdXRob3JOYW1lOiA/Pz9cbiAgICAgIC8vIGF1dGhvckVtYWlsOiA/Pz9cbiAgICAgIG1lc3NhZ2U6IGVudi5UUkFWSVNfQ09NTUlUX01FU1NBR0UsXG4gICAgICAvLyByZW1vdGVPcmlnaW46ID8/P1xuICAgICAgLy8gZGVmYXVsdEJyYW5jaDogPz8/XG4gICAgfSxcbiAgICB3ZXJja2VyOiBudWxsLFxuICAgIG5ldGxpZnk6IHtcbiAgICAgIHNoYTogZW52LkNPTU1JVF9SRUYsXG4gICAgICBicmFuY2g6IGVudi5CUkFOQ0gsXG4gICAgICByZW1vdGVPcmlnaW46IGVudi5SRVBPU0lUT1JZX1VSTCxcbiAgICB9LFxuICAgIGxheWVyY2k6IHtcbiAgICAgIHNoYTogZW52LkdJVF9DT01NSVQsXG4gICAgICBicmFuY2g6IGVudi5MQVlFUkNJX0JSQU5DSCxcbiAgICAgIG1lc3NhZ2U6IGVudi5HSVRfQ09NTUlUX1RJVExFLFxuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBDaVByb3ZpZGVyRGF0YSA9IHtcbiAgc2hhPzogc3RyaW5nO1xuICBicmFuY2g/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGF1dGhvck5hbWU/OiBzdHJpbmc7XG4gIGF1dGhvckVtYWlsPzogc3RyaW5nO1xuICByZW1vdGVPcmlnaW4/OiBzdHJpbmc7XG4gIGRlZmF1bHRCcmFuY2g/OiBzdHJpbmc7XG4gIHJlbW90ZUJyYW5jaD86IHN0cmluZztcbiAgcnVuQXR0ZW1wdD86IHN0cmluZztcbiAgZ2hhRXZlbnREYXRhPzogR2hhRXZlbnREYXRhIHwgbnVsbDtcbn07XG5cbmludGVyZmFjZSBQcm92aWRlckNvbW1pdFBhcmFtc1JlcyB7XG4gIFtrZXk6IHN0cmluZ106IENpUHJvdmlkZXJEYXRhIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFByb3ZpZGVyQ2lQYXJhbXNSZXMge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgX2dldCA9IChmbjogKCkgPT4gUHJvdmlkZXJDb21taXRQYXJhbXNSZXMgfCBQcm92aWRlckNpUGFyYW1zUmVzKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlck5hbWUpIHJldHVybiB7fTtcblxuICByZXR1cm4gXy5jaGFpbihmbigpKS5nZXQocHJvdmlkZXJOYW1lKS52YWx1ZSgpO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBpcyBubyBidWlsZCBJRCBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYnkgdXNlclxuICogQ2hlY2sgaWYgd2UgY2FuIGZldGNoIGl0IGF1dG9tYXRpY2FsbHkgZnJvbSBDSSB2YXJpYWJsZXMuXG4gKiBUaGUgcHJvY2VzcyB3aWxsIHN0b3AgaWYgd2UgY2Fubm90IGRvIGl0XG4gKiBodHRwczovL2RvY3MuY3lwcmVzcy5pby9ndWlkZXMvcmVmZXJlbmNlcy9lcnJvci1tZXNzYWdlcyNXZS1jb3VsZC1ub3QtZGV0ZXJtaW5lLWEtdW5pcXVlLUNJLWJ1aWxkLUlEXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShjaVByb3ZpZGVyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChjaVByb3ZpZGVyICYmIGRldGVjdGFibGVDaUJ1aWxkSWRQcm92aWRlcnMoKS5pbmNsdWRlcyhjaVByb3ZpZGVyKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIENJIGJ1aWxkIElEIGZyb20gdGhlIGVudmlyb25tZW50LiBQbGVhc2UgcHJvdmlkZSBhIHVuaXF1ZSBDSSBidWlsZCBJRCB1c2luZyB0aGUgLS1jaS1idWlsZC1pZCBDTEkgZmxhZyBvciAnY2lCdWlsZElkJyBwYXJhbWV0ZXIgZm9yICdydW4nIG1ldGhvZC5gXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0KCkge1xuICByZXR1cm4gXy5rZXlzKENJX1BST1ZJREVSUyk7XG59XG5cbi8vIGdyYWIgYWxsIGRldGVjdGFibGUgcHJvdmlkZXJzXG4vLyB0aGF0IHdlIGNhbiBleHRyYWN0IGNpQnVpbGRJZCBmcm9tXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0YWJsZUNpQnVpbGRJZFByb3ZpZGVycygpIHtcbiAgcmV0dXJuIF8uY2hhaW4oX3Byb3ZpZGVyQ2lQYXJhbXMoKSkub21pdEJ5KF8uaXNOdWxsKS5rZXlzKCkudmFsdWUoKTtcbn1cblxuZXhwb3J0IHR5cGUgQ2lQcm92aWRlciA9IHN0cmluZyB8IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaVByb3ZpZGVyKCk6IENpUHJvdmlkZXIge1xuICByZXR1cm4gX2RldGVjdFByb3ZpZGVyTmFtZSgpIHx8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIENpUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lQYXJhbXMoKSB7XG4gIHJldHVybiBfZ2V0KF9wcm92aWRlckNpUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFBhcmFtcygpIHtcbiAgcmV0dXJuIF9nZXQoX3Byb3ZpZGVyQ29tbWl0UGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENJKGNpQnVpbGRJZD86IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSBnZXRDaVBhcmFtcygpIGFzIENpUGFyYW1zO1xuICBjb25zdCBwcm92aWRlciA9IGdldENpUHJvdmlkZXIoKTtcbiAgaWYgKCFjaUJ1aWxkSWQpIGNoZWNrRm9yQ2lCdWlsZEZyb21DaShwcm92aWRlcik7XG5cbiAgZGVidWcoXCJkZXRlY3RlZCBDSSBwcm92aWRlcjogJXNcIiwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcImRldGVjdGVkIENJIHBhcmFtczogJU9cIiwgcGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcHJvdmlkZXIsXG4gIH07XG59XG4iLCAiaW1wb3J0IGRlYnVnRm4gZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbmltcG9ydCB7IEdoYUV2ZW50RGF0YSB9IGZyb20gXCIuLi9naXRcIjtcbmltcG9ydCB7IENpUHJvdmlkZXIsIENpUHJvdmlkZXJEYXRhLCBnZXRDb21taXRQYXJhbXMgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGbihcImN1cnJlbnRzOmNpXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWl0RGVmYXVsdHMoZXhpc3RpbmdJbmZvOiBDaVByb3ZpZGVyRGF0YSkge1xuICBkZWJ1ZyhcImdpdCBjb21taXQgZXhpc3RpbmcgaW5mb1wiKTtcbiAgZGVidWcoZXhpc3RpbmdJbmZvKTtcblxuICBjb25zdCBjb21taXRQYXJhbXNPYmogPSBnZXRDb21taXRQYXJhbXMoKTtcblxuICBkZWJ1ZyhcImNvbW1pdCBpbmZvIGZyb20gcHJvdmlkZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzOiAlT1wiLCBjb21taXRQYXJhbXNPYmopO1xuXG4gIC8vIGJhc2VkIG9uIHRoZSBleGlzdGluZ0luZm8gcHJvcGVydGllc1xuICAvLyBtZXJnZSBpbiB0aGUgY29tbWl0UGFyYW1zIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gIC8vIGRlZmF1bHRpbmcgYmFjayB0byBudWxsIGlmIGFsbCBmYWlsc1xuICAvLyBOT1RFOiBvbmx5IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBcImV4aXN0aW5nSW5mb1wiIHdpbGwgYmUgcmV0dXJuZWRcbiAgY29uc3QgY29tYmluZWQgPSBfLnRyYW5zZm9ybShcbiAgICBleGlzdGluZ0luZm8sXG4gICAgKFxuICAgICAgbWVtbzogeyBbbWVtb0tleTogc3RyaW5nXTogc3RyaW5nIHwgR2hhRXZlbnREYXRhIHwgbnVsbCB9LFxuICAgICAgdmFsdWU6IHN0cmluZyB8IEdoYUV2ZW50RGF0YSB8IG51bGwsXG4gICAgICBrZXk6IHN0cmluZ1xuICAgICkgPT4ge1xuICAgICAgcmV0dXJuIChtZW1vW2tleV0gPSBfLmRlZmF1bHRUbyhcbiAgICAgICAgdmFsdWUgfHxcbiAgICAgICAgICAoY29tbWl0UGFyYW1zT2JqID8gY29tbWl0UGFyYW1zT2JqW2tleSBhcyBrZXlvZiBDaVByb3ZpZGVyXSA6IG51bGwpLFxuICAgICAgICBudWxsXG4gICAgICApKTtcbiAgICB9XG4gICk7XG5cbiAgZGVidWcoXCJjb21iaW5lZCBnaXQgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHByb3ZpZGVyXCIpO1xuICBkZWJ1Zyhjb21iaW5lZCk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkO1xufVxuIiwgImltcG9ydCBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q292ZXJhZ2VGaWxlUGF0aCA9IGFzeW5jIChcbiAgY292ZXJhZ2VGaWxlID0gXCIuLy5ueWNfb3V0cHV0L291dC5qc29uXCJcbikgPT4ge1xuICBjb25zdCBwYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCBjb3ZlcmFnZUZpbGUpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMuYWNjZXNzKHBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGZhbHNlLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcixcbiAgICB9O1xuICB9XG59O1xuIiwgImltcG9ydCBjeXByZXNzIGZyb20gXCJjeXByZXNzXCI7XG5pbXBvcnQge1xuICBDdXJyZW50c1J1blBhcmFtZXRlcnMsXG4gIEN5cHJlc3NSZXN1bHQsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRzQ29uZmlnLCBnZXRDeXByZXNzUnVuQVBJUGFyYW1zIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgc2FmZSB9IGZyb20gXCIuLi9sYW5nXCI7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0V1NTUG9ydCB9IGZyb20gXCIuLi93c1wiO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwiY3VycmVudHM6Y3lwcmVzc1wiKTtcbmludGVyZmFjZSBSdW5DeXByZXNzU3BlY0ZpbGUge1xuICBzcGVjOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5CYXJlQ3lwcmVzcyhwYXJhbXM6IEN1cnJlbnRzUnVuUGFyYW1ldGVycyA9IHt9KSB7XG4gIC8vIHJldmVydCBjdXJyZW50cyBwYXJhbXMgdG8gY3lwcmVzcyBwYXJhbXNcbiAgLy8gZXhjbHVkZSByZWNvcmQgbW9kZSBwYXJhbXNcbiAgY29uc3QgcCA9IHtcbiAgICAuLi5wYXJhbXMsXG4gICAgY2lCdWlsZElkOiB1bmRlZmluZWQsXG4gICAgdGFnOiB1bmRlZmluZWQsXG4gICAgcGFyYWxsZWw6IHVuZGVmaW5lZCxcbiAgICByZWNvcmQ6IGZhbHNlLFxuICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgc3BlYzogXy5mbGF0dGVuKHBhcmFtcy5zcGVjKS5qb2luKFwiLFwiKSxcbiAgfTtcbiAgZGVidWcoXCJSdW5uaW5nIGJhcmUgQ3lwcmVzcyB3aXRoIHBhcmFtcyAlb1wiLCBwKTtcbiAgcmV0dXJuIGN5cHJlc3MucnVuKHApO1xufVxuXG4vKipcbiAqIFJ1biBDeXByZXNzIHRlc3RzLCB3ZSBuZWVkIHRvIHBhc3MgZG93biB0aGUgc3RyaXBwZWQgb3B0aW9ucyBhcyBpZiB3ZSd2ZSByZWNlaXZlZCB0aGVtIGZyb20gdGhlIENMSVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuU3BlY0ZpbGUoXG4gIHsgc3BlYyB9OiBSdW5DeXByZXNzU3BlY0ZpbGUsXG4gIGN5cHJlc3NSdW5PcHRpb25zOiBWYWxpZGF0ZWRDdXJyZW50c1BhcmFtZXRlcnNcbikge1xuICBjb25zdCBydW5BUElPcHRpb25zID0gZ2V0Q3lwcmVzc1J1bkFQSVBhcmFtcyhjeXByZXNzUnVuT3B0aW9ucyk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5ydW5BUElPcHRpb25zLFxuICAgIGNvbmZpZzoge1xuICAgICAgLi4ucnVuQVBJT3B0aW9ucy5jb25maWcsXG4gICAgICB0cmFzaEFzc2V0c0JlZm9yZVJ1bnM6IGZhbHNlLFxuICAgIH0sXG4gICAgZW52OiB7XG4gICAgICAuLi5ydW5BUElPcHRpb25zLmVudixcbiAgICAgIGN1cnJlbnRzX3dzOiBnZXRXU1NQb3J0KCksXG4gICAgfSxcbiAgICBzcGVjLFxuICB9O1xuXG4gIGRlYnVnKFwicnVubmluZyBjeXByZXNzIHdpdGggb3B0aW9ucyAlb1wiLCBvcHRpb25zKTtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGN5cHJlc3MucnVuKG9wdGlvbnMpO1xuXG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgY3VycmVudHNDb25maWcgPSBhd2FpdCBnZXRDdXJyZW50c0NvbmZpZygpO1xuXG4gIHdoaWxlIChcbiAgICBjdXJyZW50c0NvbmZpZy5yZXRyeSAmJlxuICAgIHJldHJpZXMgPCAoY3VycmVudHNDb25maWcucmV0cnkuaGFyZEZhaWx1cmVNYXhSZXRyaWVzID8/IDApICYmXG4gICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJmYWlsZWRcIlxuICApIHtcbiAgICB3YXJuKFwiQ3lwcmVzcyBydW5uZXIgZmFpbGVkIHdpdGggbWVzc2FnZTogJXNcIiwgcmVzdWx0Lm1lc3NhZ2UpO1xuICAgIHdhcm4oXG4gICAgICBcIltyZXRyeSAlZC8lZF0gUmV0cnlpbmcgdGhlIGZvbGxvd2luZyBzcGVjIGZpbGVzIGJlY2F1c2Ugb2YgcmV0cnkgY29uZmlnOiAlc1wiLFxuICAgICAgcmV0cmllcyArIDEsXG4gICAgICBjdXJyZW50c0NvbmZpZy5yZXRyeS5oYXJkRmFpbHVyZU1heFJldHJpZXMsXG4gICAgICBzcGVjXG4gICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgLm1hcCgoaSkgPT4gYFxcbiAtICR7aX1gKVxuICAgICAgICAuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmVzdWx0ID0gYXdhaXQgY3lwcmVzcy5ydW4ob3B0aW9ucyk7XG4gICAgcmV0cmllcysrO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRzQ29uZmlnLnJldHJ5ICYmIHJldHJpZXMgPiAwKSB7XG4gICAgd2FybihcbiAgICAgIFwiRXhoYXVzdGVkIG1heCByZXRyaWVzOiAlZC8lZFwiLFxuICAgICAgcmV0cmllcyxcbiAgICAgIGN1cnJlbnRzQ29uZmlnLnJldHJ5LmhhcmRGYWlsdXJlTWF4UmV0cmllc1xuICAgICk7XG4gIH1cblxuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgIHdhcm4oJ0N5cHJlc3MgcnVubmVyIGZhaWxlZCB3aXRoIG1lc3NhZ2U6IFwiJXNcIicsIHJlc3VsdC5tZXNzYWdlKTtcbiAgICB3YXJuKFxuICAgICAgXCJUaGUgZm9sbG93aW5nIHNwZWMgZmlsZXMgd2lsbCBiZSBtYXJrZWQgYXMgZmFpbGVkOiAlc1wiLFxuICAgICAgc3BlY1xuICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgIC5tYXAoKGkpID0+IGBcXG4gLSAke2l9YClcbiAgICAgICAgLmpvaW4oXCJcIilcbiAgICApO1xuICB9XG5cbiAgZGVidWcoXCJjeXByZXNzIHJ1biByZXN1bHQgJW9cIiwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNvbnN0IHJ1blNwZWNGaWxlU2FmZSA9IChcbiAgc3BlYzogUnVuQ3lwcmVzc1NwZWNGaWxlLFxuICBjeXByZXNzUnVuT3B0aW9uczogVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPEN5cHJlc3NSZXN1bHQ+ID0+XG4gIHNhZmUoXG4gICAgcnVuU3BlY0ZpbGUsXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYEN5cHJlc3MgcnVubm5lciBjcmFzaGVkIHdpdGggYW4gZXJyb3I6XFxuJHtcbiAgICAgICAgKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlXG4gICAgICB9XFxuJHsoZXJyb3IgYXMgRXJyb3IpLnN0YWNrfX1gO1xuICAgICAgZGVidWcoXCJjeXByZXNzIHJ1biBleGNlcHRpb24gJW9cIiwgZXJyb3IpO1xuICAgICAgd2FybignQ3lwcmVzcyBydW5uZXIgY3Jhc2hlZDogXCIlc1wiJywgbWVzc2FnZSk7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlRoZSBmb2xsb3dpbmcgc3BlYyBmaWxlcyB3aWxsIGJlIG1hcmtlZCBhcyBmYWlsZWQ6ICVzXCIsXG4gICAgICAgIHNwZWMuc3BlY1xuICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAubWFwKChpKSA9PiBgXFxuIC0gJHtpfWApXG4gICAgICAgICAgLmpvaW4oXCJcIilcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFwiZmFpbGVkXCIgYXMgY29uc3QsXG4gICAgICAgIGZhaWx1cmVzOiAxLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgfTtcbiAgICB9LFxuICAgICgpID0+IHt9XG4gICkoc3BlYywgY3lwcmVzc1J1bk9wdGlvbnMpO1xuIiwgImltcG9ydCBibHVlYmlyZCBmcm9tIFwiYmx1ZWJpcmRcIjtcblxuYmx1ZWJpcmQuUHJvbWlzZS5jb25maWcoe1xuICBjYW5jZWxsYXRpb246IHRydWUsXG59KTtcbmV4cG9ydCBjb25zdCBCUHJvbWlzZSA9IGJsdWViaXJkLlByb21pc2U7XG5cbmV4cG9ydCBjb25zdCBzYWZlID1cbiAgPFQgZXh0ZW5kcyBhbnlbXSwgUiBleHRlbmRzIGFueSwgRiBleHRlbmRzIGFueT4oXG4gICAgZm46ICguLi5hcmdzOiBUKSA9PiBQcm9taXNlPFI+LFxuICAgIGlmRmFsZWQ6IChlOiB1bmtub3duKSA9PiBGLFxuICAgIGlmU3VjY2VlZDogKCkgPT4gYW55XG4gICkgPT5cbiAgYXN5bmMgKC4uLmFyZ3M6IFQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IGF3YWl0IGZuKC4uLmFyZ3MpO1xuICAgICAgaWZTdWNjZWVkKCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaWZGYWxlZChlKTtcbiAgICB9XG4gIH07XG4iLCAiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgbWF0Y2gsIFAgfSBmcm9tIFwidHMtcGF0dGVyblwiO1xuaW1wb3J0IHsgQ3VycmVudHNSdW5QYXJhbWV0ZXJzLCBEZWJ1Z01vZGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuZW51bSBEZWJ1Z1Rva2VucyB7XG4gIEN1cnJlbnRzID0gXCJjdXJyZW50czoqXCIsXG4gIEN5cHJlc3MgPSBcImN5cHJlc3M6KlwiLFxuICBDb21taXRJbmZvID0gXCJjb21taXQtaW5mb1wiLFxufVxuZXhwb3J0IGZ1bmN0aW9uIGFjdGl2YXRlRGVidWcobW9kZTogQ3VycmVudHNSdW5QYXJhbWV0ZXJzW1wiY2xvdWREZWJ1Z1wiXSkge1xuICBtYXRjaChtb2RlKVxuICAgIC53aXRoKFAuaW5zdGFuY2VPZihBcnJheSksIChpKSA9PiBpLmZvckVhY2goc2V0RGVidWdNb2RlKSlcbiAgICAud2l0aCh0cnVlLCAoKSA9PiBzZXREZWJ1Z01vZGUoRGVidWdNb2RlLkFsbCkpXG4gICAgLndpdGgoXG4gICAgICBQLnVuaW9uKFxuICAgICAgICBEZWJ1Z01vZGUuQWxsLFxuICAgICAgICBEZWJ1Z01vZGUuQ3VycmVudHMsXG4gICAgICAgIERlYnVnTW9kZS5DeXByZXNzLFxuICAgICAgICBEZWJ1Z01vZGUuQ29tbWl0SW5mb1xuICAgICAgKSxcbiAgICAgIChpKSA9PiBzZXREZWJ1Z01vZGUoaSlcbiAgICApXG4gICAgLm90aGVyd2lzZSgoKSA9PiBzZXREZWJ1Z01vZGUoRGVidWdNb2RlLk5vbmUpKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVidWdNb2RlKG1vZGU6IHN0cmluZykge1xuICBpZiAobW9kZSA9PT0gRGVidWdNb2RlLk5vbmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0b2tlbnMgPSBuZXcgU2V0KHByb2Nlc3MuZW52LkRFQlVHID8gcHJvY2Vzcy5lbnYuREVCVUcuc3BsaXQoXCIsXCIpIDogW10pO1xuICBtYXRjaChtb2RlKVxuICAgIC53aXRoKERlYnVnTW9kZS5BbGwsICgpID0+IHtcbiAgICAgIHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ29tbWl0SW5mbyk7XG4gICAgICB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN1cnJlbnRzKTtcbiAgICAgIHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3lwcmVzcyk7XG4gICAgfSlcbiAgICAud2l0aChEZWJ1Z01vZGUuQ3VycmVudHMsICgpID0+IHRva2Vucy5hZGQoRGVidWdUb2tlbnMuQ3VycmVudHMpKVxuICAgIC53aXRoKERlYnVnTW9kZS5DeXByZXNzLCAoKSA9PiB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkN5cHJlc3MpKVxuICAgIC53aXRoKERlYnVnTW9kZS5Db21taXRJbmZvLCAoKSA9PiB0b2tlbnMuYWRkKERlYnVnVG9rZW5zLkNvbW1pdEluZm8pKVxuICAgIC5vdGhlcndpc2UoKCkgPT4ge30pO1xuXG4gIGRlYnVnLmVuYWJsZShBcnJheS5mcm9tKHRva2Vucykuam9pbihcIixcIikpO1xufVxuIiwgImltcG9ydCB7IGdldEFQSUJhc2VVcmwgfSBmcm9tIFwiLi9odHRwQ2xpZW50L2NvbmZpZ1wiO1xuXG5leHBvcnQgY29uc3QgaXNDdXJyZW50cyA9ICgpID0+XG4gICEhcHJvY2Vzcy5lbnYuQ1VSUkVOVFNfRU5GT1JDRV9JU19DVVJSRU5UUyB8fFxuICBnZXRBUElCYXNlVXJsKCkgPT09IFwiaHR0cHM6Ly9jeS5jdXJyZW50cy5kZXZcIjtcbiIsICIvLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBjb21taXRJbmZvIH0gZnJvbSBcIkBjdXJyZW50cy9jb21taXQtaW5mb1wiO1xuaW1wb3J0IHsgZ2V0Q29tbWl0RGVmYXVsdHMgfSBmcm9tIFwiLi9jaVByb3ZpZGVyXCI7XG5cbmV4cG9ydCB0eXBlIEdoYUV2ZW50RGF0YSA9IHtcbiAgaGVhZFJlZjogc3RyaW5nO1xuICBoZWFkU2hhOiBzdHJpbmc7XG4gIGJhc2VSZWY6IHN0cmluZztcbiAgYmFzZVNoYTogc3RyaW5nO1xuICBpc3N1ZVVybDogc3RyaW5nO1xuICBodG1sVXJsOiBzdHJpbmc7XG4gIHByVGl0bGU6IHN0cmluZztcbiAgc2VuZGVyQXZhdGFyVXJsOiBzdHJpbmc7XG4gIHNlbmRlckh0bWxVcmw6IHN0cmluZztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRHaXRJbmZvID0gYXN5bmMgKHByb2plY3RSb290OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29tbWl0ID0gYXdhaXQgY29tbWl0SW5mbyhwcm9qZWN0Um9vdCk7XG4gIHJldHVybiBnZXRDb21taXREZWZhdWx0cyh7XG4gICAgYnJhbmNoOiBjb21taXQuYnJhbmNoLFxuICAgIHJlbW90ZU9yaWdpbjogY29tbWl0LnJlbW90ZSxcbiAgICBhdXRob3JFbWFpbDogY29tbWl0LmVtYWlsLFxuICAgIGF1dGhvck5hbWU6IGNvbW1pdC5hdXRob3IsXG4gICAgbWVzc2FnZTogY29tbWl0Lm1lc3NhZ2UsXG4gICAgc2hhOiBjb21taXQuc2hhLFxuICAgIGdoYUV2ZW50RGF0YTogY29tbWl0LmdoYUV2ZW50RGF0YSxcbiAgfSk7XG59O1xuIiwgImltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IERldGVjdGVkQnJvd3NlciwgUGxhdGZvcm0gfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpicm93c2VyXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3Vlc3NCcm93c2VyKFxuICBicm93c2VyOiBzdHJpbmcsXG4gIGF2YWlsYWJsZUJyb3dzZXJzOiBEZXRlY3RlZEJyb3dzZXJbXSA9IFtdXG4pOiBQaWNrPFBsYXRmb3JtLCBcImJyb3dzZXJOYW1lXCIgfCBcImJyb3dzZXJWZXJzaW9uXCI+IHtcbiAgZGVidWcoXG4gICAgXCJndWVzc2luZyBicm93c2VyIGZyb20gJyVzJywgYXZhaWxhYmxlIGJyb3dzZXJzOiAlb1wiLFxuICAgIGJyb3dzZXIsXG4gICAgYXZhaWxhYmxlQnJvd3NlcnNcbiAgKTtcbiAgLy8gdHJ5IGlkZW50aWZ5aW5nIHRoZSBicm93c2VyIGJ5IG5hbWUgZmlyc3RcbiAgbGV0IHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIubmFtZSA9PT0gYnJvd3Nlcik7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGRlYnVnKFwiaWRlbnRpZmllZCBicm93c2VyIGJ5IG5hbWU6ICVvXCIsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUsXG4gICAgICBicm93c2VyVmVyc2lvbjogcmVzdWx0LnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgdHJ5IGlkZW50aWZ5aW5nIGJ5IHRoZSBwYXRoXG4gIHJlc3VsdCA9IGF2YWlsYWJsZUJyb3dzZXJzLmZpbmQoKGIpID0+IGIucGF0aCA9PT0gYnJvd3Nlcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBkZWJ1ZyhcImlkZW50aWZpZWQgYnJvd3NlciBieSBwYXRoOiAlb1wiLCByZXN1bHQpO1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyTmFtZTogcmVzdWx0LmRpc3BsYXlOYW1lID8/IHJlc3VsdC5uYW1lLFxuICAgICAgYnJvd3NlclZlcnNpb246IHJlc3VsdC52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICB3YXJuKFwiVW5hYmxlIHRvIGlkZW50aWZ5IGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvblwiKTtcblxuICAvLyBvdGhlcndpc2UsIHJldHVybiBkdW1teSBicm93c2VyXG4gIHJldHVybiB7XG4gICAgYnJvd3Nlck5hbWU6IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJWZXJzaW9uOiBcInVua25vd25cIixcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgZ2V0b3MgZnJvbSBcImdldG9zXCI7XG5pbXBvcnQgeyBjcHVzLCBmcmVlbWVtLCBwbGF0Zm9ybSwgcmVsZWFzZSwgdG90YWxtZW0gfSBmcm9tIFwib3NcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpwbGF0Zm9ybVwiKTtcblxuY29uc3QgZ2V0T3NWZXJzaW9uID0gYXN5bmMgKCkgPT4ge1xuICBpZiAocGxhdGZvcm0oKSA9PT0gXCJsaW51eFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpbnV4T3MgPSBhd2FpdCBwcm9taXNpZnkoZ2V0b3MpKCk7XG4gICAgICBpZiAoXCJkaXN0XCIgaW4gbGludXhPcyAmJiBcInJlbGVhc2VcIiBpbiBsaW51eE9zKSB7XG4gICAgICAgIHJldHVybiBbbGludXhPcy5kaXN0LCBsaW51eE9zLnJlbGVhc2VdLmpvaW4oXCIgLSBcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbGVhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUluZm8gPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG9zVmVyc2lvbiA9IGF3YWl0IGdldE9zVmVyc2lvbigpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgb3NOYW1lOiBwbGF0Zm9ybSgpLFxuICAgIG9zVmVyc2lvbixcbiAgICBvc0NwdXM6IGNwdXMoKSxcbiAgICBvc01lbW9yeToge1xuICAgICAgZnJlZTogZnJlZW1lbSgpLFxuICAgICAgdG90YWw6IHRvdGFsbWVtKCksXG4gICAgfSxcbiAgfTtcbiAgZGVidWcoXCJwbGF0Zm9ybSBpbmZvOiAlb1wiLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5pbXBvcnQgeyBndWVzc0Jyb3dzZXIgfSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybUluZm8gfSBmcm9tIFwiLi9wbGF0Zm9ybVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGxhdGZvcm0oe1xuICBicm93c2VyLFxuICBjb25maWcsXG59OiB7XG4gIGJyb3dzZXI/OiBzdHJpbmc7XG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnO1xufSkge1xuICByZXR1cm4ge1xuICAgIC4uLihhd2FpdCBnZXRQbGF0Zm9ybUluZm8oKSksXG4gICAgLi4uZ3Vlc3NCcm93c2VyKGJyb3dzZXIgPz8gXCJlbGVjdHJvblwiLCBjb25maWcucmVzb2x2ZWQ/LmJyb3dzZXJzKSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBDeXByZXNzUmVzdWx0LCBTY3JlZW5zaG90QXJ0aWZhY3QgfSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHtcbiAgU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIFRlc3RTdGF0ZSxcbiAgVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZCxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJlc3VsdHNcIik7XG5cbmV4cG9ydCBjb25zdCBpc1N1Y2Nlc3NSZXN1bHQgPSAoXG4gIHJlc3VsdDogQ3lwcmVzc1Jlc3VsdFxuKTogcmVzdWx0IGlzIEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0ID0+IHtcbiAgcmV0dXJuIHJlc3VsdC5zdGF0dXMgPT09IFwiZmluaXNoZWRcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5zaG90c1N1bW1hcnkgPSAoXG4gIHRlc3RzOiBDeXByZXNzQ29tbWFuZExpbmUuVGVzdFJlc3VsdFtdID0gW11cbik6IFNjcmVlbnNob3RBcnRpZmFjdFtdID0+IHtcbiAgcmV0dXJuIHRlc3RzLmZsYXRNYXAoKHRlc3QsIGkpID0+XG4gICAgdGVzdC5hdHRlbXB0cy5mbGF0TWFwKChhLCBhaSkgPT5cbiAgICAgIGEuc2NyZWVuc2hvdHMuZmxhdE1hcCgocykgPT4gKHtcbiAgICAgICAgLi4ucyxcbiAgICAgICAgdGVzdElkOiBgciR7aX1gLFxuICAgICAgICB0ZXN0QXR0ZW1wdEluZGV4OiBhaSxcbiAgICAgICAgc2NyZWVuc2hvdElkOiBuYW5vaWQoKSxcbiAgICAgIH0pKVxuICAgIClcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdGF0cyA9IChzdGF0czogQ3lwcmVzc0NvbW1hbmRMaW5lLlJ1blJlc3VsdFtcInN0YXRzXCJdKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdHMsXG4gICAgd2FsbENsb2NrRHVyYXRpb246IHN0YXRzLmR1cmF0aW9uLFxuICAgIHdhbGxDbG9ja1N0YXJ0ZWRBdDogc3RhdHMuc3RhcnRlZEF0LFxuICAgIHdhbGxDbG9ja0VuZGVkQXQ6IHN0YXRzLmVuZGVkQXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VGVzdEF0dGVtcHQgPSAoYXR0ZW1wdDogQ3lwcmVzc0NvbW1hbmRMaW5lLkF0dGVtcHRSZXN1bHQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRlbXB0LFxuICAgIHN0YXRlOiBhdHRlbXB0LnN0YXRlIGFzIFRlc3RTdGF0ZSxcbiAgICB3YWxsQ2xvY2tEdXJhdGlvbjogYXR0ZW1wdC5kdXJhdGlvbixcbiAgICB3YWxsQ2xvY2tTdGFydGVkQXQ6IGF0dGVtcHQuc3RhcnRlZEF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZCA9IChcbiAgcnVuUmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0LFxuICBjb3ZlcmFnZUZpbGVQYXRoPzogc3RyaW5nXG4pOiBVcGRhdGVJbnN0YW5jZVJlc3VsdHNQYXlsb2FkID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0czogZ2V0U3RhdHMocnVuUmVzdWx0LnN0YXRzKSxcbiAgICByZXBvcnRlclN0YXRzOiBydW5SZXN1bHQucmVwb3J0ZXJTdGF0cyxcbiAgICBleGNlcHRpb246IHJ1blJlc3VsdC5lcnJvciA/PyBudWxsLFxuICAgIHZpZGVvOiAhIXJ1blJlc3VsdC52aWRlbywgLy8gRGlkIHRoZSBpbnN0YW5jZSBnZW5lcmF0ZSBhIHZpZGVvP1xuICAgIHNjcmVlbnNob3RzOiBnZXRTY3JlZW5zaG90c1N1bW1hcnkocnVuUmVzdWx0LnRlc3RzID8/IFtdKSxcbiAgICBoYXNDb3ZlcmFnZTogISFjb3ZlcmFnZUZpbGVQYXRoLFxuICAgIHRlc3RzOlxuICAgICAgcnVuUmVzdWx0LnRlc3RzPy5tYXAoKHRlc3QsIGkpID0+ICh7XG4gICAgICAgIGRpc3BsYXlFcnJvcjogdGVzdC5kaXNwbGF5RXJyb3IsXG4gICAgICAgIHN0YXRlOiB0ZXN0LnN0YXRlIGFzIFRlc3RTdGF0ZSxcbiAgICAgICAgaG9va3M6IHJ1blJlc3VsdC5ob29rcyxcbiAgICAgICAgYXR0ZW1wdHM6IHRlc3QuYXR0ZW1wdHM/Lm1hcChnZXRUZXN0QXR0ZW1wdCkgPz8gW10sXG4gICAgICAgIGNsaWVudElkOiBgciR7aX1gLFxuICAgICAgfSkpID8/IFtdLFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZha2VUZXN0RnJvbUV4Y2VwdGlvbihcbiAgZXJyb3I6IHN0cmluZyxcbiAgc3RhdHM6IEN5cHJlc3NDb21tYW5kTGluZS5SdW5SZXN1bHRbXCJzdGF0c1wiXVxuKSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6IFtcIlVua25vd25cIl0sXG4gICAgYm9keTogXCJcIixcbiAgICBkaXNwbGF5RXJyb3I6IGVycm9yLnNwbGl0KFwiXFxuXCIpWzBdLFxuICAgIHN0YXRlOiBcImZhaWxlZFwiLFxuICAgIGhvb2tzOiBbXSxcbiAgICBhdHRlbXB0czogW1xuICAgICAgZ2V0VGVzdEF0dGVtcHQoe1xuICAgICAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLnNwbGl0KFwiXFxuXCIpWzBdLFxuICAgICAgICAgIHN0YWNrOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc2NyZWVuc2hvdHM6IFtdLFxuICAgICAgICBzdGFydGVkQXQ6IHN0YXRzLnN0YXJ0ZWRBdCxcbiAgICAgICAgdmlkZW9UaW1lc3RhbXA6IDAsXG4gICAgICB9KSxcbiAgICBdLFxuICAgIGNsaWVudElkOiBcInIwXCIsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCA9IChcbiAgcnVuUmVzdWx0OiBDeXByZXNzQ29tbWFuZExpbmUuUnVuUmVzdWx0LFxuICBjb25maWc6IEN5cHJlc3MuUmVzb2x2ZWRDb25maWdPcHRpb25zXG4pOiBTZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCA9PiB7XG4gIHJldHVybiB7XG4gICAgY29uZmlnLFxuICAgIHRlc3RzOlxuICAgICAgcnVuUmVzdWx0LnRlc3RzPy5tYXAoKHRlc3QsIGkpID0+ICh7XG4gICAgICAgIHRpdGxlOiB0ZXN0LnRpdGxlLFxuICAgICAgICBjb25maWc6IG51bGwsXG4gICAgICAgIGJvZHk6IHRlc3QuYm9keSxcbiAgICAgICAgY2xpZW50SWQ6IGByJHtpfWAsXG4gICAgICAgIGhvb2tJZHM6IFtdLFxuICAgICAgfSkpID8/IFtdLFxuICAgIGhvb2tzOiBydW5SZXN1bHQuaG9va3MsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc3VtbWFyaXplVGVzdFJlc3VsdHMgPSAoXG4gIGlucHV0OiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFtdLFxuICBjb25maWc6IE1lcmdlZENvbmZpZ1xuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQgPT4ge1xuICBpZiAoIWlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBnZXRFbXB0eUN5cHJlc3NSZXN1bHRzKGNvbmZpZyk7XG4gIH1cblxuICBjb25zdCBvdmVyYWxsID0gaW5wdXQucmVkdWNlKFxuICAgIChcbiAgICAgIGFjYyxcbiAgICAgIHtcbiAgICAgICAgdG90YWxEdXJhdGlvbixcbiAgICAgICAgdG90YWxGYWlsZWQsXG4gICAgICAgIHRvdGFsUGFzc2VkLFxuICAgICAgICB0b3RhbFBlbmRpbmcsXG4gICAgICAgIHRvdGFsU2tpcHBlZCxcbiAgICAgICAgdG90YWxUZXN0cyxcbiAgICAgICAgdG90YWxTdWl0ZXMsXG4gICAgICB9XG4gICAgKSA9PiAoe1xuICAgICAgdG90YWxEdXJhdGlvbjogYWNjLnRvdGFsRHVyYXRpb24gKyB0b3RhbER1cmF0aW9uLFxuICAgICAgdG90YWxTdWl0ZXM6IGFjYy50b3RhbFN1aXRlcyArIHRvdGFsU3VpdGVzLFxuICAgICAgdG90YWxQZW5kaW5nOiBhY2MudG90YWxQZW5kaW5nICsgdG90YWxQZW5kaW5nLFxuICAgICAgdG90YWxGYWlsZWQ6IGFjYy50b3RhbEZhaWxlZCArIHRvdGFsRmFpbGVkLFxuICAgICAgdG90YWxTa2lwcGVkOiBhY2MudG90YWxTa2lwcGVkICsgdG90YWxTa2lwcGVkLFxuICAgICAgdG90YWxQYXNzZWQ6IGFjYy50b3RhbFBhc3NlZCArIHRvdGFsUGFzc2VkLFxuICAgICAgdG90YWxUZXN0czogYWNjLnRvdGFsVGVzdHMgKyB0b3RhbFRlc3RzLFxuICAgIH0pLFxuICAgIGVtcHR5U3RhdHNcbiAgKTtcbiAgY29uc3QgZmlyc3RSZXN1bHQgPSBpbnB1dFswXTtcbiAgY29uc3Qgc3RhcnRJdGVtcyA9IGlucHV0Lm1hcCgoaSkgPT4gaS5zdGFydGVkVGVzdHNBdCkuc29ydCgpO1xuICBjb25zdCBlbmRJdGVtcyA9IGlucHV0Lm1hcCgoaSkgPT4gaS5lbmRlZFRlc3RzQXQpLnNvcnQoKTtcbiAgY29uc3QgcnVucyA9IGlucHV0Lm1hcCgoaSkgPT4gaS5ydW5zKS5mbGF0KCk7XG4gIHJldHVybiB7XG4gICAgLi4ub3ZlcmFsbCxcbiAgICBydW5zLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBfLmZpcnN0KHN0YXJ0SXRlbXMpIGFzIHN0cmluZyxcbiAgICBlbmRlZFRlc3RzQXQ6IF8ubGFzdChlbmRJdGVtcykgYXMgc3RyaW5nLFxuICAgIC4uLl8ucGljayhcbiAgICAgIGZpcnN0UmVzdWx0LFxuICAgICAgXCJicm93c2VyTmFtZVwiLFxuICAgICAgXCJicm93c2VyVmVyc2lvblwiLFxuICAgICAgXCJicm93c2VyUGF0aFwiLFxuICAgICAgXCJvc05hbWVcIixcbiAgICAgIFwib3NWZXJzaW9uXCIsXG4gICAgICBcImN5cHJlc3NWZXJzaW9uXCIsXG4gICAgICBcImNvbmZpZ1wiXG4gICAgKSxcbiAgICBzdGF0dXM6IFwiZmluaXNoZWRcIixcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbXB0eUN5cHJlc3NSZXN1bHRzKFxuICBjb25maWc6IE1lcmdlZENvbmZpZ1xuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQge1xuICByZXR1cm4ge1xuICAgIC4uLmVtcHR5U3RhdHMsXG4gICAgc3RhdHVzOiBcImZpbmlzaGVkXCIsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBlbmRlZFRlc3RzQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBydW5zOiBbXSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uZmlnLFxuICB9O1xufVxuY29uc3QgZW1wdHlTdGF0cyA9IHtcbiAgdG90YWxEdXJhdGlvbjogMCxcbiAgdG90YWxTdWl0ZXM6IDAsXG4gIHRvdGFsUGVuZGluZzogMCxcbiAgdG90YWxGYWlsZWQ6IDAsXG4gIHRvdGFsU2tpcHBlZDogMCxcbiAgdG90YWxQYXNzZWQ6IDAsXG4gIHRvdGFsVGVzdHM6IDAsXG59O1xuXG5jb25zdCBnZXREdW1teUZhaWxlZFRlc3QgPSAoc3RhcnQ6IHN0cmluZywgZXJyb3I6IHN0cmluZykgPT4gKHtcbiAgdGl0bGU6IFtcIlVua25vd25cIl0sXG4gIHN0YXRlOiBcImZhaWxlZFwiLFxuICBib2R5OiBcIi8vIFRoaXMgdGVzdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkdWUgdG8gZXhlY3V0aW9uIGZhaWx1cmVcIixcbiAgZGlzcGxheUVycm9yOiBlcnJvcixcbiAgYXR0ZW1wdHM6IFtcbiAgICB7XG4gICAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICAgIHN0YXJ0ZWRBdDogc3RhcnQsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIHZpZGVvVGltZXN0YW1wOiAwLFxuICAgICAgc2NyZWVuc2hvdHM6IFtdLFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbmFtZTogXCJDeXByZXNzRXhlY3V0aW9uRXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgICAgIHN0YWNrOiBcIlwiLFxuICAgICAgfSxcbiAgICB9LFxuICBdLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWlsZWREdW1teVJlc3VsdChcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICB7XG4gICAgc3BlY3MsXG4gICAgZXJyb3IsXG4gIH06IHtcbiAgICBzcGVjczogc3RyaW5nW107XG4gICAgZXJyb3I6IHN0cmluZztcbiAgfVxuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQge1xuICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgY29uc3QgZW5kID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICByZXR1cm4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25maWc6IGNvbmZpZ1N0YXRlLmdldENvbmZpZygpID8/IHt9LFxuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICAgIHN0YXJ0ZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kZWRUZXN0c0F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdG90YWxEdXJhdGlvbjogMCxcbiAgICB0b3RhbFN1aXRlczogMSxcbiAgICB0b3RhbEZhaWxlZDogMSxcbiAgICB0b3RhbFBhc3NlZDogMCxcbiAgICB0b3RhbFBlbmRpbmc6IDAsXG4gICAgdG90YWxTa2lwcGVkOiAwLFxuICAgIHRvdGFsVGVzdHM6IDEsXG4gICAgYnJvd3Nlck5hbWU6IFwidW5rbm93blwiLFxuICAgIGJyb3dzZXJWZXJzaW9uOiBcInVua25vd25cIixcbiAgICBicm93c2VyUGF0aDogXCJ1bmtub3duXCIsXG4gICAgb3NOYW1lOiBcInVua25vd25cIixcbiAgICBvc1ZlcnNpb246IFwidW5rbm93blwiLFxuICAgIGN5cHJlc3NWZXJzaW9uOiBcInVua25vd25cIixcbiAgICBydW5zOiBzcGVjcy5tYXAoKHMpID0+ICh7XG4gICAgICBzdGF0czoge1xuICAgICAgICBzdWl0ZXM6IDEsXG4gICAgICAgIHRlc3RzOiAxLFxuICAgICAgICBwYXNzZXM6IDAsXG4gICAgICAgIHBlbmRpbmc6IDAsXG4gICAgICAgIHNraXBwZWQ6IDAsXG4gICAgICAgIGZhaWx1cmVzOiAxLFxuICAgICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxuICAgICAgICBlbmRlZEF0OiBlbmQsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgfSxcbiAgICAgIHJlcG9ydGVyOiBcInNwZWNcIixcbiAgICAgIHJlcG9ydGVyU3RhdHM6IHt9LFxuICAgICAgaG9va3M6IFtdLFxuICAgICAgZXJyb3IsXG4gICAgICB2aWRlbzogbnVsbCxcbiAgICAgIHNwZWM6IHtcbiAgICAgICAgbmFtZTogcyxcbiAgICAgICAgcmVsYXRpdmU6IHMsXG4gICAgICAgIGFic29sdXRlOiBzLFxuICAgICAgICByZWxhdGl2ZVRvQ29tbW9uUm9vdDogcyxcbiAgICAgIH0sXG4gICAgICB0ZXN0czogW2dldER1bW15RmFpbGVkVGVzdChzdGFydCwgZXJyb3IpXSxcbiAgICAgIHNob3VsZFVwbG9hZFZpZGVvOiBmYWxzZSxcbiAgICAgIHNraXBwZWRTcGVjOiBmYWxzZSxcbiAgICB9KSksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDeXByZXNzUnVuUmVzdWx0Rm9yU3BlYyhcbiAgc3BlYzogc3RyaW5nLFxuICBjeXByZXNzUmVzdWx0OiBDeXByZXNzUmVzdWx0XG4pOiBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdCB8IHVuZGVmaW5lZCB7XG4gIGlmICghaXNTdWNjZXNzUmVzdWx0KGN5cHJlc3NSZXN1bHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcnVuID0gY3lwcmVzc1Jlc3VsdC5ydW5zLmZpbmQoKHIpID0+IHIuc3BlYy5yZWxhdGl2ZSA9PT0gc3BlYyk7XG4gIGlmICghcnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRzID0gZ2V0U3RhdHMocnVuLnN0YXRzKTtcbiAgLy8gYWRqdXN0IHRoZSByZXN1bHQgZm9yIHNpbmdlIHNwZWNcbiAgcmV0dXJuIHtcbiAgICAuLi5jeXByZXNzUmVzdWx0LFxuICAgIHJ1bnM6IFtydW5dLFxuICAgIHRvdGFsU3VpdGVzOiAxLFxuICAgIHRvdGFsRHVyYXRpb246IHN0YXRzLndhbGxDbG9ja0R1cmF0aW9uLFxuICAgIHRvdGFsVGVzdHM6IHN0YXRzLnRlc3RzLFxuICAgIHRvdGFsRmFpbGVkOiBzdGF0cy5mYWlsdXJlcyxcbiAgICB0b3RhbFBhc3NlZDogc3RhdHMucGFzc2VzLFxuICAgIHRvdGFsUGVuZGluZzogc3RhdHMucGVuZGluZyxcbiAgICB0b3RhbFNraXBwZWQ6IHN0YXRzLnNraXBwZWQsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IHN0YXRzLndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICBlbmRlZFRlc3RzQXQ6IHN0YXRzLndhbGxDbG9ja0VuZGVkQXQsXG4gIH07XG59XG4iLCAiaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHByZXR0eU1TIGZyb20gXCJwcmV0dHktbXNcIjtcbmltcG9ydCB7IHRhYmxlIH0gZnJvbSBcInRhYmxlXCI7XG5pbXBvcnQgeyBjeWFuLCBncmF5LCBncmVlbiwgcmVkLCB3aGl0ZSB9IGZyb20gXCIuLi9sb2dcIjtcblxuY29uc3QgZmFpbHVyZUljb24gPSByZWQoXCJcdTI3MTZcIik7XG5jb25zdCBzdWNjZXNzSWNvbiA9IGdyZWVuKFwiXHUyNzE0XCIpO1xuXG5leHBvcnQgY29uc3Qgc3VtbWFyeVRhYmxlID0gKHI6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0KSA9PiB7XG4gIGNvbnN0IG92ZXJhbGxTcGVjQ291bnQgPSByLnJ1bnMubGVuZ3RoO1xuICBjb25zdCBmYWlsZWRTcGVjc0NvdW50ID0gXy5zdW0oXG4gICAgci5ydW5zLmZpbHRlcigodikgPT4gdi5zdGF0cy5mYWlsdXJlcyArIHYuc3RhdHMuc2tpcHBlZCA+IDApLm1hcCgoKSA9PiAxKVxuICApO1xuICBjb25zdCBoYXNGYWlsZWQgPSBmYWlsZWRTcGVjc0NvdW50ID4gMDtcblxuICBjb25zdCB2ZXJkaWN0ID0gaGFzRmFpbGVkXG4gICAgPyByZWQoYCR7ZmFpbGVkU3BlY3NDb3VudH0gb2YgJHtvdmVyYWxsU3BlY0NvdW50fSBmYWlsZWRgKVxuICAgIDogb3ZlcmFsbFNwZWNDb3VudCA+IDBcbiAgICA/IFwiQWxsIHNwZWNzIHBhc3NlZCFcIlxuICAgIDogXCJObyBzcGVjcyBleGVjdXRlZFwiO1xuXG4gIGNvbnN0IGRhdGEgPSByLnJ1bnMubWFwKChyKSA9PiBbXG4gICAgci5zdGF0cy5mYWlsdXJlcyArIHIuc3RhdHMuc2tpcHBlZCA+IDAgPyBmYWlsdXJlSWNvbiA6IHN1Y2Nlc3NJY29uLFxuICAgIHIuc3BlYy5yZWxhdGl2ZVRvQ29tbW9uUm9vdCxcbiAgICBncmF5KHByZXR0eU1TKHIuc3RhdHMuZHVyYXRpb24pKSxcbiAgICB3aGl0ZShyLnN0YXRzLnRlc3RzID8/IDApLFxuICAgIHIuc3RhdHMucGFzc2VzID8gZ3JlZW4oci5zdGF0cy5wYXNzZXMpIDogZ3JheShcIi1cIiksXG4gICAgci5zdGF0cy5mYWlsdXJlcyA/IHJlZChyLnN0YXRzLmZhaWx1cmVzKSA6IGdyYXkoXCItXCIpLFxuICAgIHIuc3RhdHMucGVuZGluZyA/IGN5YW4oci5zdGF0cy5wZW5kaW5nKSA6IGdyYXkoXCItXCIpLFxuICAgIHIuc3RhdHMuc2tpcHBlZCA/IHJlZChyLnN0YXRzLnNraXBwZWQpIDogZ3JheShcIi1cIiksXG4gIF0pO1xuXG4gIHJldHVybiB0YWJsZShcbiAgICBbXG4gICAgICBbXG4gICAgICAgIFwiXCIsIC8vIG1hcmtlclxuICAgICAgICBncmF5KFwiU3BlY1wiKSxcbiAgICAgICAgXCJcIixcbiAgICAgICAgZ3JheShcIlRlc3RzXCIpLFxuICAgICAgICBncmF5KFwiUGFzc2luZ1wiKSxcbiAgICAgICAgZ3JheShcIkZhaWxpbmdcIiksXG4gICAgICAgIGdyYXkoXCJQZW5kaW5nXCIpLFxuICAgICAgICBncmF5KFwiU2tpcHBlZFwiKSxcbiAgICAgIF0sXG4gICAgICAuLi5kYXRhLFxuICAgICAgW1xuICAgICAgICBoYXNGYWlsZWQgPyBmYWlsdXJlSWNvbiA6IHN1Y2Nlc3NJY29uLCAvLyBtYXJrZXJcbiAgICAgICAgdmVyZGljdCxcbiAgICAgICAgZ3JheShwcmV0dHlNUyhyLnRvdGFsRHVyYXRpb24gPz8gMCkpLFxuICAgICAgICBvdmVyYWxsU3BlY0NvdW50ID4gMCA/IHdoaXRlKHIudG90YWxUZXN0cyA/PyAwKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsUGFzc2VkID8gZ3JlZW4oci50b3RhbFBhc3NlZCkgOiBncmF5KFwiLVwiKSxcbiAgICAgICAgci50b3RhbEZhaWxlZCA/IHJlZChyLnRvdGFsRmFpbGVkKSA6IGdyYXkoXCItXCIpLFxuICAgICAgICByLnRvdGFsUGVuZGluZyA/IGN5YW4oci50b3RhbFBlbmRpbmcpIDogZ3JheShcIi1cIiksXG4gICAgICAgIHIudG90YWxTa2lwcGVkID8gcmVkKHIudG90YWxTa2lwcGVkKSA6IGdyYXkoXCItXCIpLFxuICAgICAgXSxcbiAgICBdLFxuICAgIHtcbiAgICAgIGJvcmRlcixcbiAgICAgIGNvbHVtbkRlZmF1bHQ6IHtcbiAgICAgICAgd2lkdGg6IDgsXG4gICAgICB9LFxuICAgICAgY29sdW1uczogW1xuICAgICAgICB7IGFsaWdubWVudDogXCJsZWZ0XCIsIHdpZHRoOiAyIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcImxlZnRcIiwgd2lkdGg6IDMwIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICAgIHsgYWxpZ25tZW50OiBcInJpZ2h0XCIgfSxcbiAgICAgICAgeyBhbGlnbm1lbnQ6IFwicmlnaHRcIiB9LFxuICAgICAgICB7IGFsaWdubWVudDogXCJyaWdodFwiIH0sXG4gICAgICBdLFxuICAgICAgLy8gc2luZ2xlTGluZTogdHJ1ZSxcbiAgICAgIGRyYXdIb3Jpem9udGFsTGluZTogKGxpbmVJbmRleCwgcm93Q291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBsaW5lSW5kZXggPT09IDEgfHxcbiAgICAgICAgICBsaW5lSW5kZXggPT09IDAgfHxcbiAgICAgICAgICBsaW5lSW5kZXggPT09IHJvd0NvdW50IC0gMSB8fFxuICAgICAgICAgIGxpbmVJbmRleCA9PT0gcm93Q291bnRcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBkcmF3VmVydGljYWxMaW5lOiAobGluZUluZGV4LCByb3dDb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gbGluZUluZGV4ID09PSAwIHx8IHJvd0NvdW50ID09PSBsaW5lSW5kZXg7XG4gICAgICB9LFxuICAgIH1cbiAgKTtcbn07XG5cbmNvbnN0IGJvcmRlciA9IF8ubWFwVmFsdWVzKFxuICB7XG4gICAgdG9wQm9keTogYFx1MjUwMGAsXG4gICAgdG9wSm9pbjogYFx1MjUyQ2AsXG4gICAgdG9wTGVmdDogYCAgXHUyNTBDYCxcbiAgICB0b3BSaWdodDogYFx1MjUxMGAsXG5cbiAgICBib3R0b21Cb2R5OiBgXHUyNTAwYCxcbiAgICBib3R0b21Kb2luOiBgXHUyNTM0YCxcbiAgICBib3R0b21MZWZ0OiBgICBcdTI1MTRgLFxuICAgIGJvdHRvbVJpZ2h0OiBgXHUyNTE4YCxcblxuICAgIGJvZHlMZWZ0OiBgICBcdTI1MDJgLFxuICAgIGJvZHlSaWdodDogYFx1MjUwMmAsXG4gICAgYm9keUpvaW46IGBcdTI1MDJgLFxuXG4gICAgam9pbkJvZHk6IGBcdTI1MDBgLFxuICAgIGpvaW5MZWZ0OiBgICBcdTI1MUNgLFxuICAgIGpvaW5SaWdodDogYFx1MjUyNGAsXG4gICAgam9pbkpvaW46IGBcdTI1M0NgLFxuICB9LFxuICAodikgPT4gZ3JheSh2KVxuKTtcbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQge1xuICByZXBvcnRJbnN0YW5jZVJlc3VsdHNNZXJnZWQsXG4gIHNldEluc3RhbmNlVGVzdHMsXG4gIFNldEluc3RhbmNlVGVzdHNQYXlsb2FkLFxuICB1cGRhdGVJbnN0YW5jZVJlc3VsdHMsXG4gIFVwZGF0ZUluc3RhbmNlUmVzdWx0c1BheWxvYWQsXG59IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCB7IHVwbG9hZEFydGlmYWN0cywgdXBsb2FkU3Rkb3V0U2FmZSB9IGZyb20gXCIuLi9hcnRpZmFjdHNcIjtcbmltcG9ydCB7IHNldENhbmNlbGxhdGlvblJlYXNvbiB9IGZyb20gXCIuLi9jYW5jZWxsYXRpb25cIjtcbmltcG9ydCB7IGdldEluaXRpYWxPdXRwdXQgfSBmcm9tIFwiLi4vY2FwdHVyZVwiO1xuaW1wb3J0IHsgaXNDdXJyZW50cyB9IGZyb20gXCIuLi9lbnZcIjtcbmltcG9ydCB7IENvbmZpZ1N0YXRlLCBFeGVjdXRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0SW5zdGFuY2VSZXN1bHRQYXlsb2FkLCBnZXRJbnN0YW5jZVRlc3RzUGF5bG9hZCB9IGZyb20gXCIuL3Jlc3VsdHNcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXN1bHRzXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVwb3J0UmVzdWx0c1Rhc2soXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIHN0ZG91dDogc3RyaW5nLFxuICBjb3ZlcmFnZUZpbGVQYXRoPzogc3RyaW5nXG4pIHtcbiAgY29uc3QgcmVzdWx0cyA9IGV4ZWN1dGlvblN0YXRlLmdldEluc3RhbmNlUmVzdWx0cyhjb25maWdTdGF0ZSwgaW5zdGFuY2VJZCk7XG4gIGNvbnN0IHJ1biA9IHJlc3VsdHMucnVuc1swXTtcbiAgaWYgKCFydW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBydW4gZm91bmQgaW4gQ3lwcmVzcyByZXN1bHRzXCIpO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlUmVzdWx0cyA9IGdldEluc3RhbmNlUmVzdWx0UGF5bG9hZChydW4sIGNvdmVyYWdlRmlsZVBhdGgpO1xuICBjb25zdCBpbnN0YW5jZVRlc3RzID0gZ2V0SW5zdGFuY2VUZXN0c1BheWxvYWQocnVuLCByZXN1bHRzLmNvbmZpZyk7XG4gIGNvbnN0IHsgdmlkZW9VcGxvYWRVcmwsIHNjcmVlbnNob3RVcGxvYWRVcmxzLCBjb3ZlcmFnZVVwbG9hZFVybCwgY2xvdWQgfSA9XG4gICAgYXdhaXQgcmVwb3J0UmVzdWx0cyhpbnN0YW5jZUlkLCBpbnN0YW5jZVRlc3RzLCBpbnN0YW5jZVJlc3VsdHMpO1xuXG4gIGlmIChjbG91ZD8uc2hvdWxkQ2FuY2VsKSB7XG4gICAgZGVidWcoXCJpbnN0YW5jZSAlcyBzaG91bGQgY2FuY2VsXCIsIGluc3RhbmNlSWQpO1xuICAgIHNldENhbmNlbGxhdGlvblJlYXNvbihjbG91ZC5zaG91bGRDYW5jZWwpO1xuICB9XG5cbiAgZGVidWcoXCJpbnN0YW5jZSAlcyBhcnRpZmFjdCB1cGxvYWQgaW5zdHJ1Y3Rpb25zICVvXCIsIGluc3RhbmNlSWQsIHtcbiAgICB2aWRlb1VwbG9hZFVybCxcbiAgICBzY3JlZW5zaG90VXBsb2FkVXJscyxcbiAgICBjb3ZlcmFnZVVwbG9hZFVybCxcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICB1cGxvYWRBcnRpZmFjdHMoe1xuICAgICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgICB2aWRlb1VwbG9hZFVybCxcbiAgICAgIHZpZGVvUGF0aDogcnVuLnZpZGVvLFxuICAgICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gICAgICBzY3JlZW5zaG90czogaW5zdGFuY2VSZXN1bHRzLnNjcmVlbnNob3RzLFxuICAgICAgY292ZXJhZ2VVcGxvYWRVcmwsXG4gICAgICBjb3ZlcmFnZUZpbGVQYXRoLFxuICAgIH0pLFxuICAgIHVwbG9hZFN0ZG91dFNhZmUoaW5zdGFuY2VJZCwgZ2V0SW5pdGlhbE91dHB1dCgpICsgc3Rkb3V0KSxcbiAgXSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcG9ydFJlc3VsdHMoXG4gIGluc3RhbmNlSWQ6IHN0cmluZyxcbiAgaW5zdGFuY2VUZXN0czogU2V0SW5zdGFuY2VUZXN0c1BheWxvYWQsXG4gIGluc3RhbmNlUmVzdWx0czogVXBkYXRlSW5zdGFuY2VSZXN1bHRzUGF5bG9hZFxuKSB7XG4gIGRlYnVnKFwicmVwb3J0aW5nIGluc3RhbmNlICVzIHJlc3VsdHMuLi5cIiwgaW5zdGFuY2VJZCk7XG4gIGlmIChpc0N1cnJlbnRzKCkpIHtcbiAgICByZXR1cm4gcmVwb3J0SW5zdGFuY2VSZXN1bHRzTWVyZ2VkKGluc3RhbmNlSWQsIHtcbiAgICAgIHRlc3RzOiBpbnN0YW5jZVRlc3RzLFxuICAgICAgcmVzdWx0czogaW5zdGFuY2VSZXN1bHRzLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gcnVuIG9uZSBhZnRlciBhbm90aGVyXG4gIGF3YWl0IHNldEluc3RhbmNlVGVzdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VUZXN0cyk7XG4gIHJldHVybiB1cGRhdGVJbnN0YW5jZVJlc3VsdHMoaW5zdGFuY2VJZCwgaW5zdGFuY2VSZXN1bHRzKTtcbn1cbiIsICJpbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBTY3JlZW5zaG90QXJ0aWZhY3QsIFNjcmVlbnNob3RVcGxvYWRJbnN0cnVjdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdXBkYXRlSW5zdGFuY2VTdGRvdXQgfSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCB7IHNhZmUgfSBmcm9tIFwiLi9sYW5nXCI7XG5pbXBvcnQgeyBkaW0gfSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7IEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4vc3RhdGVcIjtcbmltcG9ydCB7IHVwbG9hZEltYWdlLCB1cGxvYWRKc29uLCB1cGxvYWRWaWRlbyB9IGZyb20gXCIuL3VwbG9hZFwiO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOmFydGlmYWN0c1wiKTtcbmludGVyZmFjZSBVcGxvYWRBcnRpZmFjdHMge1xuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGU7XG4gIHZpZGVvUGF0aDogc3RyaW5nIHwgbnVsbDtcbiAgdmlkZW9VcGxvYWRVcmw/OiBzdHJpbmcgfCBudWxsO1xuICBzY3JlZW5zaG90czogU2NyZWVuc2hvdEFydGlmYWN0W107XG4gIHNjcmVlbnNob3RVcGxvYWRVcmxzOiBTY3JlZW5zaG90VXBsb2FkSW5zdHJ1Y3Rpb25bXTtcbiAgY292ZXJhZ2VVcGxvYWRVcmw/OiBzdHJpbmcgfCBudWxsO1xuICBjb3ZlcmFnZUZpbGVQYXRoPzogc3RyaW5nIHwgbnVsbDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRBcnRpZmFjdHMoe1xuICBleGVjdXRpb25TdGF0ZSxcbiAgdmlkZW9QYXRoLFxuICB2aWRlb1VwbG9hZFVybCxcbiAgc2NyZWVuc2hvdHMsXG4gIHNjcmVlbnNob3RVcGxvYWRVcmxzLFxuICBjb3ZlcmFnZUZpbGVQYXRoLFxuICBjb3ZlcmFnZVVwbG9hZFVybCxcbn06IFVwbG9hZEFydGlmYWN0cykge1xuICBkZWJ1ZyhcInVwbG9hZGluZyBhcnRpZmFjdHM6ICVvXCIsIHtcbiAgICB2aWRlb1BhdGgsXG4gICAgdmlkZW9VcGxvYWRVcmwsXG4gICAgc2NyZWVuc2hvdHMsXG4gICAgc2NyZWVuc2hvdFVwbG9hZFVybHMsXG4gICAgY292ZXJhZ2VGaWxlUGF0aCxcbiAgICBjb3ZlcmFnZVVwbG9hZFVybCxcbiAgfSk7XG5cbiAgY29uc3QgdG90YWxVcGxvYWRzID1cbiAgICAodmlkZW9QYXRoID8gMSA6IDApICsgc2NyZWVuc2hvdHMubGVuZ3RoICsgKGNvdmVyYWdlVXBsb2FkVXJsID8gMSA6IDApO1xuICBpZiAodG90YWxVcGxvYWRzID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXBsb2FkIHZpZGVvXG4gIGlmICh2aWRlb1VwbG9hZFVybCAmJiB2aWRlb1BhdGgpIHtcbiAgICBhd2FpdCBzYWZlKFxuICAgICAgdXBsb2FkVmlkZW8sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBkZWJ1ZyhcImZhaWxlZCB1cGxvYWRpbmcgdmlkZW8gJXMuIEVycm9yOiAlb1wiLCB2aWRlb1BhdGgsIGUpO1xuICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgIGBGYWlsZWQgdXBsb2FkaW5nIHZpZGVvICR7dmlkZW9QYXRofS5cXG4ke2RpbShlKX1gXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKCkgPT4gZGVidWcoXCJzdWNjZXNzIHVwbG9hZGluZ1wiLCB2aWRlb1BhdGgpXG4gICAgKSh2aWRlb1BhdGgsIHZpZGVvVXBsb2FkVXJsKTtcbiAgfVxuICAvLyB1cGxvYWQgc2NyZWVuc2hvdHNcbiAgaWYgKHNjcmVlbnNob3RVcGxvYWRVcmxzICYmIHNjcmVlbnNob3RVcGxvYWRVcmxzLmxlbmd0aCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc2NyZWVuc2hvdHMubWFwKChzY3JlZW5zaG90KSA9PiB7XG4gICAgICAgIGNvbnN0IHVybCA9IHNjcmVlbnNob3RVcGxvYWRVcmxzLmZpbmQoXG4gICAgICAgICAgKHVybHMpID0+IHVybHMuc2NyZWVuc2hvdElkID09PSBzY3JlZW5zaG90LnNjcmVlbnNob3RJZFxuICAgICAgICApPy51cGxvYWRVcmw7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICBcIk5vIHVwbG9hZCB1cmwgZm9yIHNjcmVlbnNob3QgJW8sIHNjcmVlbnNob3RVcGxvYWRVcmxzOiAlb1wiLFxuICAgICAgICAgICAgc2NyZWVuc2hvdCxcbiAgICAgICAgICAgIHNjcmVlbnNob3RVcGxvYWRVcmxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgICAgYE5vIHVwbG9hZCBVUkwgZm9yIHNjcmVlbnNob3QgJHtzY3JlZW5zaG90LnBhdGh9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYWZlKFxuICAgICAgICAgIHVwbG9hZEltYWdlLFxuICAgICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgICAgXCJmYWlsZWQgdXBsb2FkaW5nIHNjcmVlbnNob3QgJXMuIEVycm9yOiAlb1wiLFxuICAgICAgICAgICAgICBzY3JlZW5zaG90LnBhdGgsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleGVjdXRpb25TdGF0ZS5hZGRXYXJuaW5nKFxuICAgICAgICAgICAgICBgRmFpbGVkIHVwbG9hZGluZyBzY3JlZW5zaG90ICR7c2NyZWVuc2hvdC5wYXRofS5cXG4ke2RpbShlKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gZGVidWcoXCJzdWNjZXNzIHVwbG9hZGluZ1wiLCBzY3JlZW5zaG90LnBhdGgpXG4gICAgICAgICkoc2NyZWVuc2hvdC5wYXRoLCB1cmwpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8vIHVwbG9hZCBjb3ZlcmFnZVxuICBpZiAoY292ZXJhZ2VVcGxvYWRVcmwgJiYgY292ZXJhZ2VGaWxlUGF0aCkge1xuICAgIGF3YWl0IHNhZmUoXG4gICAgICB1cGxvYWRKc29uLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJmYWlsZWQgdXBsb2FkaW5nIGNvdmVyYWdlIGZpbGUgJXMuIEVycm9yOiAlb1wiLFxuICAgICAgICAgIGNvdmVyYWdlRmlsZVBhdGgsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuXG4gICAgICAgIGV4ZWN1dGlvblN0YXRlLmFkZFdhcm5pbmcoXG4gICAgICAgICAgYEZhaWxlZCB1cGxvYWRpbmcgY292ZXJhZ2UgZmlsZSAke2NvdmVyYWdlRmlsZVBhdGh9LlxcbiR7ZGltKGUpfWBcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgICgpID0+IGRlYnVnKFwic3VjY2VzcyB1cGxvYWRpbmdcIiwgY292ZXJhZ2VGaWxlUGF0aClcbiAgICApKGNvdmVyYWdlRmlsZVBhdGgsIGNvdmVyYWdlVXBsb2FkVXJsKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBsb2FkU3Rkb3V0U2FmZSA9IHNhZmUoXG4gIHVwZGF0ZUluc3RhbmNlU3Rkb3V0LFxuICAoKSA9PiB7fSxcbiAgKCkgPT4ge31cbik7XG4iLCAiaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgbWFrZVJlcXVlc3QgfSBmcm9tIFwiLi9odHRwQ2xpZW50XCI7XG5jb25zdCByZWFkRmlsZSA9IGZzLnByb21pc2VzLnJlYWRGaWxlO1xuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnVwbG9hZFwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZFZpZGVvKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcInZpZGVvL21wNFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZEltYWdlKGZpbGU6IHN0cmluZywgdXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVwbG9hZEZpbGUoZmlsZSwgdXJsLCBcImltYWdlL3BuZ1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZEpzb24oZmlsZTogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICByZXR1cm4gdXBsb2FkRmlsZShmaWxlLCB1cmwsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbn1cblxudHlwZSBVcGxvYWRUeXBlcyA9XG4gIHwgXCJ2aWRlby9tcDRcIlxuICB8IFwiaW1hZ2UvcG5nXCJcbiAgfCBcInBsYWluL3RleHRcIlxuICB8IFwiYXBwbGljYXRpb24vanNvblwiO1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZShmaWxlOiBzdHJpbmcsIHVybDogc3RyaW5nLCB0eXBlOiBVcGxvYWRUeXBlcykge1xuICBkZWJ1ZygndXBsb2FkaW5nIGZpbGUgXCIlc1wiIHRvIFwiJXNcIicsIGZpbGUsIHVybCk7XG4gIGNvbnN0IGYgPSBhd2FpdCByZWFkRmlsZShmaWxlKTtcbiAgYXdhaXQgbWFrZVJlcXVlc3Qoe1xuICAgIHVybCxcbiAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgZGF0YTogZixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiB0eXBlLFxuICAgICAgXCJDb250ZW50LURpc3Bvc2l0aW9uXCI6IGBpbmxpbmVgLFxuICAgIH0sXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IEV2ZW50LCBwdWJzdWIgfSBmcm9tIFwiLi4vcHVic3ViXCI7XG5cbmludGVyZmFjZSBFeGVjdXRpb25TdGF0ZSB7XG4gIGNhbmNlbGxhdGlvblJlYXNvbjogc3RyaW5nIHwgbnVsbDtcbn1cbmNvbnN0IHN0YXRlOiBFeGVjdXRpb25TdGF0ZSA9IHtcbiAgY2FuY2VsbGF0aW9uUmVhc29uOiBudWxsLFxufTtcblxuZXhwb3J0IGNvbnN0IHNldENhbmNlbGxhdGlvblJlYXNvbiA9IChyZWFzb246IHN0cmluZykgPT4ge1xuICBpZiAoc3RhdGUuY2FuY2VsbGF0aW9uUmVhc29uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0YXRlLmNhbmNlbGxhdGlvblJlYXNvbiA9IHJlYXNvbjtcbiAgcHVic3ViLmVtaXQoRXZlbnQuUlVOX0NBTkNFTExFRCwgcmVhc29uKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDYW5jZWxsYXRpb25SZWFzb24gPSAoKSA9PiBzdGF0ZS5jYW5jZWxsYXRpb25SZWFzb247XG4iLCAiaW1wb3J0IHtcbiAgU3BlY1dpdGhSZWxhdGl2ZVJvb3QsXG4gIFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycyxcbn0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IGdldENhcHR1cmVkT3V0cHV0LCByZXNldENhcHR1cmUgfSBmcm9tIFwiLi4vY2FwdHVyZVwiO1xuXG5pbXBvcnQgeyBnZXRDeXByZXNzUnVuUmVzdWx0Rm9yU3BlYyB9IGZyb20gXCIuLi9yZXN1bHRzXCI7XG5cbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUJhdGNoZWRJbnN0YW5jZXMsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICBDcmVhdGVJbnN0YW5jZVBheWxvYWQsXG4gIEluc3RhbmNlUmVzcG9uc2VTcGVjRGV0YWlscyxcbn0gZnJvbSBcIi4uL2FwaVwiO1xuXG5pbXBvcnQgeyBydW5TcGVjRmlsZVNhZmUgfSBmcm9tIFwiLi4vY3lwcmVzc1wiO1xuaW1wb3J0IHsgaXNDdXJyZW50cyB9IGZyb20gXCIuLi9lbnZcIjtcbmltcG9ydCB7IGRpdmlkZXIsIGluZm8sIHRpdGxlLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXBvcnRUYXNrLCByZXBvcnRUYXNrcyB9IGZyb20gXCIuL3JlcG9ydFRhc2tcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnJ1bm5lclwiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1blRpbGxEb25lKFxuICBleGVjdXRpb25TdGF0ZTogRXhlY3V0aW9uU3RhdGUsXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAge1xuICAgIHJ1bklkLFxuICAgIGdyb3VwSWQsXG4gICAgbWFjaGluZUlkLFxuICAgIHBsYXRmb3JtLFxuICAgIHNwZWNzOiBhbGxTcGVjcyxcbiAgfTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkICYge1xuICAgIHNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdO1xuICB9LFxuICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVyc1xuKSB7XG4gIGxldCBoYXNNb3JlID0gdHJ1ZTtcblxuICB3aGlsZSAoaGFzTW9yZSkge1xuICAgIGNvbnN0IG5ld1Rhc2tzID0gYXdhaXQgcnVuQmF0Y2goZXhlY3V0aW9uU3RhdGUsIGNvbmZpZ1N0YXRlLCB7XG4gICAgICBydW5NZXRhOiB7XG4gICAgICAgIHJ1bklkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBtYWNoaW5lSWQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgfSxcbiAgICAgIGFsbFNwZWNzLFxuICAgICAgcGFyYW1zLFxuICAgIH0pO1xuICAgIGlmICghbmV3VGFza3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZyhcIk5vIG1vcmUgdGFza3MgdG8gcnVuLiBVcGxvYWRzIHF1ZXVlOiAlZFwiLCByZXBvcnRUYXNrcy5sZW5ndGgpO1xuICAgICAgaGFzTW9yZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5ld1Rhc2tzLmZvckVhY2goKHQpID0+XG4gICAgICBjcmVhdGVSZXBvcnRUYXNrKGNvbmZpZ1N0YXRlLCBleGVjdXRpb25TdGF0ZSwgdC5pbnN0YW5jZUlkKVxuICAgICk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQmF0Y2goXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgY29uZmlnU3RhdGU6IENvbmZpZ1N0YXRlLFxuICB7XG4gICAgcnVuTWV0YSxcbiAgICBwYXJhbXMsXG4gICAgYWxsU3BlY3MsXG4gIH06IHtcbiAgICBydW5NZXRhOiB7XG4gICAgICBydW5JZDogc3RyaW5nO1xuICAgICAgZ3JvdXBJZDogc3RyaW5nO1xuICAgICAgbWFjaGluZUlkOiBzdHJpbmc7XG4gICAgICBwbGF0Zm9ybTogQ3JlYXRlSW5zdGFuY2VQYXlsb2FkW1wicGxhdGZvcm1cIl07XG4gICAgfTtcbiAgICBhbGxTcGVjczogU3BlY1dpdGhSZWxhdGl2ZVJvb3RbXTtcbiAgICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbiAgfVxuKSB7XG4gIGxldCBiYXRjaCA9IHtcbiAgICBzcGVjczogW10gYXMgSW5zdGFuY2VSZXNwb25zZVNwZWNEZXRhaWxzW10sXG4gICAgY2xhaW1lZEluc3RhbmNlczogMCxcbiAgICB0b3RhbEluc3RhbmNlczogMCxcbiAgfTtcblxuICBpZiAoaXNDdXJyZW50cygpKSB7XG4gICAgZGVidWcoXCJHZXR0aW5nIGJhdGNoZWQgdGFza3M6ICVkXCIsIHBhcmFtcy5iYXRjaFNpemUpO1xuICAgIGJhdGNoID0gYXdhaXQgY3JlYXRlQmF0Y2hlZEluc3RhbmNlcyh7XG4gICAgICAuLi5ydW5NZXRhLFxuICAgICAgYmF0Y2hTaXplOiBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIH0pO1xuICAgIGRlYnVnKFwiR290IGJhdGNoZWQgdGFza3M6ICVvXCIsIGJhdGNoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUluc3RhbmNlKHJ1bk1ldGEpO1xuXG4gICAgaWYgKHJlc3BvbnNlLnNwZWMgIT09IG51bGwgJiYgcmVzcG9uc2UuaW5zdGFuY2VJZCAhPT0gbnVsbCkge1xuICAgICAgYmF0Y2guc3BlY3MucHVzaCh7XG4gICAgICAgIHNwZWM6IHJlc3BvbnNlLnNwZWMsXG4gICAgICAgIGluc3RhbmNlSWQ6IHJlc3BvbnNlLmluc3RhbmNlSWQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYmF0Y2guY2xhaW1lZEluc3RhbmNlcyA9IHJlc3BvbnNlLmNsYWltZWRJbnN0YW5jZXM7XG4gICAgYmF0Y2gudG90YWxJbnN0YW5jZXMgPSByZXNwb25zZS50b3RhbEluc3RhbmNlcztcbiAgfVxuXG4gIGlmIChiYXRjaC5zcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogQmF0Y2ggY2FuIGhhdmUgbXVsdGlwbGUgc3BlY3MuIFdoaWxlIHJ1bm5pbmcgdGhlIHNwZWNzLFxuICAgKiBjeXByZXNzIGNhbiBoYXJkLWNyYXNoIHdpdGhvdXQgcmVwb3J0aW5nIGFueSByZXN1bHQuXG4gICAqXG4gICAqIFdoZW4gY3Jhc2hlZCwgaWRlYWxseSwgd2UgbmVlZCB0bzpcbiAgICogLSBkZXRlcm1pbmUgd2hpY2ggc3BlYyBjcmFzaGVkXG4gICAqIC0gYXNzb2NpYXRlIHRoZSBjcmFzaCB3aXRoIHRoZSBzcGVjXG4gICAqIC0gcnVuIHRoZSByZXN0IG9mIHVucmVwb3J0ZWQgc3BlY3MgaW4gdGhlIGJhdGNoXG4gICAqXG4gICAqIEJ1dCBkZXRlY3RpbmcgdGhlIGNyYXNoZWQgc3BlYyBpcyBlcnJvci1wcm9uZSBhbmQgaW5hY2N1cmF0ZSxcbiAgICogc28gd2UgZmFsbCBiYWNrIHRvIHJlcG9ydGluZyBoYXJkIGNyYXNoIHRvIGFsbCBzdWJzZXF1ZW50XG4gICAqIHNwZWNzIGluIHRoZSBiYXRjaC5cbiAgICpcbiAgICogV29yc3QtY2FzZSBzY2VuYXJpbzogd2UgcmVwb3J0IGhhcmQgY3Jhc2ggdG8gYWxsIHNwZWNzIGluIHRoZSBiYXRjaC5cbiAgICovXG5cbiAgLy8gJXN0YXRlXG4gIGJhdGNoLnNwZWNzLmZvckVhY2goKGkpID0+IGV4ZWN1dGlvblN0YXRlLmluaXRJbnN0YW5jZShpKSk7XG5cbiAgZGl2aWRlcigpO1xuICBpbmZvKFxuICAgIFwiUnVubmluZzogJXMgKCVkLyVkKVwiLFxuICAgIGJhdGNoLnNwZWNzLm1hcCgocykgPT4gcy5zcGVjKS5qb2luKFwiLCBcIiksXG4gICAgYmF0Y2guY2xhaW1lZEluc3RhbmNlcyxcbiAgICBiYXRjaC50b3RhbEluc3RhbmNlc1xuICApO1xuXG4gIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHJ1blNwZWNGaWxlU2FmZShcbiAgICB7XG4gICAgICAvLyB1c2UgYWJzb2x1dGUgcGF0aHMgLSB1c2VyIGNhbiBydW4gdGhlIHByb2dyYW0gZnJvbSBhIGRpZmZlcmVudCBkaXJlY3RvcnksIGUuZy4gbnggb3IgYSBtb25vcmVwbyB3b3Jrc3BhY2VcbiAgICAgIC8vIGN5cHJlc3Mgc3RpbGwgcmVwb3J0IHRoZSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBwcm9qZWN0IHJvb3RcbiAgICAgIHNwZWM6IGJhdGNoLnNwZWNzXG4gICAgICAgIC5tYXAoKGJzKSA9PiBnZXRTcGVjQWJzb2x1dGVQYXRoKGFsbFNwZWNzLCBicy5zcGVjKSlcbiAgICAgICAgLmpvaW4oXCIsXCIpLFxuICAgIH0sXG4gICAgcGFyYW1zXG4gICk7XG5cbiAgdGl0bGUoXCJibHVlXCIsIFwiUmVwb3J0aW5nIHJlc3VsdHMgYW5kIGFydGlmYWN0cyBpbiBiYWNrZ3JvdW5kLi4uXCIpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGdldENhcHR1cmVkT3V0cHV0KCk7XG5cbiAgLy8gJXN0YXRlXG4gIGJhdGNoLnNwZWNzLmZvckVhY2goKHNwZWMpID0+IHtcbiAgICBleGVjdXRpb25TdGF0ZS5zZXRJbnN0YW5jZU91dHB1dChzcGVjLmluc3RhbmNlSWQsIG91dHB1dCk7XG4gICAgY29uc3Qgc3BlY1J1blJlc3VsdCA9IGdldEN5cHJlc3NSdW5SZXN1bHRGb3JTcGVjKHNwZWMuc3BlYywgcmF3UmVzdWx0KTtcbiAgICBpZiAoIXNwZWNSdW5SZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhlY3V0aW9uU3RhdGUuc2V0SW5zdGFuY2VSZXN1bHQoXG4gICAgICBjb25maWdTdGF0ZSxcbiAgICAgIHNwZWMuaW5zdGFuY2VJZCxcbiAgICAgIHNwZWNSdW5SZXN1bHRcbiAgICApO1xuICB9KTtcblxuICByZXNldENhcHR1cmUoKTtcblxuICByZXR1cm4gYmF0Y2guc3BlY3M7XG59XG5cbmZ1bmN0aW9uIGdldFNwZWNBYnNvbHV0ZVBhdGgoXG4gIGFsbFNwZWNzOiBTcGVjV2l0aFJlbGF0aXZlUm9vdFtdLFxuICByZWxhdGl2ZTogc3RyaW5nXG4pIHtcbiAgY29uc3QgYWJzb2x1dGVQYXRoID0gYWxsU3BlY3MuZmluZCgoaSkgPT4gaS5yZWxhdGl2ZSA9PT0gcmVsYXRpdmUpPy5hYnNvbHV0ZTtcbiAgaWYgKCFhYnNvbHV0ZVBhdGgpIHtcbiAgICB3YXJuKFxuICAgICAgJ0Nhbm5vdCBmaW5kIGFic29sdXRlIHBhdGggZm9yIHNwZWMuIFNwZWM6IFwiJXNcIiwgY2FuZGlkYXRlczogJW8nLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBhbGxTcGVjc1xuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhYnNvbHV0ZSBwYXRoIGZvciBzcGVjYCk7XG4gIH1cbiAgcmV0dXJuIGFic29sdXRlUGF0aDtcbn1cbiIsICJpbXBvcnQgeyBJbnN0YW5jZUlkIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IGVycm9yIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0UmVwb3J0UmVzdWx0c1Rhc2sgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUsIEV4ZWN1dGlvblN0YXRlIH0gZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpyZXBvcnRUYXNrXCIpO1xuXG5leHBvcnQgY29uc3QgcmVwb3J0VGFza3M6IFByb21pc2U8YW55PltdID0gW107XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXBvcnRUYXNrID0gKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgaW5zdGFuY2VJZDogSW5zdGFuY2VJZFxuKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gZXhlY3V0aW9uU3RhdGUuZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICBlcnJvcihcIkNhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgJXNcIiwgaW5zdGFuY2VJZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnN0YW5jZS5yZXBvcnRTdGFydGVkQXQpIHtcbiAgICBkZWJ1ZyhcIlJlcG9ydCB0YXNrIGFscmVhZHkgY3JlYXRlZCBmb3IgaW5zdGFuY2UgJXNcIiwgaW5zdGFuY2VJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5zdGFuY2UucmVwb3J0U3RhcnRlZEF0ID0gbmV3IERhdGUoKTtcblxuICBkZWJ1ZyhcIkNyZWF0aW5nIHJlcG9ydCB0YXNrIGZvciBpbnN0YW5jZUlkICVzXCIsIGluc3RhbmNlSWQpO1xuICByZXBvcnRUYXNrcy5wdXNoKFxuICAgIGdldFJlcG9ydFJlc3VsdHNUYXNrKFxuICAgICAgaW5zdGFuY2VJZCxcbiAgICAgIGNvbmZpZ1N0YXRlLFxuICAgICAgZXhlY3V0aW9uU3RhdGUsXG4gICAgICBpbnN0YW5jZS5vdXRwdXQgPz8gXCJubyBvdXRwdXQgY2FwdHVyZWRcIixcbiAgICAgIGluc3RhbmNlLmNvdmVyYWdlRmlsZVBhdGhcbiAgICApLmNhdGNoKGVycm9yKVxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcG9ydFRhc2tTcGVjID0gKFxuICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gIGV4ZWN1dGlvblN0YXRlOiBFeGVjdXRpb25TdGF0ZSxcbiAgc3BlYzogc3RyaW5nXG4pID0+IHtcbiAgY29uc3QgaSA9IGV4ZWN1dGlvblN0YXRlLmdldFNwZWMoc3BlYyk7XG4gIGlmICghaSkge1xuICAgIGVycm9yKFwiQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjICVzXCIsIHNwZWMpO1xuICAgIHJldHVybjtcbiAgfVxuICBkZWJ1ZyhcIkNyZWF0aW5nIHJlcG9ydCB0YXNrIGZvciBzcGVjICVzXCIsIHNwZWMpO1xuICByZXR1cm4gY3JlYXRlUmVwb3J0VGFzayhjb25maWdTdGF0ZSwgZXhlY3V0aW9uU3RhdGUsIGkuaW5zdGFuY2VJZCk7XG59O1xuIiwgImltcG9ydCB7IEJQcm9taXNlIH0gZnJvbSBcIi4uL2xhbmdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBFdmVudCwgcHVic3ViIH0gZnJvbSBcIi4uL3B1YnN1YlwiO1xuaW1wb3J0IHsgcnVuVGlsbERvbmUgfSBmcm9tIFwiLi9ydW5uZXJcIjtcblxubGV0IGNhbmNlbGxhYmxlOiB7XG4gIGNhbmNlbDogKCkgPT4gdm9pZDtcbn0gfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gb25SdW5DYW5jZWxsZWQocmVhc29uOiBzdHJpbmcpIHtcbiAgd2FybihcbiAgICBgUnVuIGNhbmNlbGxlZDogJXMuIFdhaXRpbmcgZm9yIHVwbG9hZHMgdG8gY29tcGxldGUgYW5kIHN0b3BwaW5nIGV4ZWN1dGlvbi4uLmAsXG4gICAgcmVhc29uXG4gICk7XG4gIGNhbmNlbGxhYmxlPy5jYW5jZWwoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5UaWxsRG9uZU9yQ2FuY2VsbGVkKFxuICAuLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBydW5UaWxsRG9uZT5cbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgY2FuY2VsbGFibGUgPSBuZXcgQlByb21pc2UoKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpID0+IHtcbiAgICAgIGlmICghb25DYW5jZWwpIHtcbiAgICAgICAgX3JlamVjdChuZXcgRXJyb3IoXCJCbHVlQmlyZCBpcyBtaXNjb25maWd1cmVkOiBvbkNhbmNlbCBpcyB1bmRlZmluZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvbkNhbmNlbCgoKSA9PiBfcmVzb2x2ZSh2b2lkIDApKTtcbiAgICAgIHJ1blRpbGxEb25lKC4uLmFyZ3MpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgX3Jlc29sdmUodm9pZCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgX3JlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBwdWJzdWIuYWRkTGlzdGVuZXIoRXZlbnQuUlVOX0NBTkNFTExFRCwgb25SdW5DYW5jZWxsZWQpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBwdWJzdWIucmVtb3ZlTGlzdGVuZXIoRXZlbnQuUlVOX0NBTkNFTExFRCwgb25SdW5DYW5jZWxsZWQpO1xuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBzdG9wV1NTIH0gZnJvbSBcIi4vd3NcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNodXRkb3duKCkge1xuICBhd2FpdCBzdG9wV1NTKCk7XG59XG4iLCAiLyohIEBwcmVzZXJ2ZVxuXG4jIyMgTUlUXG5cblBhcnRzIG9mIHRoaXMgY29kZSB3YXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2N5cHJlc3MtaW8vY3lwcmVzcyBhbmQgaXMgc3ViamVjdCB0byBNSVQgbGljZW5zZS5cblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDIyIEN5cHJlc3MuaW9cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcblxuaW1wb3J0IGNvbW1vblBhdGhQcmVmaXggZnJvbSBcImNvbW1vbi1wYXRoLXByZWZpeFwiO1xuaW1wb3J0IGdsb2JieSwgeyBHbG9iYnlPcHRpb25zIH0gZnJvbSBcImdsb2JieVwiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0IHtcbiAgRmluZFNwZWNzLFxuICBTcGVjVHlwZSxcbiAgU3BlY1dpdGhSZWxhdGl2ZVJvb3QsXG4gIFRlc3RpbmdUeXBlLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRvQXJyYXksIHRvUG9zaXggfSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcImN1cnJlbnRzOnNwZWNzXCIpO1xuXG50eXBlIEdsb2JQYXR0ZXJuID0gc3RyaW5nIHwgc3RyaW5nW107XG5cbi8qKlxuICogUmVwbGljYXRlIGhvdyBjeXByZXNzIGlzIGRpc2NvdmVyaW5nIHNwZWMgZmlsZXNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXByZXNzLWlvL2N5cHJlc3MvYmxvYi9iYzllZGI0NDUyM2Q2MmNhOTM0ODI3YjhlODcwZjM4Zjg2NjM0Y2E0L3BhY2thZ2VzL2RhdGEtY29udGV4dC9zcmMvc291cmNlcy9Qcm9qZWN0RGF0YVNvdXJjZS50cyNMMjUwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY3lwcmVzcy1pby9jeXByZXNzL2Jsb2IvYmM5ZWRiNDQ1MjNkNjJjYTkzNDgyN2I4ZTg3MGYzOGY4NjYzNGNhNC9wYWNrYWdlcy9kYXRhLWNvbnRleHQvc3JjL2FjdGlvbnMvUHJvamVjdEFjdGlvbnMudHMjTDQxN1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZFNwZWNzKHtcbiAgcHJvamVjdFJvb3QsXG4gIHRlc3RpbmdUeXBlLFxuICBzcGVjUGF0dGVybixcbiAgY29uZmlnU3BlY1BhdHRlcm4sXG4gIGV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4sXG59OiBGaW5kU3BlY3M8c3RyaW5nW10gfCBzdHJpbmc+KTogUHJvbWlzZTxTcGVjV2l0aFJlbGF0aXZlUm9vdFtdPiB7XG4gIGNvbmZpZ1NwZWNQYXR0ZXJuID0gdG9BcnJheShjb25maWdTcGVjUGF0dGVybik7XG4gIHNwZWNQYXR0ZXJuID0gdG9BcnJheShzcGVjUGF0dGVybik7XG4gIGV4Y2x1ZGVTcGVjUGF0dGVybiA9IHRvQXJyYXkoZXhjbHVkZVNwZWNQYXR0ZXJuKSB8fCBbXTtcblxuICAvLyBleGNsdWRlIGFsbCBzcGVjcyBtYXRjaGluZyBlMmUgaWYgaW4gY29tcG9uZW50IHRlc3RpbmdcbiAgYWRkaXRpb25hbElnbm9yZVBhdHRlcm4gPSB0b0FycmF5KGFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuKSB8fCBbXTtcblxuICBkZWJ1ZyhcImV4cGxvcmluZyBzcGVjIGZpbGVzIGZvciBleGVjdXRpb24gJU9cIiwge1xuICAgIHRlc3RpbmdUeXBlLFxuICAgIHByb2plY3RSb290LFxuICAgIHNwZWNQYXR0ZXJuLFxuICAgIGNvbmZpZ1NwZWNQYXR0ZXJuLFxuICAgIGV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgfSk7XG5cbiAgaWYgKCFzcGVjUGF0dGVybiB8fCAhY29uZmlnU3BlY1BhdHRlcm4pIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGdsb2IgcGF0dGVybnMgZm9yIGV4cGxvcmluZyBzcGVjc1wiKTtcbiAgfVxuXG4gIGxldCBzcGVjQWJzb2x1dGVQYXRocyA9IGF3YWl0IGdldEZpbGVzQnlHbG9iKHByb2plY3RSb290LCBzcGVjUGF0dGVybiwge1xuICAgIGFic29sdXRlOiB0cnVlLFxuICAgIGlnbm9yZTogWy4uLmV4Y2x1ZGVTcGVjUGF0dGVybiwgLi4uYWRkaXRpb25hbElnbm9yZVBhdHRlcm5dLFxuICB9KTtcblxuICAvLyBJZiB0aGUgc3BlY1BhdHRlcm4gYW5kIGNvbmZpZ1NwZWNQYXR0ZXJuIGFyZSBkaWZmZXJlbnQsXG4gIC8vIGl0IG1lYW5zIHRoZSB1c2VyIHBhc3NlZCBzb21ldGhpbmcgbm9uLWRlZmF1bHQgdmlhIC0tc3BlYyAocnVuIG1vZGUgb25seSlcbiAgLy8gaW4gdGhpcyBzY2VuYXJpbywgd2Ugd2FudCB0byBncmFiIGV2ZXJ5dGhpbmcgdGhhdCBtYXRjaGVzIGAtLXNwZWNgXG4gIC8vIHRoYXQgZmFsbHMgd2l0aGluIHRoZWlyIGRlZmF1bHQgc3BlY1BhdHRlcm4uIFRoZSByZWFzb24gaXMgc28gd2UgYXZvaWRcbiAgLy8gYXR0ZW1wdGluZyB0byBydW4gdGhpbmdzIHRoYXQgYXJlIG5vdCBzcGVjcywgZWcgc291cmNlIGNvZGUsIHZpZGVvcywgZXRjLlxuICAvL1xuICAvLyBFeGFtcGxlOiBkZXZlbG9wZXIgd2FudHMgdG8gcnVuIHRlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aW1lcnMgaW4gcGFja2FnZXMvZHJpdmVyXG4gIC8vIFNvIHRoZXkgcnVuIHlhcm4gY3lwcmVzczpydW4gLS1zcGVjICoqL3RpbWVycypcbiAgLy8gd2UgZG8gKipub3QqKiB3YW50IHRvIGNhcHR1cmUgYHRpbWVycy50c2AgKHNvdXJjZSBjb2RlKSBvciBhIHZpZGVvIGluXG4gIC8vIGN5cHJlc3MvdmlkZW9zL3RpbWVycy5jeS50cy5tcDQsIHNvIHdlIHRha2UgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHNwZWNQYXR0ZXJuXG4gIC8vIGFuZCAtLXNwZWMuXG4gIGlmICghXy5pc0VxdWFsKHNwZWNQYXR0ZXJuLCBjb25maWdTcGVjUGF0dGVybikpIHtcbiAgICBjb25zdCBkZWZhdWx0U3BlY0Fic29sdXRlUGF0aHMgPSBhd2FpdCBnZXRGaWxlc0J5R2xvYihcbiAgICAgIHByb2plY3RSb290LFxuICAgICAgY29uZmlnU3BlY1BhdHRlcm4sXG4gICAgICB7XG4gICAgICAgIGFic29sdXRlOiB0cnVlLFxuICAgICAgICBpZ25vcmU6IFsuLi5leGNsdWRlU3BlY1BhdHRlcm4sIC4uLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuXSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgc3BlY0Fic29sdXRlUGF0aHMgPSBfLmludGVyc2VjdGlvbihcbiAgICAgIHNwZWNBYnNvbHV0ZVBhdGhzLFxuICAgICAgZGVmYXVsdFNwZWNBYnNvbHV0ZVBhdGhzXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkU3BlY3Moe1xuICAgIHByb2plY3RSb290LFxuICAgIHRlc3RpbmdUeXBlLFxuICAgIHNwZWNBYnNvbHV0ZVBhdGhzLFxuICAgIHNwZWNQYXR0ZXJuLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZXNCeUdsb2IoXG4gIHByb2plY3RSb290OiBzdHJpbmcsXG4gIGdsb2I6IEdsb2JQYXR0ZXJuLFxuICBnbG9iT3B0aW9uczogR2xvYmJ5T3B0aW9uc1xuKSB7XG4gIGNvbnN0IHdvcmtpbmdEaXJlY3RvcnlQcmVmaXggPSBwYXRoLmpvaW4ocHJvamVjdFJvb3QsIHBhdGguc2VwKTtcbiAgY29uc3QgZ2xvYnMgPSAoW10gYXMgc3RyaW5nW10pXG4gICAgLmNvbmNhdChnbG9iKVxuICAgIC5tYXAoKGdsb2JQYXR0ZXJuKSA9PlxuICAgICAgZ2xvYlBhdHRlcm4uc3RhcnRzV2l0aChcIi4vXCIpID8gZ2xvYlBhdHRlcm4ucmVwbGFjZShcIi4vXCIsIFwiXCIpIDogZ2xvYlBhdHRlcm5cbiAgICApXG4gICAgLm1hcCgoZ2xvYlBhdHRlcm4pID0+IHtcbiAgICAgIC8vIElmIHRoZSBwYXR0ZXJuIGluY2x1ZGVzIHRoZSB3b3JraW5nIGRpcmVjdG9yeSwgd2Ugc3RyaXAgaXQgZnJvbSB0aGUgcGF0dGVybi5cbiAgICAgIC8vIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBwYXRoIG1heSBpbmNsdWRlIGNoYXJhY3RlcnMgdGhhdCBjb25mbGljdCB3aXRoIGdsb2JcbiAgICAgIC8vIHN5bnRheCAoYnJhY2tldHMsIHBhcmVudGhlc2VzLCBldGMuKSBhbmQgY2F1c2Ugb3VyIHNlYXJjaGVzIHRvIGluYWR2ZXJ0ZW50bHkgZmFpbC5cbiAgICAgIC8vIFdlIHNjb3BlIG91ciBzZWFyY2ggdG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IHVzaW5nIHRoZSBgY3dkYCBnbG9iYnkgb3B0aW9uLlxuICAgICAgaWYgKGdsb2JQYXR0ZXJuLnN0YXJ0c1dpdGgod29ya2luZ0RpcmVjdG9yeVByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXR0ZXJuLnJlcGxhY2Uod29ya2luZ0RpcmVjdG9yeVByZWZpeCwgXCJcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnbG9iUGF0dGVybjtcbiAgICB9KTtcblxuICBpZiAob3MucGxhdGZvcm0oKSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgLy8gZ2xvYmJ5IGNhbid0IHdvcmsgd2l0aCBiYWNrd2FyZHMgc2xhc2hlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ2xvYmJ5L2lzc3Vlcy8xNzlcbiAgICBkZWJ1ZyhcInVwZGF0aW5nIGdsb2IgcGF0dGVybnMgdG8gUE9TSVhcIik7XG4gICAgZm9yIChjb25zdCBpIGluIGdsb2JzKSB7XG4gICAgICBjb25zdCBjdXIgPSBnbG9ic1tpXTtcblxuICAgICAgaWYgKCFjdXIpIHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCBnbG9iIHJlY2VpdmVkXCIpO1xuXG4gICAgICBnbG9ic1tpXSA9IHRvUG9zaXgoY3VyKTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGRlYnVnKFwiZ2xvYmJpbmcgcGF0dGVybihzKTogJW9cIiwgZ2xvYnMpO1xuICAgIGRlYnVnKFwid2l0aGluIGRpcmVjdG9yeTogJXNcIiwgcHJvamVjdFJvb3QpO1xuXG4gICAgcmV0dXJuIG1hdGNoR2xvYnMoZ2xvYnMsIHtcbiAgICAgIG9ubHlGaWxlczogdHJ1ZSxcbiAgICAgIGFic29sdXRlOiB0cnVlLFxuICAgICAgY3dkOiBwcm9qZWN0Um9vdCxcbiAgICAgIC4uLmdsb2JPcHRpb25zLFxuICAgICAgaWdub3JlOiAoZ2xvYk9wdGlvbnM/Lmlnbm9yZSA/PyBbXSkuY29uY2F0KFwiKiovbm9kZV9tb2R1bGVzLyoqXCIpLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoXCJlcnJvciBpbiBnZXRGaWxlc0J5R2xvYiAlb1wiLCBlKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuY29uc3QgbWF0Y2hHbG9icyA9IGFzeW5jIChnbG9iczogR2xvYlBhdHRlcm4sIGdsb2JieU9wdGlvbnM6IEdsb2JieU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGF3YWl0IGdsb2JieShnbG9icywgZ2xvYmJ5T3B0aW9ucyk7XG59O1xuXG5pbnRlcmZhY2UgTWF0Y2hlZFNwZWNzIHtcbiAgcHJvamVjdFJvb3Q6IHN0cmluZztcbiAgdGVzdGluZ1R5cGU6IFRlc3RpbmdUeXBlO1xuICBzcGVjQWJzb2x1dGVQYXRoczogc3RyaW5nW107XG4gIHNwZWNQYXR0ZXJuOiBzdHJpbmcgfCBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlZFNwZWNzKHtcbiAgcHJvamVjdFJvb3QsXG4gIHRlc3RpbmdUeXBlLFxuICBzcGVjQWJzb2x1dGVQYXRocyxcbn06IE1hdGNoZWRTcGVjcykge1xuICBkZWJ1ZyhcImZvdW5kIHNwZWNzICVvXCIsIHNwZWNBYnNvbHV0ZVBhdGhzKTtcblxuICBsZXQgY29tbW9uUm9vdCA9IFwiXCI7XG5cbiAgaWYgKHNwZWNBYnNvbHV0ZVBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbW1vblJvb3QgPSBwYXRoLmRpcm5hbWUoc3BlY0Fic29sdXRlUGF0aHNbMF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbW1vblJvb3QgPSBjb21tb25QYXRoUHJlZml4KHNwZWNBYnNvbHV0ZVBhdGhzKTtcbiAgfVxuXG4gIHJldHVybiBzcGVjQWJzb2x1dGVQYXRocy5tYXAoKGFic29sdXRlKSA9PlxuICAgIHRyYW5zZm9ybVNwZWMoe1xuICAgICAgcHJvamVjdFJvb3QsXG4gICAgICBhYnNvbHV0ZSxcbiAgICAgIHRlc3RpbmdUeXBlLFxuICAgICAgY29tbW9uUm9vdCxcbiAgICAgIHBsYXRmb3JtOiBvcy5wbGF0Zm9ybSgpLFxuICAgICAgc2VwOiBwYXRoLnNlcCxcbiAgICB9KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybVNwZWMge1xuICBwcm9qZWN0Um9vdDogc3RyaW5nO1xuICBhYnNvbHV0ZTogc3RyaW5nO1xuICB0ZXN0aW5nVHlwZTogVGVzdGluZ1R5cGU7XG4gIGNvbW1vblJvb3Q6IHN0cmluZztcbiAgcGxhdGZvcm06IE5vZGVKUy5QbGF0Zm9ybTtcbiAgc2VwOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWMoe1xuICBwcm9qZWN0Um9vdCxcbiAgYWJzb2x1dGUsXG4gIHRlc3RpbmdUeXBlLFxuICBjb21tb25Sb290LFxuICBwbGF0Zm9ybSxcbiAgc2VwLFxufTogVHJhbnNmb3JtU3BlYykge1xuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGFic29sdXRlID0gdG9Qb3NpeChhYnNvbHV0ZSwgc2VwKTtcbiAgICBwcm9qZWN0Um9vdCA9IHRvUG9zaXgocHJvamVjdFJvb3QsIHNlcCk7XG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUocHJvamVjdFJvb3QsIGFic29sdXRlKTtcbiAgY29uc3QgcGFyc2VkRmlsZSA9IHBhdGgucGFyc2UoYWJzb2x1dGUpO1xuICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGFic29sdXRlKTtcblxuICBjb25zdCBzcGVjRmlsZUV4dGVuc2lvbiA9XG4gICAgW1wiLnNwZWNcIiwgXCIudGVzdFwiLCBcIi1zcGVjXCIsIFwiLXRlc3RcIiwgXCIuY3lcIl1cbiAgICAgIC5tYXAoKGV4dCkgPT4gZXh0ICsgZmlsZUV4dGVuc2lvbilcbiAgICAgIC5maW5kKChleHQpID0+IGFic29sdXRlLmVuZHNXaXRoKGV4dCkpIHx8IGZpbGVFeHRlbnNpb247XG5cbiAgY29uc3QgcGFydHMgPSBhYnNvbHV0ZS5zcGxpdChwcm9qZWN0Um9vdCk7XG4gIGxldCBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gfHwgXCJcIjtcblxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEpO1xuICB9XG5cbiAgY29uc3QgTEVBRElOR19TTEFTSCA9IC9eXFwvfC9nO1xuICBjb25zdCByZWxhdGl2ZVRvQ29tbW9uUm9vdCA9IGFic29sdXRlXG4gICAgLnJlcGxhY2UoY29tbW9uUm9vdCwgXCJcIilcbiAgICAucmVwbGFjZShMRUFESU5HX1NMQVNILCBcIlwiKTtcblxuICByZXR1cm4ge1xuICAgIGZpbGVFeHRlbnNpb24sXG4gICAgYmFzZU5hbWU6IHBhcnNlZEZpbGUuYmFzZSxcbiAgICBmaWxlTmFtZTogcGFyc2VkRmlsZS5iYXNlLnJlcGxhY2Uoc3BlY0ZpbGVFeHRlbnNpb24sIFwiXCIpLFxuICAgIHNwZWNGaWxlRXh0ZW5zaW9uLFxuICAgIHJlbGF0aXZlVG9Db21tb25Sb290LFxuICAgIHNwZWNUeXBlOiAodGVzdGluZ1R5cGUgPT09IFwiY29tcG9uZW50XCJcbiAgICAgID8gXCJjb21wb25lbnRcIlxuICAgICAgOiBcImludGVncmF0aW9uXCIpIGFzIFNwZWNUeXBlLFxuICAgIG5hbWUsXG4gICAgcmVsYXRpdmUsXG4gICAgYWJzb2x1dGUsXG4gIH07XG59XG4iLCAiaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkodmFsPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgcmV0dXJuIHZhbCA/ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gW3ZhbF0gOiB2YWwpIDogW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Bvc2l4KGZpbGU6IHN0cmluZywgc2VwOiBzdHJpbmcgPSBwYXRoLnNlcCkge1xuICByZXR1cm4gZmlsZS5zcGxpdChzZXApLmpvaW4ocGF0aC5wb3NpeC5zZXApO1xufVxuIiwgImltcG9ydCB7XG4gIEN1cnJlbnRzUnVuUGFyYW1ldGVycyxcbiAgVmFsaWRhdGVkQ3VycmVudHNQYXJhbWV0ZXJzLFxufSBmcm9tIFwiY3lwcmVzcy1jbG91ZC90eXBlc1wiO1xuaW1wb3J0IHsgTWVyZ2VkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9jb25maWdcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBmaW5kU3BlY3MgfSBmcm9tIFwiLi9zcGVjTWF0Y2hlclwiO1xuXG5leHBvcnQgY29uc3QgZ2V0U3BlY0ZpbGVzID0gYXN5bmMgKHtcbiAgY29uZmlnLFxuICBwYXJhbXMsXG59OiB7XG4gIGNvbmZpZzogTWVyZ2VkQ29uZmlnO1xuICBwYXJhbXM6IFZhbGlkYXRlZEN1cnJlbnRzUGFyYW1ldGVycztcbn0pID0+IHtcbiAgY29uc3Qgc3BlY1BhdHRlcm4gPSBnZXRTcGVjUGF0dGVybihjb25maWcuc3BlY1BhdHRlcm4sIHBhcmFtcy5zcGVjKTtcbiAgLy8gZmluZCB0aGUgc3BlYyBmaWxlcyBhY2NvcmRpbmcgdG8gdGhlIHJlc29sdmVkIGNvbmZpZ3VyYXRpb25cbiAgY29uc3Qgc3BlY3MgPSBhd2FpdCBmaW5kU3BlY3Moe1xuICAgIC8vIGh0dHBzOi8vZG9jcy5jeXByZXNzLmlvL2d1aWRlcy9ndWlkZXMvY29tbWFuZC1saW5lI2N5cHJlc3MtcnVuLXNwZWMtbHQtc3BlYy1ndFxuICAgIHByb2plY3RSb290OiBwYXJhbXMucHJvamVjdCA/PyBjb25maWcucHJvamVjdFJvb3QsXG4gICAgdGVzdGluZ1R5cGU6IHBhcmFtcy50ZXN0aW5nVHlwZSxcbiAgICBzcGVjUGF0dGVybixcbiAgICBjb25maWdTcGVjUGF0dGVybjogY29uZmlnLnNwZWNQYXR0ZXJuLFxuICAgIGV4Y2x1ZGVTcGVjUGF0dGVybjogY29uZmlnLmV4Y2x1ZGVTcGVjUGF0dGVybixcbiAgICBhZGRpdGlvbmFsSWdub3JlUGF0dGVybjogY29uZmlnLmFkZGl0aW9uYWxJZ25vcmVQYXR0ZXJuLFxuICB9KTtcbiAgaWYgKHNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHdhcm4oXG4gICAgICBcIkZvdW5kIG5vIHNwZWMgZmlsZXMuIFdhcyBsb29raW5nIGZvciBzcGVjIGZpbGVzIHRoYXQgbWF0Y2ggYm90aCBjb25maWdTcGVjUGF0dGVybiBhbmQgc3BlY1BhdHRlcm4gcmVsYXRpdmUgdG8gcHJvamVjdFJvb3QuIENvbmZpZ3VyYXRpb246ICVPXCIsXG4gICAgICB7XG4gICAgICAgIHByb2plY3RSb290OiBjb25maWcucHJvamVjdFJvb3QsXG4gICAgICAgIHNwZWNQYXR0ZXJuLFxuICAgICAgICBjb25maWdTcGVjUGF0dGVybjogY29uZmlnLnNwZWNQYXR0ZXJuLFxuICAgICAgICBleGNsdWRlU3BlY1BhdHRlcm46IFtcbiAgICAgICAgICBjb25maWcuZXhjbHVkZVNwZWNQYXR0ZXJuLFxuICAgICAgICAgIGNvbmZpZy5hZGRpdGlvbmFsSWdub3JlUGF0dGVybixcbiAgICAgICAgXS5mbGF0KDIpLFxuICAgICAgICB0ZXN0aW5nVHlwZTogcGFyYW1zLnRlc3RpbmdUeXBlLFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHsgc3BlY3MsIHNwZWNQYXR0ZXJuIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTcGVjUGF0dGVybihcbiAgY29uZmlnUGF0dGVybjogTWVyZ2VkQ29uZmlnW1wic3BlY1BhdHRlcm5cIl0sXG4gIGV4cGxpY2l0PzogQ3VycmVudHNSdW5QYXJhbWV0ZXJzW1wic3BlY1wiXVxuKSB7XG4gIHJldHVybiBleHBsaWNpdCB8fCBjb25maWdQYXR0ZXJuO1xufVxuIiwgImV4cG9ydCBjbGFzcyBDb25maWdTdGF0ZSB7XG4gIHByaXZhdGUgX2NvbmZpZzogQ3lwcmVzcy5SZXNvbHZlZENvbmZpZ09wdGlvbnMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIHB1YmxpYyBzZXRDb25maWcoYzogdHlwZW9mIHRoaXMuX2NvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGM7XG4gIH1cbiAgcHVibGljIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3lwcmVzc1J1bixcbiAgQ3lwcmVzc1NjcmVlbnNob3QsXG4gIEN5cHJlc3NUZXN0LFxuICBDeXByZXNzVGVzdEF0dGVtcHQsXG59IGZyb20gXCJjeXByZXNzLWNsb3VkL3R5cGVzXCI7XG5cbmltcG9ydCAqIGFzIFNwZWNBZnRlciBmcm9tIFwiLi4vcnVubmVyL3NwZWMudHlwZVwiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGVcIjtcbmltcG9ydCB7IGdldEZha2VUZXN0RnJvbUV4Y2VwdGlvbiB9IGZyb20gXCIuL3Jlc3VsdHNcIjtcblxuZnVuY3Rpb24gZ2V0U2NyZWVuc2hvdChzOiBTcGVjQWZ0ZXIuU2NyZWVuc2hvdCk6IEN5cHJlc3NTY3JlZW5zaG90IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zLFxuICAgIG5hbWU6IHMubmFtZSA/PyBcInNjcmVlbnNob3RcIixcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGVzdEF0dGVtcHQoXG4gIGF0dGVtcHQ6IFNwZWNBZnRlci5UZXN0QXR0ZW1wdCxcbiAgc2NyZWVuc2hvdHM6IFNwZWNBZnRlci5TY3JlZW5zaG90W11cbik6IEN5cHJlc3NUZXN0QXR0ZW1wdCB7XG4gIHJldHVybiB7XG4gICAgLi4uYXR0ZW1wdCxcbiAgICBzdGFydGVkQXQ6IGF0dGVtcHQud2FsbENsb2NrU3RhcnRlZEF0LFxuICAgIGR1cmF0aW9uOiBhdHRlbXB0LndhbGxDbG9ja0R1cmF0aW9uLFxuICAgIHNjcmVlbnNob3RzOiBzY3JlZW5zaG90cy5tYXAoZ2V0U2NyZWVuc2hvdCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRlc3QoXG4gIHQ6IFNwZWNBZnRlci5UZXN0LFxuICBzY3JlZW5zaG90czogU3BlY0FmdGVyLlNjcmVlbnNob3RbXVxuKTogQ3lwcmVzc1Rlc3Qge1xuICBjb25zdCBfc2NyZWVuc2hvdHMgPSBzY3JlZW5zaG90cy5maWx0ZXIoKHMpID0+IHMudGVzdElkID09PSB0LnRlc3RJZCk7XG4gIHJldHVybiB7XG4gICAgLi4udCxcbiAgICBhdHRlbXB0czogdC5hdHRlbXB0cy5tYXAoKGEsIGkpID0+XG4gICAgICBnZXRUZXN0QXR0ZW1wdChcbiAgICAgICAgYSxcbiAgICAgICAgX3NjcmVlbnNob3RzLmZpbHRlcigocykgPT4gcy50ZXN0QXR0ZW1wdEluZGV4ID09PSBpKVxuICAgICAgKVxuICAgICksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGVjUmVzdWx0c1RvQ3lwcmVzc1Jlc3VsdHMoXG4gIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgc3BlY0FmdGVyUmVzdWx0OiBTcGVjQWZ0ZXIuU3BlY1Jlc3VsdFxuKTogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHQge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogXCJmaW5pc2hlZFwiLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25maWc6IGNvbmZpZ1N0YXRlLmdldENvbmZpZygpLFxuICAgIHRvdGFsRHVyYXRpb246IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tEdXJhdGlvbixcbiAgICB0b3RhbFN1aXRlczogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnN1aXRlcyxcbiAgICB0b3RhbFRlc3RzOiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMudGVzdHMsXG4gICAgdG90YWxGYWlsZWQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5mYWlsdXJlcyxcbiAgICB0b3RhbFBhc3NlZDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnBhc3NlcyxcbiAgICB0b3RhbFBlbmRpbmc6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy5wZW5kaW5nLFxuICAgIHRvdGFsU2tpcHBlZDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLnNraXBwZWQsXG4gICAgc3RhcnRlZFRlc3RzQXQ6IHNwZWNBZnRlclJlc3VsdC5zdGF0cy53YWxsQ2xvY2tTdGFydGVkQXQsXG4gICAgZW5kZWRUZXN0c0F0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRW5kZWRBdCxcbiAgICBydW5zOiBbXG4gICAgICB7XG4gICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgLi4uc3BlY0FmdGVyUmVzdWx0LnN0YXRzLFxuICAgICAgICAgIHN0YXJ0ZWRBdDogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja1N0YXJ0ZWRBdCxcbiAgICAgICAgICBlbmRlZEF0OiBzcGVjQWZ0ZXJSZXN1bHQuc3RhdHMud2FsbENsb2NrRW5kZWRBdCxcbiAgICAgICAgICBkdXJhdGlvbjogc3BlY0FmdGVyUmVzdWx0LnN0YXRzLndhbGxDbG9ja0R1cmF0aW9uLFxuICAgICAgICB9LFxuICAgICAgICByZXBvcnRlcjogc3BlY0FmdGVyUmVzdWx0LnJlcG9ydGVyLFxuICAgICAgICByZXBvcnRlclN0YXRzOiBzcGVjQWZ0ZXJSZXN1bHQucmVwb3J0ZXJTdGF0cyA/PyB7fSxcbiAgICAgICAgc3BlYzogc3BlY0FmdGVyUmVzdWx0LnNwZWMsXG4gICAgICAgIGVycm9yOiBzcGVjQWZ0ZXJSZXN1bHQuZXJyb3IsXG4gICAgICAgIHZpZGVvOiBzcGVjQWZ0ZXJSZXN1bHQudmlkZW8sXG4gICAgICAgIHNob3VsZFVwbG9hZFZpZGVvOiB0cnVlLCAvLyBub3QgcmVhbGx5IHVzZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAvLyB3cm9uZyB0eXBlZGVmIGZvciBDeXByZXNzQ29tbWFuZExpbmUuQ3lwcmVzc1J1blJlc3VsdFxuICAgICAgICAvLyBhY3R1YWwgSG9va05hbWUgaXMgXCJiZWZvcmUgYWxsXCIgfCBcImJlZm9yZSBlYWNoXCIgfCBcImFmdGVyIGFsbFwiIHwgXCJhZnRlciBlYWNoXCJcbiAgICAgICAgaG9va3M6IHNwZWNBZnRlclJlc3VsdC5ob29rcyxcbiAgICAgICAgdGVzdHM6IChzcGVjQWZ0ZXJSZXN1bHQudGVzdHMgPz8gW10pLm1hcCgodCkgPT5cbiAgICAgICAgICBnZXRUZXN0KHQsIHNwZWNBZnRlclJlc3VsdC5zY3JlZW5zaG90cylcbiAgICAgICAgKSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGJhY2tmaWxsRXhjZXB0aW9uID0gKFxuICByZXN1bHQ6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0XG4pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgcnVuczogcmVzdWx0LnJ1bnMubWFwKGJhY2tmaWxsRXhjZXB0aW9uUnVuKSxcbiAgfTtcbn07XG5cbmNvbnN0IGJhY2tmaWxsRXhjZXB0aW9uUnVuID0gKHJ1bjogQ3lwcmVzc1J1bikgPT4ge1xuICBpZiAoIXJ1bi5lcnJvcikge1xuICAgIHJldHVybiBydW47XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnJ1bixcbiAgICB0ZXN0czogW2dldEZha2VUZXN0RnJvbUV4Y2VwdGlvbihydW4uZXJyb3IsIHJ1bi5zdGF0cyldLFxuICB9O1xufTtcbiIsICJpbXBvcnQgeyBJbnN0YW5jZUlkIH0gZnJvbSBcImN5cHJlc3MtY2xvdWQvdHlwZXNcIjtcbmltcG9ydCB7IGVycm9yLCB3YXJuIH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHsgZ2V0RmFpbGVkRHVtbXlSZXN1bHQgfSBmcm9tIFwiLi4vcmVzdWx0c1wiO1xuaW1wb3J0IHtcbiAgYmFja2ZpbGxFeGNlcHRpb24sXG4gIHNwZWNSZXN1bHRzVG9DeXByZXNzUmVzdWx0cyxcbn0gZnJvbSBcIi4uL3Jlc3VsdHMvbWFwUmVzdWx0XCI7XG5pbXBvcnQgeyBTcGVjUmVzdWx0IH0gZnJvbSBcIi4uL3J1bm5lci9zcGVjLnR5cGVcIjtcblxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgQ29uZmlnU3RhdGUgfSBmcm9tIFwiLi9jb25maWdcIjtcbmNvbnN0IGRlYnVnID0gRGVidWcoXCJjdXJyZW50czpzdGF0ZVwiKTtcblxudHlwZSBJbnN0YW5jZUV4ZWN1dGlvblN0YXRlID0ge1xuICBpbnN0YW5jZUlkOiBJbnN0YW5jZUlkO1xuICBzcGVjOiBzdHJpbmc7XG4gIG91dHB1dD86IHN0cmluZztcbiAgc3BlY0JlZm9yZT86IERhdGU7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgcnVuUmVzdWx0cz86IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0O1xuICBydW5SZXN1bHRzUmVwb3J0ZWRBdD86IERhdGU7XG4gIHNwZWNBZnRlcj86IERhdGU7XG4gIHNwZWNBZnRlclJlc3VsdHM/OiBTcGVjUmVzdWx0O1xuICByZXBvcnRTdGFydGVkQXQ/OiBEYXRlO1xuICBjb3ZlcmFnZUZpbGVQYXRoPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvblN0YXRlIHtcbiAgcHJpdmF0ZSB3YXJuaW5ncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIHN0YXRlOiBSZWNvcmQ8SW5zdGFuY2VJZCwgSW5zdGFuY2VFeGVjdXRpb25TdGF0ZT4gPSB7fTtcblxuICBwdWJsaWMgZ2V0V2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMud2FybmluZ3M7XG4gIH1cblxuICBwdWJsaWMgYWRkV2FybmluZyh3YXJuaW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLndhcm5pbmdzLmFkZCh3YXJuaW5nKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZXN1bHRzKGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUpLm1hcCgoaSkgPT5cbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2VSZXN1bHRzKGNvbmZpZ1N0YXRlLCBpLmluc3RhbmNlSWQpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnN0YW5jZShpbnN0YW5jZUlkOiBJbnN0YW5jZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gIH1cblxuICBwdWJsaWMgZ2V0U3BlYyhzcGVjOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlKS5maW5kKChpKSA9PiBpLnNwZWMgPT09IHNwZWMpO1xuICB9XG5cbiAgcHVibGljIGluaXRJbnN0YW5jZSh7XG4gICAgaW5zdGFuY2VJZCxcbiAgICBzcGVjLFxuICB9OiB7XG4gICAgaW5zdGFuY2VJZDogSW5zdGFuY2VJZDtcbiAgICBzcGVjOiBzdHJpbmc7XG4gIH0pIHtcbiAgICBkZWJ1ZygnSW5pdCBleGVjdXRpb24gc3RhdGUgZm9yIFwiJXNcIicsIHNwZWMpO1xuICAgIHRoaXMuc3RhdGVbaW5zdGFuY2VJZF0gPSB7XG4gICAgICBpbnN0YW5jZUlkLFxuICAgICAgc3BlYyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNCZWZvcmUoc3BlYzogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0U3BlYyhzcGVjKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3Igc3BlYyBcIiVzXCInLCBzcGVjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpLnNwZWNCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNDb3ZlcmFnZShzcGVjOiBzdHJpbmcsIGNvdmVyYWdlRmlsZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFNwZWMoc3BlYyk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIHNwZWMgXCIlc1wiJywgc3BlYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVidWcoXCJFeHBlcmltZW50YWw6IGNvdmVyYWdlRmlsZVBhdGggd2FzIHNldFwiKTtcbiAgICBpLmNvdmVyYWdlRmlsZVBhdGggPSBjb3ZlcmFnZUZpbGVQYXRoO1xuICB9XG5cbiAgcHVibGljIHNldFNwZWNBZnRlcihzcGVjOiBzdHJpbmcsIHJlc3VsdHM6IFNwZWNSZXN1bHQpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLnNwZWNBZnRlciA9IG5ldyBEYXRlKCk7XG4gICAgaS5zcGVjQWZ0ZXJSZXN1bHRzID0gcmVzdWx0cztcbiAgfVxuXG4gIHB1YmxpYyBzZXRTcGVjT3V0cHV0KHNwZWM6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTcGVjKHNwZWMpO1xuICAgIGlmICghaSkge1xuICAgICAgd2FybignQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBzcGVjIFwiJXNcIicsIHNwZWMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEluc3RhbmNlT3V0cHV0KGkuaW5zdGFuY2VJZCwgb3V0cHV0KTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnN0YW5jZU91dHB1dChpbnN0YW5jZUlkOiBzdHJpbmcsIG91dHB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5vdXRwdXQpIHtcbiAgICAgIGRlYnVnKCdJbnN0YW5jZSBcIiVzXCIgYWxyZWFkeSBoYXMgb3V0cHV0JywgaW5zdGFuY2VJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGkub3V0cHV0ID0gb3V0cHV0O1xuICB9XG5cbiAgcHVibGljIHNldEluc3RhbmNlUmVzdWx0KFxuICAgIGNvbmZpZ1N0YXRlOiBDb25maWdTdGF0ZSxcbiAgICBpbnN0YW5jZUlkOiBzdHJpbmcsXG4gICAgcmVzdWx0czogQ3lwcmVzc0NvbW1hbmRMaW5lLkN5cHJlc3NSdW5SZXN1bHRcbiAgKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuc3RhdGVbaW5zdGFuY2VJZF07XG4gICAgaWYgKCFpKSB7XG4gICAgICB3YXJuKCdDYW5ub3QgZmluZCBleGVjdXRpb24gc3RhdGUgZm9yIGluc3RhbmNlIFwiJXNcIicsIGluc3RhbmNlSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLnJ1blJlc3VsdHMgPSByZXN1bHRzO1xuICAgIGkucnVuUmVzdWx0c1JlcG9ydGVkQXQgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIGdldEluc3RhbmNlUmVzdWx0cyhcbiAgICBjb25maWdTdGF0ZTogQ29uZmlnU3RhdGUsXG4gICAgaW5zdGFuY2VJZDogc3RyaW5nXG4gICk6IEN5cHJlc3NDb21tYW5kTGluZS5DeXByZXNzUnVuUmVzdWx0IHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRJbnN0YW5jZShpbnN0YW5jZUlkKTtcblxuICAgIGlmICghaSkge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBmaW5kIGV4ZWN1dGlvbiBzdGF0ZSBmb3IgaW5zdGFuY2UgXCIlc1wiJywgaW5zdGFuY2VJZCk7XG5cbiAgICAgIHJldHVybiBnZXRGYWlsZWREdW1teVJlc3VsdChjb25maWdTdGF0ZSwge1xuICAgICAgICBzcGVjczogW1widW5rbm93blwiXSxcbiAgICAgICAgZXJyb3I6IFwiQ2Fubm90IGZpbmQgZXhlY3V0aW9uIHN0YXRlIGZvciBpbnN0YW5jZVwiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdXNlIHNwZWM6YWZ0ZXIgcmVzdWx0cyAtIGl0IGNhbiBiZWNvbWUgYXZhaWxhYmxlIGJlZm9yZSBydW4gcmVzdWx0c1xuICAgIGlmIChpLnNwZWNBZnRlclJlc3VsdHMpIHtcbiAgICAgIHJldHVybiBiYWNrZmlsbEV4Y2VwdGlvbihcbiAgICAgICAgc3BlY1Jlc3VsdHNUb0N5cHJlc3NSZXN1bHRzKGNvbmZpZ1N0YXRlLCBpLnNwZWNBZnRlclJlc3VsdHMpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpLnJ1blJlc3VsdHMpIHtcbiAgICAgIHJldHVybiBiYWNrZmlsbEV4Y2VwdGlvbihpLnJ1blJlc3VsdHMpO1xuICAgIH1cblxuICAgIGRlYnVnKCdObyByZXN1bHRzIGRldGVjdGVkIGZvciBcIiVzXCInLCBpLnNwZWMpO1xuICAgIHJldHVybiBnZXRGYWlsZWREdW1teVJlc3VsdChjb25maWdTdGF0ZSwge1xuICAgICAgc3BlY3M6IFtpLnNwZWNdLFxuICAgICAgZXJyb3I6IGBObyByZXN1bHRzIGRldGVjdGVkIGZvciB0aGUgc3BlYyBmaWxlLiBUaGF0IHVzdWFsbHkgaGFwcGVucyBiZWNhdXNlIG9mIGN5cHJlc3MgY3Jhc2guIFNlZSB0aGUgY29uc29sZSBvdXRwdXQgZm9yIGRldGFpbHMuYCxcbiAgICB9KTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUNBLE9BQU87OztBQ0RQLFNBQVMscUJBQXFCO0FBRXZCLElBQU1BLFdBQVUsY0FBYyxZQUFZLEdBQUc7OztBQ0ZwRCxPQUFPLFFBQVE7QUFDZixJQUFNLFVBQVUsR0FBRztBQUduQixHQUFHLFFBQVEsU0FBVSxTQUFTLE1BQU0sU0FBUztBQUUzQyxNQUFJLFFBQVEsTUFBTSxTQUFTLEdBQUc7QUFFNUIsVUFBTUMsV0FBVSxRQUFRLFNBQVMsTUFBTTtBQUFBLE1BQ3JDLEdBQUc7QUFBQTtBQUFBLE1BRUgsT0FBTyxDQUFDLFFBQVEsUUFBUSxNQUFNO0FBQUEsSUFDaEMsQ0FBQztBQUNELFdBQU9BO0FBQUEsRUFDVDtBQUdBLFNBQU8sUUFBUSxTQUFTLE1BQU0sT0FBTztBQUN2Qzs7O0FDbEJBLE9BQU8sV0FBVztBQUNsQixPQUFPLFVBQVU7QUFFakIsT0FBTyxvQkFBb0I7QUFDM0IsU0FBUyxPQUFPLFNBQVM7QUFDekIsWUFBWSxlQUFlOzs7QUNMM0IsT0FBTyxr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QUNqRSxNQUFBQSxRQUFNLG9CQUFvQixNQUFNLE9BQU87QUFDdkMscUJBQWUsYUFBYSxLQUFLLFVBQVUsT0FBTztBQUNsRCxxQkFBZSxjQUFjLEtBQUssVUFBVSxrQkFBa0IsQ0FBQztBQUUvRCxVQUFJLCtCQUErQjtBQUNqQyxjQUFNLEVBQUUsTUFBQUssT0FBTSxPQUFBQyxPQUFNLElBQUksTUFBTTtBQUFBLFVBQzVCLFFBQVEsS0FBSztBQUFBLFFBQ2Y7QUFDQSxZQUFJLENBQUNBLFFBQU87QUFDVix5QkFBZSxnQkFBZ0IsS0FBSyxVQUFVRCxLQUFJO0FBQUEsUUFDcEQsT0FBTztBQUNMLHlCQUFlO0FBQUEsWUFDYixvQ0FBb0NBO0FBQUEsRUFBVSxJQUFJQyxNQUFLO0FBQUEsVUFDekQ7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLDJCQUFxQixhQUFhLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxJQUNqRTtBQUFBLEVBQ0Y7QUFDRjtBQUVBLFNBQVNGLGVBQWMsZ0JBQWdDO0FBQ3JELFFBQU0sV0FBVyxNQUFNLEtBQUssZUFBZSxZQUFZLENBQUM7QUFDeEQsTUFBSSxTQUFTLFNBQVMsR0FBRztBQUN2QjtBQUFBLE1BQ0UsR0FBRyxTQUFTLFVBQVU7QUFBQSxRQUNwQjtBQUFBLFFBQ0EsU0FBUztBQUFBLE1BQ1g7QUFBQSxFQUF3QyxTQUNyQyxJQUFJLENBQUMsR0FBRyxNQUFNO0FBQUEsRUFBSyxPQUFPLElBQUksSUFBSSxLQUFLLFNBQVMsU0FBUyxLQUFLLEdBQUcsRUFDakUsS0FBSyxJQUFJO0FBQUEsSUFDZDtBQUFBLEVBQ0Y7QUFDRjs7O0FsQjVNTyxTQUFTRyxLQUFJLFFBQXlCO0FBQzNDLFNBQU8sSUFBWSxNQUFNO0FBQzNCOyIsCiAgIm5hbWVzIjogWyJyZXF1aXJlIiwgInByb2Nlc3MiLCAiZXJyb3IiLCAiRGVidWciLCAiZGVidWciLCAiZGVidWciLCAibG9nIiwgIkRlYnVnIiwgIl8iLCAiRGVidWciLCAiUCIsICJtYXRjaCIsICJEZWJ1ZyIsICJwYXRoIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInJlcXVpcmUiLCAic3Rkb3V0IiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAibWF0Y2giLCAiUCIsICJEZWJ1ZyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiXyIsICJfIiwgImRlYnVnIiwgIkRlYnVnIiwgIl8iLCAiZXJyb3IiLCAicmVxdWlyZSIsICJEZWJ1ZyIsICJfIiwgIl8iLCAicGxhdGZvcm0iLCAic3Rkb3V0IiwgIl8iLCAiZGVidWciLCAiXyIsICJfIiwgImRlYnVnIiwgImRlYnVnRm4iLCAiXyIsICJkZWJ1ZyIsICJkZWJ1Z0ZuIiwgIl8iLCAiZnMiLCAiam9pbiIsICJwYXRoIiwgImVycm9yIiwgIkRlYnVnIiwgIl8iLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJlcnJvciIsICJkZWJ1ZyIsICJtYXRjaCIsICJQIiwgIm1hdGNoIiwgIlAiLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJkZWJ1ZyIsICJlcnJvciIsICJydW4iLCAiXyIsICJfIiwgInIiLCAiRGVidWciLCAiRGVidWciLCAiRGVidWciLCAiZnMiLCAiZnMiLCAiZGVidWciLCAiRGVidWciLCAiZmlsZSIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJzdGRvdXQiLCAicnVuIiwgIkRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgInBsYXRmb3JtIiwgImVycm9yIiwgIkRlYnVnIiwgInBhdGgiLCAiXyIsICJwYXRoIiwgImZpbGUiLCAiZGVidWciLCAiRGVidWciLCAiXyIsICJwYXRoIiwgInBsYXRmb3JtIiwgImdldFRlc3RBdHRlbXB0IiwgInJ1biIsICJEZWJ1ZyIsICJkZWJ1ZyIsICJkZWJ1ZyIsICJEZWJ1ZyIsICJwbGF0Zm9ybSIsICJydW4iLCAicHJpbnRXYXJuaW5ncyIsICJwYXRoIiwgImVycm9yIiwgInJ1biJdCn0K